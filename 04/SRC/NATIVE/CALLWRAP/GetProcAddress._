#define lib MACRO_project_prefix_HIDDEN  //: Private  //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //: Public   //: 02 ://
#define GM1( a , b )      a## _ ##b      //: GLUEMAC  //: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //: GLUEMAC  //: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 
#define EII(  nam  ) K_2( LIB, EII, nam )//:INIT_FUNC //: 12 ://
#define ARG(  nam  ) GM2( ARG   ,   nam )//:Argument  //: 13 ://
#define VAR(  nam  ) GM2( VAR   ,   nam )//:Local_Var //: 14 ://
#define RET(  nam  ) GM2( RET   ,   nam )//:RET___Var //: 15 ://
#define fun(  nam  ) GM2( f_2020_04_23_0258AM, nam )  //: 16 :// 
#define NIL  ((void*)0)                               //: 17 ://
#define  H   fun(Halt)                                //: 18 ://
#define  D   fun(Dmsg)                                //: 19 ://



    #define SRC_NATIVE_CALLWRAP_GETPROCADDRESS ( 434 )
    


//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/NATIVE/CALLWRAP/GetProcAddress:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/NATIVE/CALLWRAP/GetProcAddress:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://


//:INSTANCES: //:////////////////////////////////////////////://

    void* INS( dll_k32 ) = NIL; //:Kernel32.dll pointer
    void* INS( dll_u32 ) = NIL; //:User32.dll   pointer
    void* INS( dll_g32 ) = NIL; //:Gdi32.dll    pointer
    void* INS( dll_vuk ) = NIL; //:vulkan-1.dll pointer

//:TYPEDEFS: ////////////////////////////////////////////////://

    typedef void (* TYP(Func) )(void); //:Function pointer.
    typedef void*   TYP(Data)        ; //:Data     pointer.
    typedef const char* TYP(Str)     ; //:String   pointer.

    //:TYPEDEF_FARPROC / DLLL_FUNC / DFUN
    //:DFUN=="DLL Function"
    typedef
        unsigned long long               //:RETURNS
        ( __stdcall  *TYP(DFUN)       )  //:NAME
        ( /**NOT_SPECIFIED != void**/ ); //:PARAMS



//:FORWARD_DECLARATIONS: //://///////////////////////////////://

    void EII( SRC_NATIVE_CALLWRAP_getprocaddress )( void );

    TYP(Data) fun(LoadLibrary)( TYP(Str) dll_nam );

    TYP(Func) 
    FUN(GetProcAddress)(
        TYP(Str) dll_nam
    ,   TYP(Str) fun_nam
    );

    TYP(Func)
    fun(GetProcAddress)(
        TYP(Data) dll_ptr
    ,   TYP(Str)  fun_nam
    );

//:FUNCTIONS: //:////////////////////////////////////////////://

    //:Initializer code for this file:
    //:EII: Existance_Is_Initialization
    void EII( SRC_NATIVE_CALLWRAP_getprocaddress )( void ){
        D("[EII:BEG]");

        fun( LoadLibrary )( "dll_k32" );

        //:GPA Test:
        ////////////////////////////////////////////////////////
        printf("[GPA_TEST...]\n\n\n");

        TYP(Func) VAR(CreateWindowExW)=
        FUN(GetProcAddress)("dll_u32","CreateWindowExW");
        
        if( NIL == VAR(CreateWindowExW) ){
            printf("[FILE:GetProcAddress:FAIL:GPA_CWEXW]");
            fflush(stdout);exit(4);
        };;
        ////////////////////////////////////////////////////////

        //:Make absolutely sure all public variables are
        //:non-null before exiting "EII" function:
        //:EIIEIIEIIEIIEIIEIIEIIEII//EIIEIIEIIEIIEIIEIIEIIEII://

        fun( LoadLibrary )( "dll_k32" ); //:Kernel32.dll
        fun( LoadLibrary )( "dll_u32" ); //:User32.dll
        fun( LoadLibrary )( "dll_g32" ); //:Gdi32.dll

        if( NIL == INS(dll_k32) ){ H("[NOLOAD:dll_k32]");};
        if( NIL == INS(dll_u32) ){ H("[NOLOAD:dll_u32]");};
        if( NIL == INS(dll_g32) ){ H("[NOLOAD:dll_g32]");};

        //:make_sure_all_function_pointers_unique:
        #define I1  INS(dll_k32) //://///////////////////////://
        #define I2  INS(dll_u32) //://///////////////////////://
        #define I3  INS(dll_g32) //://///////////////////////://
        #define    L_E_N ( 3 )   //://///////////////////////://
        void* arr[ L_E_N ]={ I1,I2,I3 };
        for( int a = 0; a < L_E_N; a++ ){  //:- - - - - - - -://
        for( int b = 0; b < L_E_N; b++ ){  //:- - - - - - - -://
            if( a==b ){ continue; };
            if( arr[a]==arr[b] ){ H("[FAIL:NOT_A_SET]");};
        };;};;D("[PASS:YES_A_SET]");
        #undef  L_E_N //:////////////////////////////////////://
        #define I1  INS(dll_k32) //://///////////////////////://
        #define I2  INS(dll_u32) //://///////////////////////://
        #define I3  INS(dll_g32) //://///////////////////////://

        //:EIIEIIEIIEIIEIIEIIEIIEII//EIIEIIEIIEIIEIIEIIEIIEII://

        D("[EII:END]");
    }

    TYP(Data) fun(LoadLibrary)(
        TYP(Str) ARG(dll_nam)
    ){

        printf("[dll_nam]:%s\n", ARG(dll_nam));

        TYP(Data) 
        VAR(Data)=NIL;
        if( VAR(Data) ){ /** NOOP **/ };

        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_k32"
        &&  ARG(dll_nam)[4] == 'k' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:kernel32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("kernel32.dll");
            INS(dll_k32)=( VAR(Data) ); //:CACHE_YOUR_DLL

        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_u32"
        &&  ARG(dll_nam)[4] == 'u' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:user32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("user32.dll");
            INS(dll_u32)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_g32"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:gdi32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("gdi32.dll");
            INS(dll_g32)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( 1 ){
            //:If dll_name is not a shorthand name,
            //:load it as is.

            printf("[CHECK:DoesDLLNameLookCorrect?]%s\n"
            , ARG(dll_nam) );fflush( stdout );

            VAR(Data)=DLLL_LoadLibraryA( ARG(dll_nam) );
        };;

        if( NIL == VAR(Data) ){
            printf("[NullLoadedLibrary]");
            fflush(stdout); exit(4);
        };;

        return(   VAR(Data) );
    }

    TYP(Func) 
    FUN(GetProcAddress)(
        TYP(Str)  ARG(dll_nam)
    ,   TYP(Str)  ARG(fun_nam)
    ){
        TYP(Data)   VAR(dll_ptr) =NIL;

        //:Make sure dll is loaded:
        ////////////////////////////////////////////////////////
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_k32"
        &&  ARG(dll_nam)[4] == 'k' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_k32 ) ){

                INS(dll_k32)= 
                fun( LoadLibrary )( "kernel32.dll" );
            };;
            assert(      INS(dll_k32) );
            VAR(dll_ptr)=INS(dll_k32);
                
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_u32"
        &&  ARG(dll_nam)[4] == 'u' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_u32 ) ){

                INS(dll_u32)= 
                fun( LoadLibrary )( "user32.dll" );
            };;
            assert(      INS(dll_u32) );
            VAR(dll_ptr)=INS(dll_u32);

        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_g32"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_g32 ) ){

                INS(dll_g32)= 
                fun( LoadLibrary )( "gdi32.dll" );
            };;
            assert(      INS(dll_g32) );
            VAR(dll_ptr)=INS(dll_g32);
                
        }else{
            printf("[UnknownValueOf:dll_nam]:%s\n"
            , ARG(dll_nam));;

            fflush(stdout);
            exit(4);
        };;
        ////////////////////////////////////////////////////////

        //:Assert DLL pointer is not null:
        if( NIL==VAR(dll_ptr) ){
            printf("[DLL_PTR_NULL]\n");
            fflush(stdout);
            exit(4);
        };;

        //:Get function address from dll:
        ////////////////////////////////////////////////////////
        TYP(Func)
        VAR(GetProcAddress)=
        fun(GetProcAddress)(
            VAR(dll_ptr)
        ,   ARG(fun_nam)
        );;
        ////////////////////////////////////////////////////////

        return( VAR(GetProcAddress) );

    }

    //:Prviate version of "GetProcAddress" wrapper:
    TYP(Func)
    fun(GetProcAddress)(
        TYP(Data) ARG(dll_ptr)
    ,   TYP(Str)  ARG(fun_nam)
    ){
        TYP(DFUN) 
        VAR(DFUN)=DLLL_GetProcAddress( 
            ARG(dll_ptr)
        ,   ARG(fun_nam) 
        );;
        
        //:Cast dll function to generic function pointer:
        TYP(Func) RET(DFUN)=(
            (TYP(Func)) VAR(DFUN)
        );;

        //:Output/return:
        return( RET(DFUN) );
    }



#undef  lib  ///////////////////////////////////////////: 01 ://
#undef  LIB  ///////////////////////////////////////////: 02 ://
#undef  GM1  ///////////////////////////////////////////: 03 ://
#undef  GM2  ///////////////////////////////////////////: 04 ://
#undef  K_1  ///////////////////////////////////////////: 05 ://
#undef  K_2  ///////////////////////////////////////////: 06 ://                                   
#undef  MAK  ///////////////////////////////////////////: 07 ://   
#undef  TYP  ///////////////////////////////////////////: 08 ://   
#undef  INS  ///////////////////////////////////////////: 09 ://   
#undef  FUN  ///////////////////////////////////////////: 10 :// 
#undef  EXA  ///////////////////////////////////////////: 11 :// 
#undef  EII  ///////////////////////////////////////////: 12 ://
#undef  ARG  ///////////////////////////////////////////: 13 ://
#undef  VAR  ///////////////////////////////////////////: 14 ://
#undef  RET  ///////////////////////////////////////////: 15 ://
#undef  fun  ///////////////////////////////////////////: 16 :// 
#undef  NIL  ///////////////////////////////////////////: 17 ://
#undef   H   ///////////////////////////////////////////: 18 ://
#undef   D   ///////////////////////////////////////////: 19 ://
