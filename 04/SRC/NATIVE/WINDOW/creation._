//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1127AM_SNWC, n) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1127AM_SNWC, n) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1127AM_SNWC, n) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1127AM_SNWC, n) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1127AM_SNWC, n) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1127AM_SNWC, n) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1127AM_SNWC, n) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1127AM_SNWC, n) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1127AM_SNWC, n) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1127AM_SNWC, n) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1127AM_SNWC, n) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1127AM_SNWC, n) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1127AM_SNWC, n) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1127AM_SNWC, n) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1127AM_SNWC, n) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1127AM_SNWC, n) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:path to this file:
    #define  SRC_NATIVE_WINDOW_CREATION ( 1 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//[THINGS_ID_LIKE_YOU_TO_SEE_FIRST:11111111111111111111111111]//

    
    typedef void* 
        TYP(con_win);
        TYP(con_win) 
    FUN(SRC_NATIVE_WINDOW_CREATION_GetWinDC)( void );



//[11111111111111111111111111:THINGS_ID_LIKE_YOU_TO_SEE_FIRST]//
//:STRUCTS: SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS://

    //[  SEE[ VG03.ALL's F09_STRUCT_PIXELFORMATDESCRIPTOR ]  ]//
    //[  docs.microsoft.com/en-us/windows/win32/api/wingdi   ]//
    //[  /ns-wingdi-pixelformatdescriptor                    ]//
    #define B_04 unsigned long  /**DWORD **/  //:////////////://
    #define B_02 unsigned short /** WORD **/  //:////////////://
    #define B_01 unsigned char  /** BYTE **/  //:////////////://
    struct TYP(PIXELFORMATDESCRIPTOR) {  
    /**  01  **/    B_02  nSize;             
    /**  02  **/    B_02  nVersion;          
    /**  --  **/                          
    /**  03  **/    B_04  dwFlags;            
    /**  --  **/                          
    /**  04  **/    B_01  iPixelType;        
    /**  05  **/    B_01  cColorBits;        
    /**  06  **/    B_01  cRedBits;          
    /**  07  **/    B_01  cRedShift;         
    /**  08  **/    B_01  cGreenBits;        
    /**  09  **/    B_01  cGreenShift;       
    /**  10  **/    B_01  cBlueBits;         
    /**  11  **/    B_01  cBlueShift;        
    /**  12  **/    B_01  cAlphaBits;        
    /**  13  **/    B_01  cAlphaShift;       
    /**  14  **/    B_01  cAccumBits;        
    /**  15  **/    B_01  cAccumRedBits;     
    /**  16  **/    B_01  cAccumGreenBits;   
    /**  17  **/    B_01  cAccumBlueBits;    
    /**  18  **/    B_01  cAccumAlphaBits;   
    /**  19  **/    B_01  cDepthBits;        
    /**  20  **/    B_01  cStencilBits;      
    /**  21  **/    B_01  cAuxBuffers;       
    /**  22  **/    B_01  iLayerType;        
    /**  23  **/    B_01  bReserved;         
    /**  --  **/                          
    /**  24  **/    B_04  dwLayerMask;        
    /**  25  **/    B_04  dwVisibleMask;      
    /**  26  **/    B_04  dwDamageMask;       
    /**  --  **/
    };//[struct]//
    #undef  B_04 ////////////// /**DWORD **/  //:////////////://
    #undef  B_02 ////////////// /** WORD **/  //:////////////://
    #undef  B_01 ////////////// /** BYTE **/  //:////////////://

    //:winuser.h
    struct TYP(WIN32POINT){

        long x;         //:TAKEN_FROM:VGK03.ALL:
        long y;         //:F09_STRUCT_POINT && F09_STRUCT_MSG

    }ins(win32point)={
        0
    };

    //:winuser.h
    struct TYP(WINMSG){  //:WINDOW's "MSG" type:

        void*                    hwnd    ;  //: HWND    ://
        unsigned   int           message ;  //: UINT    ://
        unsigned __int64         wParam  ;  //: WPARAM  ://

                 __int64         lParam  ;  //: LPARAM  ://
        unsigned    long         time    ;  //: DWORD   ://

        struct  TYP(WIN32POINT)  pt      ;  //: POINT   ://
        unsigned    long         lPrivate;  //: DWORD   ://

    }ins(winmsg)={
        0
    };

//:SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS :STRUCTS://
//:TYPEDEFS: TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://

    //:Generic function pointer type:
    ////////////////////////////////////////////////////////////

    //:Did not expect something like TYP(FUN) to expanded
    //:correctly. But maybe we should avoid that?

    typedef 
        void (* TYP(FUN) )(void);

    typedef
        int TYP(TYP);
    ////////////////////////////////////////////////////////////

    //:Generic function pointer type:
    typedef void (* TYP(Func) )(void); //:Function pointer.
    typedef void*   TYP(Data)        ; //:Data     pointer.

    // ------------------------------------------------------ //
    typedef 
        __int64
        (__stdcall *TYP(WNDPROC) )(
            void*             //: HWND
        ,   unsigned   int    //: UINT
        ,   unsigned __int64  //: WPARAM
        ,            __int64  //: LPARAM
        );
    // ------------------------------------------------------ //
    struct TYP(WNDCLASSEXW) {
                    unsigned int   cbSize       ;
                    unsigned int   style        ;
                    TYP(WNDPROC)   lpfnWndProc  ;
                             int   cbClsExtra   ;
                             int   cbWndExtra   ;
                            void*  hInstance    ;
                            void*  hIcon        ;
                            void*  hCursor      ;
                            void*  hbrBackground;
            const unsigned short*  lpszMenuName ;
            const unsigned short*  lpszClassName;
                            void*  hIconSm      ;
    };
    // ------------------------------------------------------ //

//:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT: TYPEDEFS://
//:FORWARD_DECLARATIONS::FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF://
    __stdcall
    __int64 //:LRESULT
    fun(WinMsgHanWndPoc)(
    /**/           void*    han_win   //:HWND
    ,   unsigned   int      Msg       //:...?...
    ,   unsigned __int64    wParam    //:WPARAM
    ,            __int64    lParam    //:LPARAM
    );

    char*
    fun(MakeIntResourceA)( int i );

    //:This function is registered with the main game loop.
    //:It does NOT need to be public, since this file
    //:does the registering, not the game loop file.
    void fun( WindowTick )( void );

//:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF::FORWARD_DECLARATIONS://
//:INSTANCES: IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII://

    int ins(frames_without_window)=(0-1); //:negative==unset

    struct TYP(WNDCLASSEXW) INS(WNDCLASSEXW)={0};
    void*  INS(han_exe)=(NIL); //:AKA:handle_to_exe
    void*  INS(dek_win)=(NIL); //:AKA:the_desktop_window
    void*  ins(han_win)=(NIL); //:AKA:handle_to_YOUR_window
    void*  ins(con_win)=(NIL); //:AKA:window_device_context

    #define NOT_UNICODE_I_SWEAR const unsigned short //://///://
    //://////////////////////////////////////////////////////://

    NOT_UNICODE_I_SWEAR*      //:AKA:unique_window_name
    INS(win_nam)=( L"2020_4_22:UNIQUE_WINDOW_NAME"     );

    NOT_UNICODE_I_SWEAR*      //:AKA:titlebar_text
    INS(tib_tex)=( L"[FLIP_THE_FUCKING_TABLE!]((╯°□°）╯︵ ┻━┻))" );

    //://////////////////////////////////////////////////////://
    #undef  NOT_UNICODE_I_SWEAR //://////////////////////////://
    
    //:FUNCTION_POINTERS:  FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://
            
    TYP(FUN)    INS(CreateWindowExW  )=( NIL );
    TYP(FUN)    INS(GetDesktopWindow )=( NIL );
    TYP(FUN)    INS(RegisterClassExW )=( NIL );
    TYP(FUN)    INS(LoadIconA        )=( NIL );
    TYP(FUN)    INS(LoadCursorA      )=( NIL );
    TYP(FUN)    INS(GetModuleHandleW )=( NIL );
    TYP(FUN)    INS(DefWindowProcW   )=( NIL );
    TYP(FUN)    INS(DestroyWindow    )=( NIL );
    TYP(FUN)    INS(PostQuitMessage  )=( NIL );
    TYP(FUN)    INS(GetWindowDC      )=( NIL );
    TYP(FUN)    INS(ChoosePixelFormat)=( NIL );
    TYP(FUN)    INS(SetPixelFormat   )=( NIL );
    TYP(FUN)    INS(ShowWindow       )=( NIL );
    TYP(FUN)    INS(UpdateWindow     )=( NIL );
    TYP(FUN)    INS(SetFocus         )=( NIL );
    TYP(FUN)    INS(PeekMessageW     )=( NIL );
    TYP(FUN)    INS(TranslateMessage )=( NIL );
    TYP(FUN)    INS(DispatchMessageW )=( NIL );

    //:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP  :FUNCTION_POINTERS://

    struct TYP(PIXELFORMATDESCRIPTOR) INS(fod_pix)={0};
    int    ins(fmt_num)=( 0 ); //:pixel_format_number

//:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII: INSTANCES://

//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/NATIVE/WINDOW/creation._:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/NATIVE/WINDOW/creation._:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG:// 

int FUN( SRC_NATIVE_WINDOW_creation )( void ){
printf("[SRC_NATIVE_WINDOW_creation]\n");

    //:STEPS: 
    //: 1: EII: Existance_Is_Initialization
    //:         Front load resources first and make sure
    //:         they all are valid.
    //:
    //: 2: Register Your Window "Class".
    //:
    //: 3: .....todo...

    TYP(TYP)     int_a = 5;
    VG04_TYP_TYP int_b = 6;
    printf("[int_a]:%d\n", int_a);
    printf("[int_b]:%d\n", int_b);

    //:EII:Existance_Is_Initialization:(BELOW):--------------://
    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://

    //: INS( variable_names ) : Public, Init immediately here.
    //: ins( variable_names ) : Private,Init before func exits.
    //: MORE_INFO[ SC[ EII_INS_INS_RULES ] ]

    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://

    ////////////////////////////////////////////////////////////
    INS(CreateWindowExW)=
    FUN(GetProcAddress)("dll_u32","CreateWindowExW");

    INS(GetDesktopWindow)=
    FUN(GetProcAddress)("dll_u32","GetDesktopWindow");

    INS(RegisterClassExW)=
    FUN(GetProcAddress)("dll_u32","RegisterClassExW");

    INS(LoadIconA)=
    FUN(GetProcAddress)("dll_u32","LoadIconA");

    INS(LoadCursorA)=
    FUN(GetProcAddress)("dll_u32","LoadCursorA");

    INS(GetModuleHandleW)= //: "kernel32.dll"
    FUN(GetProcAddress)("dll_k32","GetModuleHandleW");

    INS(DefWindowProcW)=
    FUN(GetProcAddress)("dll_u32","DefWindowProcW");

    INS(DestroyWindow)=
    FUN(GetProcAddress)("dll_u32","DestroyWindow");

    INS(PostQuitMessage)=
    FUN(GetProcAddress)("dll_u32","PostQuitMessage");

    INS(GetWindowDC)=
    FUN(GetProcAddress)("dll_u32","GetWindowDC");

    INS(ChoosePixelFormat)= //: "gdi32.dll"
    FUN(GetProcAddress)("dll_g32","ChoosePixelFormat");

    INS(SetPixelFormat)= //: "gdi32.dll"
    FUN(GetProcAddress)("dll_g32","SetPixelFormat");

    INS(ShowWindow)=
    FUN(GetProcAddress)("dll_u32","ShowWindow");

    INS(UpdateWindow)=
    FUN(GetProcAddress)("dll_u32","UpdateWindow");

    INS(SetFocus)=
    FUN(GetProcAddress)("dll_u32","SetFocus");

    INS(PeekMessageW)=
    FUN(GetProcAddress)("dll_u32","PeekMessageW");

    INS(TranslateMessage)=
    FUN(GetProcAddress)("dll_u32","TranslateMessage");

    INS(DispatchMessageW)=
    FUN(GetProcAddress)("dll_u32","DispatchMessageW");



    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://
    if( ((void*)0) != INS(CreateWindowExW) ){
        D("[SUCCESS:CreateWindowExW]");
    }else{
        H("[FAILURE:CreateWindowExW]");
    };;
    if( ((void*)0) != INS(GetDesktopWindow) ){
        D("[SUCCESS:GetDesktopWindow]");
    }else{
        H("[FAILURE:GetDesktopWindow]");
    };;
    if( ((void*)0) != INS(RegisterClassExW) ){
        D("[SUCCESS:RegisterClassExW]");
    }else{
        H("[FAILURE:RegisterClassExW]");
    };;
    if( ((void*)0) != INS(LoadIconA) ){
        D("[SUCCESS:LoadIconA]");
    }else{
        H("[FAILURE:LoadIconA]");
    };;
    if( ((void*)0) != INS(LoadCursorA) ){
        D("[SUCCESS:LoadCursorA]");
    }else{
        H("[FAILURE:LoadCursorA]");
    };;
    if( ((void*)0) != INS(GetModuleHandleW) ){
        D("[SUCCESS:GetModuleHandleW]");
    }else{
        H("[FAILURE:GetModuleHandleW]");
    };;
    if( ((void*)0) != INS(DefWindowProcW) ){
        D("[SUCCESS:DefWindowProcW]");
    }else{
        H("[FAILURE:DefWindowProcW]");
    };;
    if( ((void*)0) != INS(DestroyWindow) ){
        D("[SUCCESS:DestroyWindow]");
    }else{
        H("[FAILURE:DestroyWindow]");
    };;
    if( ((void*)0) != INS(PostQuitMessage) ){
        D("[SUCCESS:PostQuitMessage]");
    }else{
        H("[FAILURE:PostQuitMessage]");
    };;
    if( ((void*)0) != INS(GetWindowDC) ){
        D("[SUCCESS:GetWindowDC]");
    }else{
        H("[FAILURE:GetWindowDC]");
    };;
    if( ((void*)0) != INS(ChoosePixelFormat) ){
        D("[SUCCESS:ChoosePixelFormat]");
    }else{
        H("[FAILURE:ChoosePixelFormat]");
    };;
    if( ((void*)0) != INS(SetPixelFormat) ){
        D("[SUCCESS:SetPixelFormat]");
    }else{
        H("[FAILURE:SetPixelFormat]");
    };;
    if( ((void*)0) != INS(ShowWindow) ){
        D("[SUCCESS:ShowWindow]");
    }else{
        H("[FAILURE:ShowWindow]");
    };;
    if( ((void*)0) != INS(UpdateWindow) ){
        D("[SUCCESS:UpdateWindow]");
    }else{
        H("[FAILURE:UpdateWindow]");
    };;
    if( ((void*)0) != INS(SetFocus) ){
        D("[SUCCESS:SetFocus]");
    }else{
        H("[FAILURE:SetFocus]");
    };;
    if( ((void*)0) != INS(PeekMessageW) ){
        D("[SUCCESS:PeekMessageW]");
    }else{
        H("[FAILURE:PeekMessageW]");
    };;
    if( ((void*)0) != INS(TranslateMessage) ){
        D("[SUCCESS:TranslateMessage]");
    }else{
        H("[FAILURE:TranslateMessage]");
    };;
    if( ((void*)0) != INS(DispatchMessageW) ){
        D("[SUCCESS:DispatchMessageW]");
    }else{
        H("[FAILURE:DispatchMessageW]");
    };;

    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://
    //[SC[MSA_FPU_CXX](BELOW)////////////////////////////////]//
    //:make_sure_all_function_pointers_unique:      //|  --  |//
    #define       L_E_N (         18+1)  //://///////////////://
    TYP(FUN) arr[ L_E_N ]={     0x00                //|  --  |//
    ,INS(CreateWindowExW   ) /**  01  **/           //|  01  |//
    ,INS(GetDesktopWindow  ) /**  02  **/           //|  02  |//
    ,INS(RegisterClassExW  ) /**  03  **/           //|  03  |//
    ,INS(LoadIconA         ) /**  04  **/           //|  04  |//
    ,INS(LoadCursorA       ) /**  05  **/           //|  05  |//
    ,INS(GetModuleHandleW  ) /**  06  **/           //|  06  |//
    ,INS(DefWindowProcW    ) /**  07  **/           //|  07  |//
    ,INS(DestroyWindow     ) /**  08  **/           //|  08  |//
    ,INS(PostQuitMessage   ) /**  09  **/           //|  09  |//
    ,INS(GetWindowDC       ) /**  10  **/           //|  10  |//
    ,INS(ChoosePixelFormat ) /**  11  **/           //|  11  |//
    ,INS(SetPixelFormat    ) /**  12  **/           //|  12  |//
    ,INS(ShowWindow        ) /**  13  **/           //|  13  |//
    ,INS(UpdateWindow      ) /**  14  **/           //|  14  |//
    ,INS(SetFocus          ) /**  15  **/           //|  15  |//
    ,INS(PeekMessageW      ) /**  16  **/           //|  16  |//
    ,INS(TranslateMessage  ) /**  17  **/           //|  17  |//
    ,INS(DispatchMessageW  ) /**  18  **/           //|  18  |//
    #define  L_E_N_DOUBLECHECK   (18+1) //:///////////:  --  ://
//: ,INS(function_pointer_name_here)                //|  19  |//
//: ,INS(function_pointer_name_here)                //|  20  |//
//: ,INS(function_pointer_name_here)                //|  31  |//
//: ,INS(function_pointer_name_here)                //|  32  |//
//: ,INS(function_pointer_name_here)                //|  33  |//
//: ,INS(function_pointer_name_here)                //|  34  |//
//: ,INS(function_pointer_name_here)                //|  35  |//
//: ,INS(function_pointer_name_here)                //|  36  |//
//: ,INS(function_pointer_name_here)                //|  37  |//
//: ,INS(function_pointer_name_here)                //|  38  |//
//: ,INS(function_pointer_name_here)                //|  39  |//
//: ,INS(function_pointer_name_here)                //|  40  |//
//: ,INS(function_pointer_name_here)                //|  41  |//
//: ,INS(function_pointer_name_here)                //|  42  |//
//: ,INS(function_pointer_name_here)                //|  43  |//
//: ,INS(function_pointer_name_here)                //|  44  |//
//: ,INS(function_pointer_name_here)                //|  45  |//
//: ,INS(function_pointer_name_here)                //|  46  |//
//: ,INS(function_pointer_name_here)                //|  47  |//
//: ,INS(function_pointer_name_here)                //|  48  |//
//: ,INS(function_pointer_name_here)                //|  49  |//
//: ,INS(function_pointer_name_here)                //|  50  |//
    };;//:////////////////////////////////////////////:  --  ://
    if( L_E_N != L_E_N_DOUBLECHECK ){
        H("[FAIL:MACRO_SETUP_FAIL:L_E_N_DOUBLECHECK]");
    };;
    for( int a = 0; a < L_E_N; a++ ){  //:- - - - - - - - - -://
    for( int b = 0; b < L_E_N; b++ ){  //:- - - - - - - - - -://
        if( a==b ){ continue; };
        if( arr[a]==arr[b] ){ H("[FAIL:NOTASET:2020_04_25]");};
    };;};;                    D("[PASS:YESASET:2020_04_25]");
    #undef  L_E_N //:////////////////////////////////////////://
    //[SC[MSA_FPU_CXX](ABOVE)////////////////////////////////]//
    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://

    INS(han_exe)=((TYP(F_01))INS(GetModuleHandleW))( NIL );
    INS(dek_win)=((TYP(F_00))INS(GetDesktopWindow))(     );

    if( NIL== INS(han_exe) ){ H("[NIL:han_exe]"); };
    if( NIL== INS(dek_win) ){ H("[NIL:dek_win]"); };
    
    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://

    //: LATER_IN_FUNCTION: 
    //: INS(fod_pix)==temp_pixel_format_descriptor_for_easy_init
    struct TYP(PIXELFORMATDESCRIPTOR)               
    temp_pixel_format_descriptor_for_easy_init={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct TYP(PIXELFORMATDESCRIPTOR) ),       //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;    
    //:eieieieieieieieieieieieieieieieieieieieieieieieieieiei://
    #define PIX INS(fod_pix) ///////////////////////////////////
    //: COPY_OVER + SMOKE_TEST : BELOW --------------------- ://

        //:Copy over temp to file scope variable:
        //:fod_pix==temp_pixel_format_descriptor_for_easy_init
                PIX=temp_pixel_format_descriptor_for_easy_init;

        //:Smoke_Test:
        ////////////////////////////////////////////////////////
        if(      32!=PIX.cColorBits   ){
            H( "[32!=PIX.cColorBits]" );
        };;
        if( 24 != PIX.cDepthBits  ){
            printf( 
                  "[PIX.cDepthBits]:%d\n"
            ,       PIX.cDepthBits  
            );;
            H("[24!=PIX.cDepthBits]");
        };;
        if(      8!=PIX.cStencilBits ){
           H( "[08!=PIX.cStencilBits]");
        };;     
    
        #define COLT_40 40 /////////////////////////////////////
 
        if( COLT_40 != 
            sizeof( struct TYP(PIXELFORMATDESCRIPTOR) )
        ){
            H("[COLT_40:1]");
        }else
        if( 
            COLT_40 != 
            sizeof( temp_pixel_format_descriptor_for_easy_init)
        ){
            H("[COLT_40:2]");
        }else
        if( COLT_40 != sizeof( PIX ) ){
            H("[COLT_40:3]");
        }else
        if( COLT_40 != sizeof( INS( fod_pix ) ) ){
            H("[COLT_40:4]");
        }else
        if( COLT_40 != INS( fod_pix ).nSize ){
            H("[COLT_40:5]");
        }else{
            D("[PIXELFORMATDESCRIPTOR:It_Checks_Out]");
        };;

        #undef  COLT_40  ///////////////////////////////////////

        ////////////////////////////////////////////////////////
             
    //: COPY_OVER + SMOKE_TEST : ABOVE --------------------- ://
    #undef  PIX ////////////////////////////////////////////////
    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://
    //:EII:Existance_Is_Initialization:(ABOVE):______________://


    //:R:Register:(BELOW):-----------------------------------://
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    //:Before creating window, must register window class:
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    
    
    //:SmokeTest:
    size_t struct_size =( sizeof( struct TYP(WNDCLASSEXW) ) );
    if( struct_size != 80 ){ H("[BadStructSize]"); };
    
    
    ////////////////////////////////////////////////////////////
    
    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////
    
    INS(WNDCLASSEXW).cbSize=sizeof( struct TYP(WNDCLASSEXW) );
    INS(WNDCLASSEXW).style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                    //| ...ClassWin32         |//
    0);;
    INS(WNDCLASSEXW).lpfnWndProc=fun(WinMsgHanWndPoc);
    INS(WNDCLASSEXW).cbClsExtra=0;
    INS(WNDCLASSEXW).cbWndExtra=0;
    INS(WNDCLASSEXW).hInstance =( INS( han_exe ) );
    
    char* idi_application = fun(MakeIntResourceA)( 32512 );
    char* idc_arrow       = fun(MakeIntResourceA)( 32512 );
    
    #define F2 TYP(F_02) ///////////////////////////////////////
    
        INS(WNDCLASSEXW).hIcon  =((F2)INS(LoadIconA))(  
            NULL
        ,   idi_application
        );;
        INS(WNDCLASSEXW).hCursor=((F2)INS(LoadCursorA))(  
            NULL
        ,   idc_arrow
        );;
    
    #undef  F2 /////////////////////////////////////////////////
    #define XX /////////////////////////////////////////////////
    
    //:SEE[ HBR_BACKGROUND_CAN_BE_NULL_FOR_VULKAN_WINDOW ]
    //:AKA[ HBC_BNF_VW ]
    INS(WNDCLASSEXW).hbrBackground=NULL;
    INS(WNDCLASSEXW).lpszMenuName=NULL;
    INS(WNDCLASSEXW).lpszClassName=INS(win_nam);
    
    #undef  XX /////////////////////////////////////////////////
    #define F2 TYP(F_02) ///////////////////////////////////////
    
    INS(WNDCLASSEXW).hIconSm=(
        ((F2)INS(LoadIconA))(
            NULL
        ,   idi_application
        )
    );;
    
    #undef  F2 /////////////////////////////////////////////////
    #define F3 TYP(F_03) ///////////////////////////////////////
    
    //:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
    //|If you forget to register your window class,the       |//
    //|observable effect is the window never opening,and the |//
    //|wait loop exiting immediately.                        |//
    //|
    //|RegisterClassExW:(MSDN_DOCS):
    //|Registers a window class for subsequent use in calls  |//
    //|to the CreateWindow or CreateWindowEx function.       |//
    //:______________________________________________________://
    int VAR( bool )=(
        (int)(unsigned long long)
        (  (TYP(F_01))  INS(RegisterClassExW)  )(  
            &( INS(WNDCLASSEXW) )
        )
    );;
    if( VAR( bool ) <= 0 ){
        H("[REGWINCLASS:FAIL]");
    }else{
        D("[REGWINCLASS:PASS]");
    };;
    
    #undef  F3 /////////////////////////////////////////////////
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    //:R:Register:(ABOVE):-----------------------------------://
    //:CREATE_WINDOW:::CWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCW://
    #define NIHILISM NIL //://///////////|///////////////////://
    #define V void       //://///////////|///////////////////://
    #define U64 unsigned long long int //:///////////////////://
    ins(han_win)=
    ((TYP(F_12))INS(CreateWindowExW))//:---------------------://
    (
    ////
        /**/(V*)0x00000008L  /** ws_ex_topmost **/
        ,   (V*)INS(win_nam) /** Window___Name **/
        ,   (V*)INS(tib_tex) /** Titlebar_Text **/
    ////
        , 
        (V*)(U64)
        (0
        |  0x00CF0000 /** ws_overlappedwindow **/ 
        |      0x0020 /** CS_OWNDC (2B/32b)  **/
        |
        0)
    ////    X_Y_WID_HIG
        ,   (V*)(U64) 22    //: _X_  -----------://
        ,   (V*)(U64) 22    //: _Y_  -----------://
        ,   (V*)(U64) 1024  //: WID  -----------://
        ,   (V*)(U64) 512   //: HIG  -----------://
    ////
        ,   INS(dek_win)    //:-- hWndParent ---://
        ,   ( NIHILISM )    //:-- hMenu      ---://
        ,   INS(han_exe)    //:-- hInstance  ---://        
        ,   ( NIHILISM )    //:-- lpParam    ---://  
    ////
    ); //:---------------------------------------------------://
    
    if(NIL==ins(han_win)){
        H("[FAIL:VKG04_WindowCreateFail]");
        return 0;
    }else{
        D("[PASS:VKG04_CreatedWindow:TODO:SetupWindowLoop]");
    };;
    #undef  U64      //://///////////////////////////////////://
    #undef  V        //://///////////////////////////////////://
    #undef  NIHILISM //://///////////////////////////////////://
    //:CWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCW:::CREATE_WINDOW://
    //:DEVICE_CONTEXT: DCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC://

    ins(con_win)=((TYP(F_01))INS(GetWindowDC))( ins(han_win) );
    if( NIL==ins(con_win) ){
        H("[FailedToGet:window_device_context/con_win]");
    }else{
        D("[PASS:con_win(window_device_context)]");
    };;

    //:DCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC :DEVICE_CONTEXT://

    //:PFN:Pixel_Format_Number: GET: ins(fmt_num):
    //::PFN:PFN:PFN:PFN:PFN:PFN::::::PFN:PFN:PFN:PFN:PFN:PFN:://
    ins(fmt_num)=( //:pixel_format_number
        //:CAST_RESULTS:
        (int)(unsigned long long)

        //:FUNCTION_CALL:
        (  (TYP(F_02))INS(ChoosePixelFormat /**GDI32.DLL**/ ))

        //:FUNCTION_PARAMETERS:
        (  
             ins(con_win)    /**window_device_context**/
        , &( INS(fod_pix) )  /**PIXELFORMATDESCRIPTOR**/
        )
    );;

    if( 0 == ins(fmt_num) ){
        H("[FAIL:DEFINITELY_FAILED:ChoosePixelFormat]");
    }else
    if( 0  > ins(fmt_num) ){ //:NEGATIVE
        //:Look more into documentation if this happens.
        //:but pretty sure it should be a positive number.
        //:Also watch out for errors due to sign extension.
        H("[fail?PROBABLY_FAILED:::ChoosePixelFormat]");
    }else
    if( 0  < ins(fmt_num) ){ //:POSITIVE
        D("[PASS:ALL_IS_GOOD_IN_THE_PIXELFORMAT_NEIGHBORHOOD]");
    }else{ //:WHAT_THE_FUCK
        H("[FAIL:WHAT_THE_FUCK:2020_04_25:0148PM]");
    };;
    //::PFN:PFN:PFN:PFN:PFN:PFN::::::PFN:PFN:PFN:PFN:PFN:PFN:://

    //:VC:Vulkan_Compatible:
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://
    //:VKG03.ALL:f09_MakeWindowCompatibleWith_GL
    //:Make the window compatible with openGL & Vulkan:
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((TYP(F_03))INS(SetPixelFormat))(
        /**/
        /**/        ins(con_win)  /** window_device_context **/
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        ins(fmt_num)  /** pixel_format_number   **/
        /**/    ,
        /**/     &( INS(fod_pix) )/** PIXELFORMATDESCRIPTOR **/
        )
    );;
    if( setting_pixel_format_worked ){
        D("[PASS:SET_PIXEL_FORMAT]");
    }else{
        H("[FAIL:SET_PIXEL_FORMAT]");
    };;
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://

    //:SEE:VG03.ALL:f09_WindowLoop

    //:LG:Loosey_Goosey:
    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    //: Because we are playing loosy-goosy without including
    //: any header files, we better check runtime size of
    //: the structs we re-created against observed sizes
    //: when compiling small project using <windows.h> header.
    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    if( 8 == sizeof( ins(win32point) ) ){
        D("[PASS:SIZECHECK:win32point]");
    }else{
        H("[FAIL:SIZECHECK:win32point]");
    };;
    if(48 == sizeof( ins(winmsg)     ) ){
        D("[PASS:SIZECHECK:winmsg]");
    }else{
        H("[FAIL:SIZECHECK:winmsg]");
    };;

    if( 8 == sizeof( struct TYP(WIN32POINT) ) ){
        D("[PASS:SIZECHECK:WIN32POINT]");
    }else{
        H("[FAIL:SIZECHECK:WIN32POINT]");
    };;
    if(48 == sizeof( struct TYP(WINMSG)     ) ){
        D("[PASS:SIZECHECK:WINMSG]");
    }else{
        H("[FAIL:SIZECHECK:WINMSG]");
    };;


    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    //:TP:TickPrep: Prepwork before doing a WindowTick(...):
    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://
    //:                                                      ://
    //:ALL_FUNCTIONS_FROM: "User32.dll"                      ://
    //:                                                      ://
    //: ShowWindow   :Set Visibility State Of Window:        ://
    //: UpdateWindow :Force WM_PAINT to top of message queue.://
    //: SetFocus     :Set keyboard focus to window:          ://
    //:                                                      ://
    //: han_win:-----: handle_to_a_window_instance           ://
    //:                ( handle_to_window )                  ://
    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://
    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;

    ( (TYP(F_02)) INS(ShowWindow)   )(  ins(han_win), show  );
    ( (TYP(F_01)) INS(UpdateWindow) )(  ins(han_win)        ); 
    ( (TYP(F_01)) INS(SetFocus)     )(  ins(han_win)        );

    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://

    //:We are not going to enter a window loop here.
    //:That would wreck the chain structure of our project
    //:setup. Instead we will register WindowTick function
    //:with the main game loop, and the game loop will 
    //:call it for us.
    INS(looptable).MEM(nat_win)=&( fun(WindowTick) );


    return( 0 );
}


int fun(TakeOrLookMessage)( //://////////////////////////////://

    //:ins(winmsg) / LPMSG
    struct TYP(WINMSG)* dont_prefix_message_with_and_symbol 
    ,
    int                 take_the_message
){ //:///////////////////////////////////////////////////////://

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        H("[FAIL:EXPECTED:Pos|Or|Zero]");
    };;

    int ret =(
        //:CAST_RETURN_DATA:
        (int)(unsigned long long)

        //:FUNCTION_TO_CALL:
        (  (TYP(F_05)) INS(PeekMessageW)  )

        //:ARGUMENTS_TO_FUNCTION:
        (
        /** -- **/    (void*)
        /** 01 **/    dont_prefix_message_with_and_symbol
        /** -- **/    ,
        /** 02 **/    NULL //:hWnd:NullToProcessThreadMessages
        /** -- **/    ,
        /** 03 **/    0    //:wMsgFilterMin
        /** -- **/    ,
        /** 04 **/    0    //:wMsgFilterMax
        /** -- **/    ,
        /** -- **/    (void*)(unsigned long long)
        /** 05 **/    look_or_take  //:wRemoveMsg
        )
    );;
    return( ret );

} //://////////////////////////////////////:TakeOrLookMessage://
int /** BOOL **/ fun(LookMessage)( //:///////////////////////://
    struct TYP(WINMSG)* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=fun(TakeOrLookMessage)(msg,look);
    return( ret );
} //:////////////////////////////////////////////:LookMessage://
int /** BOOL **/ fun(TakeMessage)( //:///////////////////////://
    struct TYP(WINMSG)* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=fun(TakeOrLookMessage)(msg,take);
    return( ret );
} //:////////////////////////////////////////////:TakeMessage://

//:I thought this needed to be public. But then I realized
//:it is this file's responsibility to register itself
//:with the main game loop.
void fun( WindowTick )( void )
{
    //:One tick of our window loop goes here.

    //:######################################################://
    #define M ins(winmsg) //:################################://

    fun(LookMessage)( &M );
    if( /** WHILE_CONVERTED_TO_AN_IF **/ //://///////////////://

        M.message != 0x12 /** UINT:wm_quit **/

    ){  //://////////////////////////////////////////////////://

        if( fun(TakeMessage)(    &M )){

            ( (TYP(F_01))INS(TranslateMessage) )( &M );

            ( (TYP(F_01))INS(DispatchMessageW) )( &M );

        };;

        ins(frames_without_window) = 0;

    }else{ //:///////////////////////////////////////////////://

        //:Notify console if the window is closed and the
        //:program is still executing.
        #define MSG_MAX_INDEX ( 5 ) //://////////////////////://
            ins(frames_without_window)++;
            char* no_more_window_message=(
                "[SRC/NATIVE/WINDOW/creation._:NOMOREWINDOW]\n"
            );;
            if( ins(frames_without_window) < MSG_MAX_INDEX ){
                //:TODO: Variables to let rendering system know
                //:      that the window is closed. For now 
                //:      a simple printf will do.
                printf(no_more_window_message);
                fflush(stdout);
            }else
            if( ins(frames_without_window) == MSG_MAX_INDEX ){
                printf("[StillNoWindowButBeingQuietNow...]\n");
                printf("[USE[CTRL+C]HERE_TO_EXIT_PROGRAM!]\n");
                fflush(stdout);
            };;
        #undef MSG_MAX_INDEX //://///////////////////////////://

    };; //://////////////////////////////////////////////////://

    #undef M //:#############################################://
    //:######################################################://

}
 






//:MakeIntResourceA /////////////////////////////////////////://
char*
fun(MakeIntResourceA)( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
} //:////////////////////////////////////// MakeIntResourceA ://
//:WinMsgHanWndPoc //////////////////////////////////////////://
__stdcall
__int64 //:LRESULT
fun(WinMsgHanWndPoc)(
/**/           void*    han_win   //:HWND
,   unsigned   int      Msg       //:...?...
,   unsigned __int64    wParam    //:WPARAM
,            __int64    lParam    //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[SRC/NATIVE/WINDOW/creation._:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 (( TYP(F_01) )(INS(DestroyWindow)))(han_win);

            if(0==ok){ H("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            (( TYP(F_01) )(INS(DestroyWindow)))(han_win);

        if(0==ok){ H("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((TYP(F_01))INS(PostQuitMessage))(0);

    case 0x000F /**wm_paint**/:
        
        //:SEE[ WM_PAINT_COMMENTS_SECTION ]

    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            (   (TYP(F_04))   (INS(DefWindowProcW))   )(
            /**/(void*)                han_win  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //://////////////////////////////////////// WinMsgHanWndPoc://

    void* //: [ TYP(con_win) == void* ]
    FUN(SRC_NATIVE_WINDOW_CREATION_GetWinDC)( void ){

        if(NIL==ins(con_win)){ H("[GetWinDC:NIL:con_win]"); };
        return( ins(con_win) );
    }

//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//