//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_0714AM_CL , n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_0714AM_CL , n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_0714AM_CL , n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_0714AM_CL , n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_0714AM_CL , n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_0714AM_CL , n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_0714AM_CL , n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_0714AM_CL , n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_0714AM_CL , n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_0714AM_CL , n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_0714AM_CL , n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_0714AM_CL , n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_0714AM_CL , n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_0714AM_CL , n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_0714AM_CL , n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_0714AM_CL , n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_OPENCL_SETUP_MAIN ( 2020+04+27 - 1154 + 'C' )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/OPENCL(COMPUTE_LIB)/SETUP/main._:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/OPENCL(COMPUTE_LIB)/SETUP/main._:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://        
//:TYPEDEFS::TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD://


    //:SetupForPointerToA:GetProcAddress:Function:SC[GPA_FUN]
    //://////////////////////////////////////////////////////://
    //:                                                      ://
    //: Below we are constructing type:                      ://
    //:                         TYP(GPA_FUN) / T(GPA_FUN)    ://
    //:                                                      ://
    //: It is a is like a generic function pointer, EXCEPT   ://
    //: that it returns a function pointer rather than a     ://
    //: void*. We need this specialized generic function     ://
    //: pointer because we cannot mix data pointers and      ://
    //: function pointers when casting.                      ://
    //:                                                      ://
    //: NO!  TYP(FUN) f = (TYP(FUN))INS(gen_fun)("FuncName"); //
    //: OK:  TYP(FUN) f = (TYP(FUN))INS(gpa_fun)("FuncName"); //
    //: OK:  TYP(FUN) f =           INS(gpa_fun)("FuncName"); //
    //:                                                      ://
    //://////////////////////////////////////////////////////://
    #define T( nam ) TYP( nam ) //://////////////////////////://

    typedef void       (* T(GEN_FUN) )(void);  //:Generic:FUNC
    typedef void          T(GEN_DAT)        ;  //:Generic:DATA
    typedef T(GEN_FUN) (* T(GPA_FUN) )(void*); //:GPA_Pointer

    #undef  T //:////////////////////////////////////////////://

//:TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD::TYPEDEFS://
//:FORWARD_DECLARATIONS::FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD://

    TYP(FUN) fun(GetAnyCLFuncAddress)( const char* );

//:FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD::FORWARD_DECLARATIONS://
//:OPENCL_FUNCTION_POINTERS::FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://

    //:T1:Teir_1:Teir_1_OpenCL_Function_Pointers:------------://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
    #define    N  =(NIL);/////////://////////////////////////://  
    #define    G  TYP(GPA_FUN)  //://////////////////////////://
    #define    F  TYP(FUN)      //://////////////////////////://  

    //: //:OpenCL function pointers that can be immediately
    //: //:Fetched without requiring an OpenCL instance.
    //: G            ins(wclGetProcAddress   )                 N
    //: F            ins(wclGetCurrentContext)                 N
    //: TYP(F_01)    ins(wclCreateContext    )                 N
    //: TYP(F_02)    ins(wclMakeCurrent      )                 N

    #undef     N  //:////////////////////////////////////////://
    #undef     G  //:////////////////////////////////////////://
    #undef     F  //:////////////////////////////////////////://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

    //:T2:Teir_2:Teir_1_OpenCL_Function_Pointers:------------://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
    #define  N      =(NIL);   //:////////////////////////////://  
    #define  F    TYP(FUN)    //:////////////////////////////://   
    #define  F_01 TYP(F_01)   //:////////////////////////////://
    #define  F_02 TYP(F_02)   //:////////////////////////////://
    #define  F_03 TYP(F_03)   //:////////////////////////////://
    #define  F_04 TYP(F_04)   //:////////////////////////////://
    #define  F_05 TYP(F_05)   //:////////////////////////////://
    #define  F_06 TYP(F_06)   //:////////////////////////////://
    #define  F_07 TYP(F_07)   //:////////////////////////////://
    #define  F_08 TYP(F_08)   //:////////////////////////////://
    #define  F_09 TYP(F_09)   //:////////////////////////////://

    //:OpenCL: 1.2  
    //:------------------------------------------------------://
    #define MACRO_01 clGetExtensionFunctionAddressForPlatform
    //:------------------------------------------------------://
    F_01  INS( clFinish                   ) N         //| 01 |//
    F_01  INS( clFlush                    ) N         //| 02 |//
    F_01  INS( clReleaseKernel            ) N         //| 03 |//
    F_01  INS( clReleaseProgram           ) N         //| 04 |//
    F_01  INS( clReleaseMemObject         ) N         //| 05 |//
    F_01  INS( clReleaseCommandQueue      ) N         //| 06 |//
    F_01  INS( clReleaseContext           ) N         //| 07 |//
    F_02  INS( clWaitForEvents            ) N         //| 08 |//
    F_02  INS( MACRO_01                   ) N         //| 09 |//
    F_03  INS( clGetPlatformIDs           ) N         //| 10 |//
    F_03  INS( clCreateKernel             ) N         //| 11 |//
    F_04  INS( clCreateCommandQueue       ) N         //| 12 |//
    F_04  INS( clSetKernelArg             ) N         //| 13 |//
    F_05  INS( clCreateBuffer             ) N         //| 14 |//
    F_05  INS( clCreateProgramWithSource  ) N         //| 15 |//
    F_05  INS( clGetDeviceIDs             ) N         //| 16 |//
    F_05  INS( clGetDeviceInfo            ) N         //| 17 |//
    F_05  INS( clGetContextInfo           ) N         //| 18 |//
    F_05  INS( clGetCommandQueueInfo      ) N         //| 19 |//
    F_05  INS( clGetKernelInfo            ) N         //| 20 |//
    F_05  INS( clGetPlatformInfo          ) N         //| 21 |//
    F_06  INS( clGetProgramBuildInfo      ) N         //| 22 |//
    F_06  INS( clBuildProgram             ) N         //| 23 |//
    F_06  INS( clCreateContext            ) N         //| 24 |//
    F_09  INS( clEnqueueReadBuffer        ) N         //| 25 |//
    F_09  INS( clEnqueueNDRangeKernel     ) N         //| 26 |//
    F_09  INS( clEnqueueWriteBuffer       ) N         //| 27 |//
    //:------------------------------------------------------://
    #undef MACRO_01 //://////////////////////////////////////://
    //:------------------------------------------------------://

    //:CL 2.0 only.
    //:F_04  INS( clCreateCommandQueueWithProperties       ) N 
          
    #undef  N     //:////////////////////////////////////////://
    #undef  F     //:////////////////////////////////////////://
    #undef  F_01  //:////////////////////////////////////////://
    #undef  F_02  //:////////////////////////////////////////://
    #undef  F_03  //:////////////////////////////////////////://
    #undef  F_04  //:////////////////////////////////////////://
    #undef  F_05  //:////////////////////////////////////////://
    #undef  F_06  //:////////////////////////////////////////://
    #undef  F_07  //:////////////////////////////////////////://
    #undef  F_08  //:////////////////////////////////////////://
    #undef  F_09  //:////////////////////////////////////////://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
//:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP::OPENCL_FUNCTION_POINTERS://
//:OPEN_CL_ENUMERATIONS:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE://

    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)
    //://////////////////////////////////////////////////////://
    #define  E_M CLEAR_CRYSTAL_BALL_WITCH_PARTY //:ERROR_MESSAGE
    #define  D_T U32                     //:DECLARE_TYPE(ALL)
    #define  E_0(con,msg) _Static_assert( con, msg )
    #define  E_1(t_t,msg) E_0(sizeof(t_t) > 0, msg )
    #define  A_1 _Static_assert
    #define  A_2(h_d,msg_nam) A_1(               h_d,#msg_nam )
    #define  A_3(h_d,nam,msg) A_2(               h_d, msg:nam )
    #define  A_4(h_d,nam,msg) A_3(               h_d, nam,msg )
    #define  A_5(nam,hex,dec) A_4(          hex==dec, nam,E_M )
    #define  A_6(nam,hex,dec) A_5(   nam  , hex ,dec          )
    #define  D_1(nam,hex    ) D_T INS(nam) = hex
    #define  D_2(nam,hex    ) D_1(    nam  , hex       )
    #define  DA1(nam,hex,dec) D_2(nam,hex) ; A_6(nam,hex,dec)
    #define  DA2(nam,hex,dec,eye_tot) DA1(nam,hex,dec)
        
        //:DA: Declare & Assert
        //:HackishChecksum:Check hex against decimal for match.
        DA2( cl_mem_read_write      ,   0x1 , (1<<0) , A_01 ) ;
        DA2( cl_mem_write_only      ,   0x2 , (1<<1) , A_02 ) ;
        DA2( cl_mem_read_only       ,   0x4 , (1<<2) , A_03 ) ;
        DA2( cl_mem_use_host_ptr    ,   0x8 , (1<<3) , A_04 ) ;       
        DA2( cl_mem_alloc_host_ptr  ,  0x10 , (1<<4) , A_05 ) ;
        DA2( cl_mem_copy_host_ptr   ,  0x20 , (1<<5) , A_06 ) ;
        ///( RESERVED               ,  0x40 , (1<<6) , A_07 ) ;
        DA2( cl_mem_host_write_only ,  0x80 , (1<<7) , A_08 ) ;
        DA2( cl_mem_host_read_only  , 0x100 , (1<<8) , A_09 ) ;
        DA2( cl_mem_host_no_access  , 0x200 , (1<<9) , A_10 ) ;

        DA2( cl_device_type_default     ,0x1, (1<<0) , B_01 ) ;
        DA2( cl_device_type_cpu         ,0x2, (1<<1) , B_02 ) ;
        DA2( cl_device_type_gpu         ,0x4, (1<<2) , B_03 ) ;
        DA2( cl_device_type_accelerator ,0x8, (1<<3) , B_04 ) ;

        //:cl_platform_info:
        DA2( cl_platform_profile    ,
                               0x0900, (0x900 + 0) , C_01 ) ;
        DA2( cl_platform_version    ,
                               0x0901, (0x900 + 1) , C_02 ) ;
        DA2( cl_platform_name       ,
                               0x0902, (0x900 + 2) , C_03 ) ;
        DA2( cl_platform_vendor     ,
                               0x0903, (0x900 + 3) , C_04 ) ;
        DA2( cl_platform_extensions ,
                               0x0904, (0x900 + 4) , C_05 ) ;

        //:E_#:Exists: Assert these INS(___) types exist
        //:SEE[ STATIC_ASSERT_EXIST_HACK ]
        E_1( INS(cl_mem_read_write         ) , "eye_tot:A_01" );
        E_1( INS(cl_mem_write_only         ) , "eye_tot:A_02" );
        E_1( INS(cl_mem_read_only          ) , "eye_tot:A_03" );
        E_1( INS(cl_mem_use_host_ptr       ) , "eye_tot:A_04" );
        E_1( INS(cl_mem_alloc_host_ptr     ) , "eye_tot:A_05" );
        E_1( INS(cl_mem_copy_host_ptr      ) , "eye_tot:A_06" );
        ///( INS(RESERVED                  ) , "eye_tot:A_07" );
        E_1( INS(cl_mem_host_write_only    ) , "eye_tot:A_08" );
        E_1( INS(cl_mem_host_read_only     ) , "eye_tot:A_09" );
        E_1( INS(cl_mem_host_no_access     ) , "eye_tot:A_10" );

        E_1( INS(cl_device_type_default    ) , "eye_tot:B_01" );
        E_1( INS(cl_device_type_cpu        ) , "eye_tot:B_02" );
        E_1( INS(cl_device_type_gpu        ) , "eye_tot:B_03" );
        E_1( INS(cl_device_type_accelerator) , "eye_tot:B_04" );

        E_1( INS(cl_platform_profile       ) , "eye_tot:C_01" );
        E_1( INS(cl_platform_version       ) , "eye_tot:C_02" );
        E_1( INS(cl_platform_name          ) , "eye_tot:C_03" );
        E_1( INS(cl_platform_vendor        ) , "eye_tot:C_04" );
        E_1( INS(cl_platform_extensions    ) , "eye_tot:C_05" );

    #undef   E_M    //://////////////////////////////////////://
    #undef   D_T    //://////////////////////////////////////://
    #undef   E_0    //://////////////////////////////////////://
    #undef   E_1    //://////////////////////////////////////://
    #undef   A_1    //://////////////////////////////////////://
    #undef   A_2    //://////////////////////////////////////://
    #undef   A_3    //://////////////////////////////////////://
    #undef   A_4    //://////////////////////////////////////://
    #undef   A_5    //://////////////////////////////////////://
    #undef   A_6    //://////////////////////////////////////://
    #undef   D_1    //://////////////////////////////////////://
    #undef   D_2    //://////////////////////////////////////://
    #undef   DA1    //://////////////////////////////////////://
    #undef   DA2    //://////////////////////////////////////://
    //://////////////////////////////////////////////////////://
    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)

//:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:OPEN_CL_ENUMERATIONS://
//:FILESCOPE_WHATEVERS:FWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFW://

    //://////////////0xAARRGGBB
    #define ALT_555 (0x55555555)

    U64 ins(gar_byt_01) = ALT_555;
    char file_scope_arr[256]={0};
    U64 ins(gar_byt_02) = ALT_555;
    
    //|RISK: The host side type ‘cl_uint’ is guaranteed to be|//
    //|the same format as the device side type ‘uint’.       |//
    //|Depending of the platform,‘unsigned int’ may be       |//
    //|something different.                                  |//
    //|community.khronos.org/t/unsigned-int-or-cl-uint/2200  |//

    #define VOD void //://///////////////////////////////////://
  
    //:PLATFORM_ID: cl_platform_id[ ] :::::::::::::::::::::::://
    #define PID_CAP ( 10 ) //:///////////////////////////////://
    VOD* g_2(plat_id, pid_arr)  [ PID_CAP ]={0}; //:arr_dat
    U32  g_2(plat_id, pid_num) =(    0    );     //:arr_num
    int  g_2(plat_id, pid_cap) =( PID_CAP );     //:arr_cap
    int  g_2(plat_id, pid_dex) =( 0  -  1 );     //:sel_dex
    #undef PID_CAP //:///////////////////////////////////////://

    //:DEVICE_ID:     cl_device_id[ ] :::::::::::::::::::::::://
    #define DEV_CAP ( 10 ) //:///////////////////////////////://
    VOD* g_2(devi_id,dev_arr) [ DEV_CAP ]={0}; //:arr_dat
    U32  g_2(devi_id,dev_num)=(    0    );     //:arr_num
    int  g_2(devi_id,dev_cap)=( DEV_CAP );     //:arr_cap
    int  g_2(devi_id,dev_dex)=( 0  -  1 );     //:sel_dex
    #undef DEV_CAP //:///////////////////////////////////////://
    
    //:CONTEXT:cl_context+cl_context_properties :::::::::::::://
    VOD* g_2(con_com,context)=( NIL ); //:cl_context
    VOD* g_2(con_com,con_pro)=( NIL ); //:cl_context_properties
   
    #undef  VOD //://////////////////////////////////////////://
           

//:FWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFW:FILESCOPE_WHATEVERS://
//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
    void EII(SRC_OPENCL_SETUP_main)(void){ //:///////////////://

        //:T1:Teir_1:Grab Teir 1 OpenCL Functions:
        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

        #define g_p_a FUN(SRC_NATIVE_CALLWRAP_GetProcAddress) //
        #define G_P_A( a ) g_p_a( "dll_gra",  a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!ins( a )){ H( #a"[IS_NULL]" ); };
        #define     N( a ) n( a ) //:////////////////////////://

            #define G0( a ) G( a )
            #define G1( a ) (TYP(F_01))G( a )
            #define G2( a ) (TYP(F_02))G( a )

            //:Unlike openGL code, I don't think we need
            //:to separate into teir1 and teir2 functions,
            //:but just in case, leave this code here for
            //:now.

            //////  //:MACROS:
            //////  //:     G: Calls GetProcAddress
            //////  //:     N: Null  Checks Function Pointer
            //////  
            //////  //:SEE[ GPA_POINTERS_ARE_SPECIAL ]
            //////  ins(wclGetProcAddress   )=(
            //////      (TYP(GPA_FUN))G( wclGetProcAddress    ));;
            //////  
            //////  ins(wclGetCurrentContext)=G0( wclGetCurrentContext);
            //////  ins(wclCreateContext    )=G1( wclCreateContext    );
            //////  ins(wclMakeCurrent      )=G2( wclMakeCurrent      );
            //////  
            //////  N(wclGetProcAddress   ); //:NULL_CHECKS
            //////  N(wclGetCurrentContext); //:NULL_CHECKS
            //////  N(wclCreateContext    ); //:NULL_CHECKS
            //////  N(wclMakeCurrent      ); //:NULL_CHECKS

            #undef G0
            #undef G1
            #undef G2

        #undef  g_p_a  //:///////////////////////////////////://
        #undef  G_P_A  //:///////////////////////////////////://
        #undef      G  //:///////////////////////////////////://
        #undef      n  //:///////////////////////////////////://
        #undef      N  //:///////////////////////////////////://

        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
        
        //[ TODO: Any setup code that might be needed between]//
        //[       Teir_1 and Teir_2 function pointer fetch.  ]//

        //:T2:Teir_2:( 2nd_tier_opencl_function_pointers )
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
        //://////////////////////////////////////////////////://
        #define g_p_a fun(GetAnyCLFuncAddress)       //://///://
        #define G_P_A( a ) g_p_a(             a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!INS( a )){ H( #a"[IS_NULL]" ); };
        #define     o( a ) if( INS( a )){ D( "[OK_YEAH]"#a ); };
        #define     N( a ) n( a ) //:////////////////////////://

            //:G_N:Get_function_pointer_AND_check_for_null.
            //://////////////////////////////////////////////://
            #define G_N( a ) INS( a )=G( a );N( a ); o( a );

            #define G0( a ) INS( a )=(TYP(F_00))G( a ) _ _ _ _ _
            #define G1( a ) INS( a )=(TYP(F_01))G( a ) _ _ _ _ _
            #define G2( a ) INS( a )=(TYP(F_02))G( a ) _ _ _ _ _
            #define G3( a ) INS( a )=(TYP(F_03))G( a ) _ _ _ _ _
            #define G4( a ) INS( a )=(TYP(F_04))G( a ) _ _ _ _ _
            #define G5( a ) INS( a )=(TYP(F_05))G( a ) _ _ _ _ _
            #define G6( a ) INS( a )=(TYP(F_06))G( a ) _ _ _ _ _
            #define G7( a ) INS( a )=(TYP(F_07))G( a ) _ _ _ _ _
            #define G8( a ) INS( a )=(TYP(F_08))G( a ) _ _ _ _ _
            #define G9( a ) INS( a )=(TYP(F_09))G( a ) _ _ _ _ _

            #define G_0( a ) G0( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_1( a ) G1( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_2( a ) G2( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_3( a ) G3( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_4( a ) G4( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_5( a ) G5( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_6( a ) G6( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_7( a ) G7( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_8( a ) G8( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_9( a ) G9( a );N( a ); o( a ); _ _ _ _ _ _

//:----------------------------------------------------------://
#define MACRO_01 clGetExtensionFunctionAddressForPlatform //:://
//:----------------------------------------------------------://

                    G_1( clFinish                  ); //| 01 |//
                    G_1( clFlush                   ); //| 02 |//
                    G_1( clReleaseKernel           ); //| 03 |//
                    G_1( clReleaseProgram          ); //| 04 |//
                    G_1( clReleaseMemObject        ); //| 05 |//
                    G_1( clReleaseCommandQueue     ); //| 06 |//
                    G_1( clReleaseContext          ); //| 07 |//
                    G_2( clWaitForEvents           ); //| 08 |//
                    G_2( MACRO_01                  ); //| 09 |//
                    G_3( clGetPlatformIDs          ); //| 10 |//
                    G_3( clCreateKernel            ); //| 11 |//
                    G_4( clCreateCommandQueue      ); //| 12 |//
                    G_4( clSetKernelArg            ); //| 13 |//
                    G_5( clCreateBuffer            ); //| 14 |//
                    G_5( clCreateProgramWithSource ); //| 15 |//
                    G_5( clGetDeviceIDs            ); //| 16 |//
                    G_5( clGetDeviceInfo           ); //| 17 |//
                    G_5( clGetContextInfo          ); //| 18 |//
                    G_5( clGetCommandQueueInfo     ); //| 19 |//
                    G_5( clGetKernelInfo           ); //| 20 |//
                    G_5( clGetPlatformInfo         ); //| 21 |//
                    G_6( clGetProgramBuildInfo     ); //| 22 |//
                    G_6( clBuildProgram            ); //| 23 |//
                    G_6( clCreateContext           ); //| 24 |//
                    G_9( clEnqueueReadBuffer       ); //| 25 |//
                    G_9( clEnqueueNDRangeKernel    ); //| 26 |//
                    G_9( clEnqueueWriteBuffer      ); //| 27 |//

//:----------------------------------------------------------://
#undef MACRO_01 //://////////////////////////////////////////://
//:----------------------------------------------------------://

            #undef   G0 //://////////////////////////////////://
            #undef   G1 //://////////////////////////////////://
            #undef   G2 //://////////////////////////////////://
            #undef   G3 //://////////////////////////////////://
            #undef   G4 //://////////////////////////////////://
            #undef   G5 //://////////////////////////////////://
            #undef   G6 //://////////////////////////////////://
            #undef   G7 //://////////////////////////////////://
            #undef   G8 //://////////////////////////////////://
            #undef   G9 //://////////////////////////////////://
                        //://////////////////////////////////://
            #undef  G_0 //://////////////////////////////////://
            #undef  G_1 //://////////////////////////////////://
            #undef  G_2 //://////////////////////////////////://
            #undef  G_3 //://////////////////////////////////://
            #undef  G_4 //://////////////////////////////////://
            #undef  G_5 //://////////////////////////////////://
            #undef  G_6 //://////////////////////////////////://
            #undef  G_7 //://////////////////////////////////://
            #undef  G_8 //://////////////////////////////////://
            #undef  G_9 //://////////////////////////////////://

            #undef  G_N //://////////////////////////////////://
            //://////////////////////////////////////////////://

        #undef  g_p_a   //://////////////////////////////////://
        #undef  G_P_A   //://////////////////////////////////://
        #undef      G   //://////////////////////////////////://
        #undef      n   //://////////////////////////////////://
        #undef      o   //://////////////////////////////////://
        #undef      N   //://////////////////////////////////://
        //://////////////////////////////////////////////////://
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://

    //:======================================================://
    //:ABOVE:GrabbinThemFunctionPointers:
    //:BELOW:COG_CreateContext_OpenComputeLanguage:
    //:======================================================://



        { //:SCOPE: GET_PLATFORM_IDS:
        #define VOD void //://///////////////////////////////://
        extern VOD* g_2(plat_id, pid_arr)[10]; //:arr_dat
        extern U32  g_2(plat_id, pid_num); //:arr_num
        extern int  g_2(plat_id, pid_cap); //:arr_cap
        extern int  g_2(plat_id, pid_dex); //:sel_dex
        #undef  VOD //://////////////////////////////////////://

            #define ARR  g_2(plat_id, pid_arr) //:///////////://
            #define NUM  g_2(plat_id, pid_num) //:///////////://
            #define CAP  g_2(plat_id, pid_cap) //:///////////://
            #define DEX  g_2(plat_id, pid_dex) //:///////////://

            int RET(clGetPlatformIDs) = (0-333);

            //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
            //://////////////////////////////////////////////://
            //:Before We call clGetPlatformIDs, make sure it is
            //:not null. Let's not do this on all calls. Just
            //:the first one as a sanity check on our function
            //:pointer fetching macros:
            //://////////////////////////////////////////////://
            if(NIL==INS(clGetPlatformIDs)){ H("[NIL:CGPID]");};
            TYP(F_03) var(fun)=(
                (TYP(F_03))
                FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
                    "dll_com"
                ,   "clGetPlatformIDs"
                )
            );;
            if( var(fun) != INS(clGetPlatformIDs)){
                H("[FAIL:DIFF:FUNCTION_POINTER]");
            }else{
                D("[PASS:SAME:FUNCTION_POINTER]");
            };;
            //://////////////////////////////////////////////://

            RET(clGetPlatformIDs)=(U32)(U64)
            INS(clGetPlatformIDs)(	
                (void*)(U32)0//: num_entries   01 ://
            ,         NIL         //: platforms     02 ://
            ,      &( NUM )       //: num_platforms 03 ://
            );;       
                
            //:CR:Check_Return:CheckReturnCode:
            //:CRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCR://
            if( RET(clGetPlatformIDs) != 0 /**CL_SUCCESS**/ ){
                D("[WHAT_THE_FUCKING_HELL]");
                printf("[RET(clGetPlatformIDs):%u\n",
                         RET(clGetPlatformIDs) );;

                if( 0xFFFFFC17 == (U32)RET(clGetPlatformIDs) ){
                    D("[0xFFFFFC17:CL_PLATFORM_NOT_FOUND_KHR]");
                    D("[FIX:Load_A_Different:OpenCL*.dll]");
                };;

                H("[WHAT_THE_FUCKING_HELL]");
            }else{
                D("[CL_SUCCES]");
            };;
            //:CRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCR://
            
            //:Truncate capacity if needed:
            printf( "#1:g_2(plat_id, pid_num)::%d\n",
                        g_2(plat_id, pid_num) );; 
            if((int)NUM >      CAP ){
                    NUM = (U32)CAP ;   
                D("[WARN:RoomForPlatformsIs:NOT_ENOUGH]");
            }else{
                D("[PASS:RoomForPlatformsIs:ENOUGHROOM]");
            };;

            //:Actually get platforms:
            INS(clGetPlatformIDs)(
            /**/ (void*)(U64) NUM       //: num_entries   01 ://
            ,    (void*)(U64) ARR       //: platforms     02 ://
            ,    (void*)(U64) NIL       //: num_platforms 03 ://
            );;
            printf( "#2:g_2(plat_id, pid_num)::%d\n",
                        g_2(plat_id, pid_num) );; 
            //|______________________________________________|//

            //:TODO: More detailed logic on platform
            //:      selection than simply using the
            //:      first (zeroth) one.
            DEX=( 0 ); 

            #undef  ARR  //:////  g_2(plat_id, pid_arr)  ////://
            #undef  NUM  //:////  g_2(plat_id, pid_num)  ////://
            #undef  CAP  //:////  g_2(plat_id, pid_cap)  ////://
            #undef  DEX  //:////  g_2(plat_id, pid_dex)  ////://
        } //:SCOPE: GET_PLATFORM_IDS:
        { //:SCOPE: GET_PLATFORM_VERSION:

            D("[LetsGetPlatformInfo...]");
    

            #define WILD_WEST_CAST (void*)(U64) //://////////://

            int siz=( 0 );

            //:Selected platform handle:
            void* han_pla=(
                g_2(plat_id, pid_arr)[
                g_2(plat_id, pid_dex)]
            );;

            INS(clGetPlatformInfo)(
                WILD_WEST_CAST  han_pla
            ,   WILD_WEST_CAST  INS(cl_platform_version)
            ,   WILD_WEST_CAST  0
            ,   WILD_WEST_CAST  NIL
            ,   WILD_WEST_CAST  &siz
            );;

            //:platform_version
           //:  char pid_ver[256]={0}; 
           //:  if( siz <= 0 ){ H("[WTF_SIZE]"); };
            if( siz > (256-1) ){
                D("[NOT_ENOUGH_ROOM_TO_GET_STRING]");
            }else{
                D("[ENOUGH_ROOM_TO_GET_STRING]");

               printf( "siz:%d\n", siz );

              // char* platform_version =( 
              //     malloc(256) 
              // );

              //  char* platform_version=(
              //      calloc(1,256)
              //  );;
                
                #error TODO: Fix this mess.
                #error figure out why declaring random variable
                #error before calling this function makes the
                #error string get populated.
                #error Add the actual function prototype to
                #error this file to make sure you are calling
                #error function correctly and read up on valgrind.

              // char str[25];
              // str[0]='x';
                //U32 guard_byte = ALT_555;
               // if( whatever ){ /**NOOP**/ };

               // char* platform_version=NIL; //: ( str );

                //char platform_version[256]={0};

                ///char platform_version[256]="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
            
                INS(clGetPlatformInfo)(
                    WILD_WEST_CAST  han_pla
                ,   WILD_WEST_CAST  INS(cl_platform_version)
                ,   WILD_WEST_CAST  siz  

              //  ,   WILD_WEST_CAST  &(platform_version[0])

                ,   WILD_WEST_CAST  file_scope_arr
               // ,   WILD_WEST_CAST  &(str[0])


                ,   WILD_WEST_CAST  NIL
                );; 
            
                
                printf("[pid_ver/platform_version]:%s\n"
                        ,file_scope_arr
                );;
             //  printf("[pid_ver/platform_version]:%s\n"
             //          ,&(platform_version[0])
             //  );;

                fflush(stdout);

               // if( guard_byte != ALT_555 ){
               //     H("gottouched]");
               // };; 
                if( ins(gar_byt_01) != ALT_555 ){
                    H("gottouched]");
                };; 
                if( ins(gar_byt_02) != ALT_555 ){
                    H("gottouched]");
                };; 
            
                //free( platform_version );
            };;



            #undef  WILD_WEST_CAST //:///////////////////////://

//       size_t siz = 0;
//       CLEB_AF_Success( "[ERROR:GPI#1]",
//           CLEB.clGetPlatformInfo(
//           /**/PID->arr[P] //:<---1st plaform
//           ,   CL_PLATFORM_VERSION //:param_name
//           ,   0     //:param_value_size
//           ,   NULL  //:param_value
//           ,   &siz  //:param_value_size_ret
//           )
//       );;CLEB_PV_size_t("[siz]",siz);
//       char* platform_version =( malloc(siz) );
//       CLEB_AF_Success( "[ERROR:GPI#2]",
//           CLEB.clGetPlatformInfo(
//           /**/PID->arr[P]
//           ,   CL_PLATFORM_VERSION
//           ,   siz
//           ,   platform_version
//           ,   NULL
//           )
//       );;CLEB_PV_STR("[platform_version]"
//                       ,platform_version );
//
//       free( platform_version );

        } //:SCOPE:GET_PLATFORM_VERSION
////    { //:SCOPE: clGetDeviceIDs ::::::::::::::::::::::::::://
////    //://////////////////////////////////////////////////://
////    #define VOD void //://///////////////////////////////://
////    extern VOD* g_2(devi_id, dev_arr)[10]; //:arr_dat
////    extern U32  g_2(devi_id, dev_num);     //:arr_num
////    extern int  g_2(devi_id, dev_cap);     //:arr_cap
////    extern int  g_2(devi_id, dev_dex);     //:sel_dex
////    #undef  VOD //://////////////////////////////////////://
////        
////        #define dev_ARR  g_2(devi_id, dev_arr) //:///////://
////        #define dev_NUM  g_2(devi_id, dev_num) //:///////://
////        #define dev_CAP  g_2(devi_id, dev_cap) //:///////://
////        #define dev_DEX  g_2(devi_id, dev_dex) //:///////://
////
////        int err=(0 - 444);
////        U32 typ_gpu=( INS(cl_device_type_gpu) );
////       
////        //:Get target platform handle:
////        //:han_pla == pid_arr[ pid_dex ]
////        //:platform_handle=platform_array[ selected_index ]
////        void* han_pla=(
////            g_2(plat_id, pid_arr)[
////            g_2(plat_id, pid_dex)]
////        );;
////
////        if(NIL==han_pla){  H("[PlatformHandleIsNull]"); };
////        
////        err=(int)(U64)INS(clGetDeviceIDs)(
////        /**/(void*)(U64)  han_pla    //:platform
////        ,   (void*)(U64)  typ_gpu    //:device_type
////        ,   (void*)(U64)  0          //:num_entries
////        ,   (void*)(U64)  NIL        //:devices
////        ,   (void*)(U64)&(dev_NUM)   //:num_devices
////        );;
////
////        //:Does pre allocated array have enough room
////        //:for all devices?
////        if( err != 0 ){ 
////            printf("[err]:%d\n", err );
////            printf("[err]:%0x\n", err );
////            if( err == (0-32)/**CL_INVALID_PLATFORM**/){
////                D("[(0-32):0xFFFFFFE0:INVALID_PLATFORM]");
////            };;
////            H("[2020_04_30:1238PM-A]");
////        };;
////
////        if( dev_NUM <= 0 ){ H("[NO_DEVICES]"); };
////        if( (int)dev_NUM > (int)dev_CAP ){
////            dev_NUM = (U32)dev_CAP;
////            D("[WARNING:Not_Enough_Slots:DEVICES]");
////        }else{
////            D("[OK:ENOUGH_ROOM_FOR_ALL_DEVICES]");
////        };;
////
////        printf("[NUM_DEVICES:%d\n",dev_NUM);
////        
////        err=(int)(U64)INS(clGetDeviceIDs)(
////        /**/(void*)(U64) han_pla      //:platform
////        ,   (void*)(U64) typ_gpu      //:device_type
////        ,   (void*)(U64) dev_NUM      //:num_entries
////        ,   (void*)(U64) dev_ARR      //:devices
////        ,   (void*)(U64) NIL          //:num_devices
////        );;
////
////        if( err != 0 ){ H("[2020_04_30:1238PM-B]");};
////
////        dev_DEX=( 0 );
////        D("[TODO: Logic for selecting device index]");
////
////        #undef  dev_ARR  //:    g_2(plat_id, pid_arr)    :// 
////        #undef  dev_NUM  //:    g_2(plat_id, pid_num)    :// 
////        #undef  dev_CAP  //:    g_2(plat_id, pid_cap)    :// 
////        #undef  dev_DEX  //:    g_2(plat_id, pid_dex)    :// 
////
////    //://////////////////////////////////////////////////://
////    }//:SCOPE: clGetDeviceIDs  ::::::::::::::::::::::::::://



    }    E_F(SRC_OPENCL_SETUP_main)  //://///////////////////://
//[MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:MAIN]//


//:AG:Any_CL:(BELOW):¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:                                                          ://
//: Decided to make a "GetAnyCLFuncAddress" to mirror        ://
//: the Open_Graphics_Library function of similiar name:     ://
//: "GetAnyGLFunctionAddress". Uncertain if this will        ://
//: be a needed function.                                    ://
//:                                                          ://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
    TYP(FUN) fun(GetAnyCLFuncAddress)( //:///////////////////://
        const char* ARG(fun_nam) //:name_of_open_cl_function
    ){
        
        TYP(FUN) 
        RET(FUN)=( FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
            "dll_com" //: dll_nam: "dll_com"==OpenCL*.DLL
        ,ARG(fun_nam) //: dll_com:dll_compute
        ));;

        return( RET(FUN) );

    }E_F(GetAnyCLFuncAddress)//://///////////////////////////://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:AG:Any_CL:(ABOVE):________________________________________://


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//