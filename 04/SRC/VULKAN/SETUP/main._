//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER|//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
#define    GM1( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) GM1( a   ,   b )              //| 04 |//
#define    K_1( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    K_2( a,b,c ) K_1( a   ,   b     ,   c )    //| 06 |//
#define    VAR( n ) GM2( VAR   ,               n )    //| 07 |//
#define    EII( n ) K_2( LIB, EII,             n )    //| 08 |//
#define    MEM( n ) K_2( LIB ,MEM,             n )    //| 09 |//
#define    INS( n ) K_2( LIB ,INS,             n )    //| 10 |//
#define    FUN( n ) K_2( LIB ,FUN,             n )    //| 11 |//
#define    TYP( n ) K_2( LIB ,TYP,             n )    //| 12 |//
#define    ARG( n ) GM2(      ARG,             n )    //| 13 |//
#define    RET( n ) GM2(      RET,             n )    //| 14 |//
#define    BRA( n ) K_2( lib, bra,             n )    //| 15 |//
#define    SUB( n ) K_2( lib, sub,             n )    //| 16 |//
#define    var( n ) GM2( v_2020_04_25_1007PM , n )    //| 17 |//
#define    eii( n ) GM2( e_2020_04_25_1007PM , n )    //| 18 |//
#define    mem( n ) GM2( m_2020_04_25_1007PM , n )    //| 19 |//
#define    ins( n ) GM2( i_2020_04_25_1007PM , n )    //| 20 |//
#define    fun( n ) GM2( f_2020_04_25_1007PM , n )    //| 21 |//
#define    typ( n ) GM2( t_2020_04_25_1007PM , n )    //| 22 |//
#define    arg( n ) GM2( a_2020_04_25_1007PM , n )    //| 23 |//
#define    ret( n ) GM2( r_2020_04_25_1007PM , n )    //| 24 |//
#define    bra( n ) GM2( b_2020_04_25_1007PM , n )    //| 25 |//
#define    sub( n ) GM2( s_2020_04_25_1007PM , n )    //| 26 |//
#define    obj( n ) GM2( o_2020_04_25_1007PM , n )    //| 27 |//
#define    poi( n ) GM2( p_2020_04_25_1007PM , n )    //| 28 |//
#define    NIL        ((void*)0)                      //| 29 |//
#define    siz( n ) GM2( S_2020_04_25_1007PM , n )    //| 30 |//
#define    num( n ) GM2( N_2020_04_25_1007PM , n )    //| 31 |//
#define    arr( n ) GM2( A_2020_04_25_1007PM , n )    //| 32 |//
#define    dex( n ) GM2( D_2020_04_24_1007PM , n )    //| 33 |//
#define      H          fun( Halt )                   //| 34 |//
#define      D          fun( Dmsg )                   //| 35 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 36 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 37 |//
#define    G_1(G,a    ) G ##_## a                     //| 38 |//
#define    G_2(G,a,b  ) G ##_## a ##_## b             //| 39 |//
#define    G_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 40 |//
#define    g_1(a      ) G_1( lib, a      )            //| 41 |//
#define    g_2(a,b    ) G_2( lib, a,b    )            //| 42 |//
#define    g_3(a,b,c  ) G_3( lib, a,b,c  )            //| 43 |//
#define    U32 unsigned           int                 //| 44 |//
#define    I32 signed             int                 //| 45 |//
#define    U64 unsigned long long int                 //| 46 |//
#define    I64 signed   long long int                 //| 47 |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
//:If the macro is banned, it means you'll have       //| -- |//
//:to use the private (lowercase) version and         //| -- |//
//:add getter code. OR you can be more generic        //| -- |//
//:and make the value a MEM(member_name).             //| -- |//
//:A bit rigid. But widdling down the ways things     //| -- |//
//:are allowed to be done should have benifits.       //| -- |//
#if defined( PTR ) || defined( ptr )                  //| -- |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| -- |//
#endif                                                //| -- |//
#if defined( SIZ )                                    //| -- |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( NUM )                                    //| -- |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( ARR )                                    //| -- |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( OBJ )                                    //| -- |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( POI )                                    //| -- |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
//:V_* can be confused as a local variable.           //| -- |//
//:F_* can be confused as function pyramid type.      //| -- |//
//:g_ : private global. (File scope variable.)        //| -- |//
#if defined( v_1 ) || defined( V_1 )                  //| -- |//
    #error USE: g_1,g_2,g_3,g_4 (NOT:V_)              //| -- |//
#endif                                                //| -- |//
#if defined( f_1 ) || defined( F_1 )                  //| -- |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| -- |//
#endif                                                //| -- |//
//|____________________________________________|V4_MEGAHEADER|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //[[////////////////////////////////////////////////////]]//
    //[]////#   Experiment:                            #////[]//
    //[]////#   Instead of trying to make something    #////[]//
    //[]////#   pronouncable, abbreviation rules will  #////[]//
    //[]////#   be the first three letters of word.    #////[]//
    //[]////#   All variables 2 words long.            #////[]//
    //[[////////////////////////////////////////////////////]]//

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_VULKAN_SETUP_MAIN ( 7623 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//[1111111111111111111111111111111111111111111111111111111111]//

    //:Things I'd like you to notice first:
    #define E extern TYP(FUN) //:////////////////////////////://
            E INS(vkCreateInstance);
            E INS(vkEnumerateInstanceExtensionProperties);
    #undef  E //:////////////////////////////////////////////://

//[1111111111111111111111111111111111111111111111111111111111]//
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://
    static void fun(Halt)( const char* msg ){printf( //:- - -://
    "[SRC_VULKAN_SETUP_MAIN:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC_VULKAN_SETUP_MAIN:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://
//:VULKAN_DLL_FUNCTION_POINTERS:////:////////////////////////://

    #define F TYP(FUN) //:///////////////////////////////////://
    #define N =( NIL );//:///////////////////////////////////://
            F INS(vkCreateInstance)                            N
            F INS(vkEnumerateInstanceExtensionProperties)      N
    #undef  N //:////////////////////////////////////////////://
    #undef  F //:////////////////////////////////////////////://

//:////////////////////////:////:VULKAN_DLL_FUNCTION_POINTERS://
//:TYPEDEFS_NODEPS: :T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0://

    //:Typedefs that do not rely on struct definitions.
    typedef void* typ(        vuk_ins) ;//:VkInstance

    struct typ(app_inf) {          //:VkApplicationInfo
        unsigned int      sType;   //:VkStructureType
        const void*       pNext;
        const char*       pApplicationName;
        unsigned int      applicationVersion; //:uint32_t
        const char*       pEngineName;
        unsigned int      engineVersion;      //:unsigned int
        unsigned int      apiVersion;         //:unsigned int
    }E_S(app_inf)

    //:VkExtensionProperties
    struct TYP(ext_pro){
        //:ext_nam: extensionName
        char MEM(ext_nam)[ 256 /*VK_MAX_EXTENSION_NAME_SIZE*/ ];

        //:spe_ver: specVersion
        U32 MEM(spe_ver); /** uint32_t **/

    }E_S(ext_pro)

//:T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0: :TYPEDEFS_NODEPS://
//:TYPEDEFS_01_DEP:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
    //:-------:cre_inf.vuk_ins:------------------------------://
    struct typ(cre_inf_vuk_ins) {   //:VkInstanceCreateInfo
        unsigned int         sType; //:VkStructureType
        const   void*        pNext;
        unsigned int         flags;

                             //:AKA:pApplicationInfo
        const struct         //:AKA:VkApplicationInfo*
                             typ(app_inf)*
                             poi(app_inf);

        unsigned      int    enabledLayerCount;
        const char* const*   ppEnabledLayerNames;

        //:Is "const char**" same as "const char* const*" ?
        //:In fact.. Both are "char**" with extra constraints.

        unsigned     int     enabledExtensionCount;
        const char* const*   ppEnabledExtensionNames;
    }E_S(cre_inf_vuk_ins)
//:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1:TYPEDEFS_01_DEP://
//:FILESCOPE_GLOBALS::GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG://

    //:Global variables used to setup our main Vulkan_Struct.
    //:( Vulkan_Struct == struct typ(vuk_mai) == vulkan_main )
    //:There should only be ONE reference to these used to
    //:populate the struct, and then always use the struct
    //:reference. Failure to do so will result in
    //:spaghetti code.

    //:wanted_instance_extensions
    int   g_2(ext_ins,wan_num)=( 2 );
    char* g_2(ext_ins,wan_arr)[  2 ]={
        "VK_KHR_surface"
    ,   "VK_KHR_win32_surface"
    };

    //:WHAT_INSTANCE_EXTENSIONS_ARE_AVALIABLE:                 _
    //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 49 ]                       _
    //:NO_SUCH_TYPE:VkInstanceExtensionProperties:             _
    //:THE_TYPE_IS :VkExtensionProperties                      _
    #define E_P  struct TYP(ext_pro)                           _
    #define CAP ( 4 ) /** Maximum_Capacity_Of_Array **/        _
    #define NUM (0-1) /** Number_Of_Valid_Entries:  **/        _
            int  g_2(ext_ins,pro_cap)=(CAP)                    S
            int  g_2(ext_ins,pro_num)=(NUM)                    S
            E_P  g_2(ext_ins,pro_arr)[ CAP ]={0}               S
    #undef  E_P  ///                                           _
    #undef  CAP  ///                                           _
    #undef  NUM  ///                                           _

//:GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG::FILESCOPE_GLOBALS://
//:VULKAN_STRUCT:VSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVS://
    struct typ(vuk_mai){ //:vulkan_main.

        struct
        typ(app_inf)   //:VkApplicationInfo
        mem(app_inf);  //:VkApplicationInfo

        termin
        typ(vuk_ins)   //:VkInstance/VulkanInstance
        mem(vuk_ins);  //:VkInstance/VulkanInstance

        struct bra(ext_ins){//:extensions:INSTANCE
            int    mem(wan_num);//:wanted_instance_extensions
            char** mem(wan_arr);//:wanted_instance_extensions

            //:InstanceExtensionProperties  //~//////////////://
            #define E_P struct TYP(ext_pro) //://////////////://
                //:typ(vuk_mai).sub(ext_ins).mem(pro_cap);
                //:typ(vuk_mai).sub(ext_ins).mem(pro_num);
                //:typ(vuk_mai).sub(ext_ins).mem(pro_arr);
                int    mem(pro_cap); //: properties_capacity
                int    mem(pro_num); //: properties_numberof
                E_P*   mem(pro_arr); //: properties_array
            #undef E_P //:///////////////////////////////////://

        }sub(ext_ins);

        struct bra(cre_inf){ //:cre_(ate)_inf_(o)

            struct //:ins(vuk_mai).sub(cre_inf).mem(vuk_ins);
            typ(cre_inf_vuk_ins)   //:VkInstanceCreateInfo
            mem(        vuk_ins);  //:VkInstanceCreateInfo

        }sub(cre_inf); //:///////////////////////////////////://


    }ins(vuk_mai)={
        0
    }E_S(vuk_mai)
//:VSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVS:VULKAN_STRUCT://

    //://////////////////////////////////////////////////////://
    static unsigned int fun(MakVer)( //:VK_MAKE_VERSION://///://
        unsigned int major
    ,   unsigned int minor
    ,   unsigned int patch
    ){
        unsigned int ret(mak_ver);
        ret(mak_ver) =(
            (((major) << 22) | ((minor) << 12) | (patch))
        );;
        return( ret(mak_ver) );
    }//://///////////////////////////////////////////////////://

//[MAIN:(BELOW):---------------------------------------------]//
//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//

    void EII(SRC_VULKAN_SETUP_main)( void )  //://///////////://
    {

    //:Before doing any vulkan setup, front load any needed
    //:function pointers from vulkan-1.dll:

    //:Use: "GetProcAddress" code for this.
    //:     Modify it to recognize "vuk_dll" as shorthand
    //:     code for "vulkan-1.dll"

    INS(vkCreateInstance)=FUN(GetProcAddress)(
    /**/    "dll_vuk" //:vulkan-1.dll
    ,       "vkCreateInstance" );;

    //:vkEnumerateInstanceExtensionProperties

    INS(vkEnumerateInstanceExtensionProperties)=
    FUN(GetProcAddress)(
    /**/ "dll_vuk"
    ,    "vkEnumerateInstanceExtensionProperties"
    );;


    #define vkm ins(vuk_mai) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    //:------------------------------------------------------://

        //:W:WantedInstanceExtensions:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://

        //: Loading: wanted_instance_extensions from
        //:          private file-scope variable into
        //:          our private struct.

        //:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
        #define NUM vkm.sub(ext_ins).mem(wan_num)  _ _ _ _ _ _ _
        #define ARR vkm.sub(ext_ins).mem(wan_arr)  _ _ _ _ _ _ _
                NUM  =  g_2(ext_ins     ,wan_num)              s
                ARR  =  g_2(ext_ins     ,wan_arr)              s
        #undef  ARR  /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  NUM  /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        //:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
        //:V:WantedInstanceExtensions:_______________________://
        //:VkApplicationInfo:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:AIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAI://
        #define MV fun(MakVer)         _ _ _ _ _ _ _ _ _ _ _ _ _
        #define AI vkm.mem(app_inf)    _ _ _ _ _ _ _ _ _ _ _ _ _
                AI.sType /**app_inf**/ =(0 /**app_inf**/ )     s
                AI.pApplicationName    = "HELLO_TRIANGLE"      s
                AI.applicationVersion  = MV(1,0,0)             s
                AI.pEngineName         = "No_Engine"           s
                AI.engineVersion       = MV(1,0,0)             s
                AI.apiVersion          = MV(1,0,0)             s
        #undef  AI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  MV /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        //:AIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAI://
        //:VkApplicationInfo:________________________________://
        //:VkInstanceCreateInfo:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 48 ](BottomOfPage)   ://
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        #define AI vkm.mem(app_inf)              _ _ _ _ _ _ _ _
        #define VI vkm.mem(vuk_ins)              _ _ _ _ _ _ _ _
        #define CI vkm.sub(cre_inf).mem(vuk_ins) _ _ _ _ _ _ _ _
                                                               _
                CI.sType = 1 /**1==INSTANCE_CREATE_INFO**/     s
                CI.poi(app_inf) = &( AI )                      s
                                                               _
            //:NUM:wanted_instance_extensions_count            _
            //:ARR:wanted_instance_extensions                  _
            #define NUM vkm.sub(ext_ins).mem(wan_num)  _ _ _ _ _
            #define ARR vkm.sub(ext_ins).mem(wan_arr)  _ _ _ _ _
            #define READONLY (const char* const*)      _ _ _ _ _
                                                               _
                CI.enabledExtensionCount  =  (           NUM ) s
                CI.ppEnabledExtensionNames=  ( READONLY  ARR ) s
                                                               _
                //:not going to use the "use_validation_layers"_
                //:switch like in VG03.ALL. Look how crazy     _
                //:this code is. You've obviously decided      _
                //:to play with the safteys off.               _
                CI.enabledLayerCount  = 0                      s
                CI.ppEnabledLayerNames=NIL                     s
                                                               _
            #undef  READONLY /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
            #undef  ARR      /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
            #undef  NUM      /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

            if( NIL == INS(vkCreateInstance) ){
                D("[NIL_FUNCTION_PTR:vkCreateInstance!]");
                H("[DID_YOU_FORGET_TO_LOAD_VULKAN_PTR?]");
            };;

            unsigned int res=(
                //:CAST:
                (unsigned int)(unsigned long long)

                //:FUNC:
                ( (TYP(F_03)) INS(vkCreateInstance)  )

                //:ARGS:
                (
                    &(CI) //:VkInstanceCreateInfo
                ,  ( NIL )
                ,   &(VI) //:VkInstance
                )
            );;
            if( 0 != res ){
                H( "[FAIL:vkCreateInstance]");
            }else{
                D( "[PASS:vkCreateInstance]");
            };;

        #undef  CI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  VI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  AI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 48 ](BottomOfPage)   ://
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        //:CI:VkInstanceCreateInfo:__________________________://

        //:SizeChecks:
        ;;;if( sizeof(U32) != 4 ){
            H("[FAIL:SIZECHECK:U32]");
        };;if( sizeof( struct TYP(ext_pro)  ) != 260 ){
            H("[FAIL:SIZECHECK:VkExtensionProperties]");
        };;

        //:EP:InstanceExtensionProperties:(BELOW):¯¯¯¯¯¯¯¯¯¯¯://
        //:EPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEP://
        #define VUK_FUN vkEnumerateInstanceExtensionProperties
        { //:SCOPE
            int res=(0-1);//:VkResult

            //:SizeChecks:
            if( sizeof(I32)!= 4 ){ H("[2020_04_27_0429AM-A]");}
            if( sizeof(U64)!= 8 ){ H("[2020_04_27_0429AM-B]");}

            int ava_num=(0-1); //:Available_Number(Amount)
            res=( (I32)(U64)
            (
                ((TYP(F_03))INS( VUK_FUN ))
                (
                    NIL //:<--Optional:FilterByValidationLayer
                ,   &( g_2(ext_ins,pro_num) ) //:extensionCount
                ,   NIL
                )
            ));
            if( res != 0 /**VK_SUCCESS**/ ){
                H("[2020_04_27:0419AM]");
            };;

            //:Do we have enough capacity to get everything?
            //://////////////////////////////////////////////://
            //:Keep it simple. We are not going to deal with
            //:malloc unless absolutely necessary. We can
            //:afford a bit of wasted space.
            if( ava_num > g_2(ext_ins,pro_cap) ){
                D("[WARN:CapacityNotLargeEnoughToGetAll]");
                D("[EXPECT:VK_INCOMPLETE]");
                g_2(ext_ins,pro_num) = g_2(ext_ins,pro_cap);
            }else{
                D("[OKAY:CapacityLargeEnoughToGetAll]");
                D("[EXPECT:VK_SUCCESS]");
                g_2(ext_ins,pro_num) = ava_num;
            };;
            //://////////////////////////////////////////////://

            res=( (I32)(U64)
            (
                ((TYP(F_03))INS( VUK_FUN ))
                (
                    //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 49 ]
                    //:"It takes an optional first parameter"
                    //:"that allows us to filter extensions "
                    //:"by a specific validation layer.     "
                    NIL //:<--Optional:FilterByValidationLayer
                ,   &( g_2(ext_ins,pro_num) ) //:extensionCount
                ,   &( g_2(ext_ins,pro_arr) ) //:pProperties
                )
            ));

            //:Did we get the expected success status?
            if( ava_num > g_2(ext_ins,pro_cap) ){
                if( res != 5 /**VK_INCOMPLETE**/ ){
                    H("[2020_04_27:0421AM-A]");
                };;
            }else{
                if( res != 0 /**VK_SUCCESS**/ ){
                    H("[2020_04_27:0421AM-A]");
                };;
            };;

            //:Copy over values to our main vulkan struct:
            vkm.sub(ext_ins).mem(pro_cap)=g_2(ext_ins,pro_cap);
            vkm.sub(ext_ins).mem(pro_num)=g_2(ext_ins,pro_num);
            vkm.sub(ext_ins).mem(pro_arr)=g_2(ext_ins,pro_arr);

            //:Loop over instance extensions as sanity check:
            #define E_P struct TYP(ext_pro) //://////////////://

                printf("\n[VkExtensionProperties:(BELOW)]\n");
                int  num(ext) = vkm.sub(ext_ins).mem(pro_num);
                E_P* arr(ext) = vkm.sub(ext_ins).mem(pro_arr);

                int     dex(ext) = 0;
                for(
                /**/    dex(ext)= 0
                ;       dex(ext) < num(ext)
                ;       dex(ext)++
                ){
                    //:VkExtensionProperties
                    printf("[extensionName]:%s\n"
                    , ( arr(ext)[ dex(ext) ] ).MEM(ext_nam)
                    );;
                };;
                fflush(stdout);

            #undef E_P //:///////////////////////////////////://

        } //:SCOPE
        #undef  VUK_FUN  //://///////////////////////////////://
        //:EPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEP://
        //:EP:InstanceExtensionProperties:(ABOVE):___________://

        //:WHEN DONE WITH SETUP:
        //:Do a check of entire struct to make sure every
        //:member is valid

    //:------------------------------------------------------://
    #undef  vkm  /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    }E_F(SRC_VULKAN_SETUP_main)//:///////////////////////////://
    //://////////////////////////////////////////////////////://

//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
//[MAIN:(ABOVE):---------------------------------------------]//


//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
#undef     GM1                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     K_1                                        //| 05 |//
#undef     K_2                                        //| 06 |//
#undef     VAR                                        //| 07 |//
#undef     EII                                        //| 08 |//
#undef     MEM                                        //| 09 |//
#undef     INS                                        //| 10 |//
#undef     FUN                                        //| 11 |//
#undef     TYP                                        //| 12 |//
#undef     ARG                                        //| 13 |//
#undef     RET                                        //| 14 |//
#undef     BRA                                        //| 15 |//
#undef     SUB                                        //| 16 |//
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     NIL                                        //| 29 |//
#undef     siz                                        //| 30 |//
#undef     num                                        //| 31 |//
#undef     arr                                        //| 32 |//
#undef     dex                                        //| 33 |//
#undef       H                                        //| 34 |//
#undef       D                                        //| 35 |//
#undef     E_S                                        //| 36 |//
#undef     E_F                                        //| 37 |//
#undef     G_1                                        //| 38 |//
#undef     G_2                                        //| 39 |//
#undef     G_3                                        //| 40 |//
#undef     g_1                                        //| 41 |//
#undef     g_2                                        //| 42 |//
#undef     g_3                                        //| 43 |//
#undef     U32                                        //| 44 |//
#undef     I32                                        //| 45 |//
#undef     U64                                        //| 46 |//
#undef     I64                                        //| 47 |//
#undef  termin                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
//:If the macro is banned, it means you'll have       //| -- |//
//:to use the private (lowercase) version and         //| -- |//
//:add getter code. OR you can be more generic        //| -- |//
//:and make the value a MEM(member_name).             //| -- |//
//:A bit rigid. But widdling down the ways things     //| -- |//
//:are allowed to be done should have benifits.       //| -- |//
#if defined( PTR ) || defined( ptr )                  //| -- |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| -- |//
#endif                                                //| -- |//
#if defined( SIZ )                                    //| -- |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( NUM )                                    //| -- |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( ARR )                                    //| -- |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( OBJ )                                    //| -- |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
#if defined( POI )                                    //| -- |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| -- |//
#endif                                                //| -- |//
//:V_* can be confused as a local variable.           //| -- |//
//:F_* can be confused as function pyramid type.      //| -- |//
//:g_ : private global. (File scope variable.)        //| -- |//
#if defined( v_1 ) || defined( V_1 )                  //| -- |//
    #error USE: g_1,g_2,g_3,g_4 (NOT:V_)              //| -- |//
#endif                                                //| -- |//
#if defined( f_1 ) || defined( F_1 )                  //| -- |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| -- |//
#endif                                                //| -- |//
//|____________________________________________|V4_MEGAHEADER|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://


//:BATSIN:
//:     bat: Branching_Type:
//:     sin: Sub___Instance:

//: ACTUAL: ARR_SIZ_NUM_RULES:
//:   TYPO: ARR_SIZ_NAM_RULES:
//:     "siz,num,arr" may also be built into the
//:     name of the variable instead of added as
//:     a "kind". Use whatever combination allows
//:     you to keep the base-name of the variable
//:     as xxx_xxx.
//:         EX: siz(tik_tok)  arr(tik_tok)
//:         OR:     siz_tok       arr_tok
//:
//:     siz,num,arr are all local.
//:     They are not qualified with the library name
//:     or obfuscated because they are local variables.
//:
//:     Do NOT make them file scope.

//: NESTING:
//| The answer to that is that if you need more than 3       |//
//| levels of indentation,you’re screwed anyway,and should   |//
//| fix your program.                                        |//
//| www.kernel.org/doc/html/v4.10/process/coding-style.html  |//


//:VK_TUT_2018:
//:     A PDF version of "vulkan-tutorial.com/"
//:     VK_TUT_2018 is my shortcut name that opens the
//:     tutorial on my computer.