//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1123AM_GL , n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1123AM_GL , n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1123AM_GL , n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1123AM_GL , n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1123AM_GL , n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1123AM_GL , n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1123AM_GL , n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1123AM_GL , n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1123AM_GL , n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1123AM_GL , n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1123AM_GL , n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1123AM_GL , n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1123AM_GL , n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1123AM_GL , n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1123AM_GL , n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1123AM_GL , n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_OPENGL_SETUP_MAIN ( 2020+04+27 - 1154 + 'G' )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/OPENGL(GRAPHICS_LIB)/SETUP/main._:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/OPENGL(GRAPHICS_LIB)/SETUP/main._:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG:// 
//[THINGS_ID_LIKE_YOU_TO_SEE_FIRST:11111111111111111111111111]//

    //:IN: SRC/NATIVE/CALLWRAP/GetProcAddress._ 
    //:CORRECT[ dll_gra ]WRONG[ han_gra ]( open_gl_handle )
    extern void* INS(dll_gra); //:<--HandleTo:OpenGL32.dll
           void* ins(con_gra); //:<--Context:Graphics

//[11111111111111111111111111:THINGS_ID_LIKE_YOU_TO_SEE_FIRST]//
//:TYPEDEFS::TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD://


    //:SetupForPointerToA:GetProcAddress:Function:SC[GPA_FUN]
    //://////////////////////////////////////////////////////://
    //:                                                      ://
    //: Below we are constructing type:                      ://
    //:                         TYP(GPA_FUN) / T(GPA_FUN)    ://
    //:                                                      ://
    //: It is a is like a generic function pointer, EXCEPT   ://
    //: that it returns a function pointer rather than a     ://
    //: void*. We need this specialized generic function     ://
    //: pointer because we cannot mix data pointers and      ://
    //: function pointers when casting.                      ://
    //:                                                      ://
    //: NO!  TYP(FUN) f = (TYP(FUN))INS(gen_fun)("FuncName"); //
    //: OK:  TYP(FUN) f = (TYP(FUN))INS(gpa_fun)("FuncName"); //
    //: OK:  TYP(FUN) f =           INS(gpa_fun)("FuncName"); //
    //:                                                      ://
    //://////////////////////////////////////////////////////://
    #define T( nam ) TYP( nam ) //://////////////////////////://

    typedef void       (* T(GEN_FUN) )(void);  //:Generic:FUNC
    typedef void          T(GEN_DAT)        ;  //:Generic:DATA
    typedef T(GEN_FUN) (* T(GPA_FUN) )(void*); //:GPA_Pointer

    #undef  T //:////////////////////////////////////////////://

//:TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD::TYPEDEFS://
//:FORWARD_DECLARATIONS::FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD://

    TYP(FUN) fun(GetAnyGLFuncAddress)( const char* );

//:FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD::FORWARD_DECLARATIONS://
//:OPENGL_FUNCTION_POINTERS::FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://

    //:T1:Teir_1:Teir_1_OpenGL_Function_Pointers:------------://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
    #define    N  =(NIL);/////////://////////////////////////://  
    #define    G  TYP(GPA_FUN)  //://////////////////////////://
    #define    F  TYP(FUN)      //://////////////////////////://  

        //:These function pointers can be immediately fetched.
        //:Other OpenGL function pointers require an OpenGL
        //:context to be created first. I believe because
        //:the function pointers are [instance/member]
        //:methods of your context. 
        G            ins(wglGetProcAddress   )                 N
        F            ins(wglGetCurrentContext)                 N
        TYP(F_01)    ins(wglCreateContext    )                 N
        TYP(F_02)    ins(wglMakeCurrent      )                 N
                    
        //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
        //|You must call wglMakeCurrent after m_hDC has been |//
        //|setup. stackoverflow.com/questions/2348332 SC[    |//
        //|mc-after-dc-url ]                                 |//
        //| - - - - - - - - - - - -- - - - - - - - - - - - - |//
        //|Before you can use OpenGL,the context you created |//
        //|must be made current. This is done with the       |//
        //|wglMakeCurrent function.                          |//
        //| - - - - - - - - - - - -- - - - - - - - - - - - - |//
        //|SEE:SC[ make_context_current_you_must_url ]       |//
        //|www.khronos.org/opengl/wiki/                      |//
        //|Creating_an_OpenGL_Context_(WGL)                  |//
        //|#Simple_Context_Creation                          |//
        //|COMMENT_RIPPED_FROM[ V:\GLEB\GLEB.H ]*************|//
        //|__________________________________________________|//

    #undef     N  //:////////////////////////////////////////://
    #undef     G  //:////////////////////////////////////////://
    #undef     F  //:////////////////////////////////////////://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

    //:T2:Teir_2:Teir_1_OpenGL_Function_Pointers:------------://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
    #define     N  =(NIL);/////////://///////////////////////://  
    #define     F  TYP(FUN)      //://///////////////////////://    

    /** 01 **/  F       ins(glGenBuffers                     ) N            
    /** 02 **/  F       ins(glBindBuffer                     ) N            
    /** 03 **/  F       ins(glBufferData                     ) N            
    /** 04 **/  F       ins(glGetError                       ) N            
    /** 05 **/  F       ins(glEnableVertexAttribArray        ) N
    /** 06 **/  F       ins(glVertexAttribPointer            ) N   
    /** 07 **/  F       ins(glDrawArrays                     ) N            
    /** 08 **/  F       ins(glDisableVertexAttribArray       ) N
    /** 09 **/  F       ins(glCreateShader                   ) N          
    /** 10 **/  F       ins(glShaderSource                   ) N          
    /** 11 **/  F       ins(glCompileShader                  ) N         
    /** 12 **/  F       ins(glGetShaderiv                    ) N           
    /** 13 **/  F       ins(glGetShaderInfoLog               ) N      
    /** 14 **/  F       ins(glCreateProgram                  ) N         
    /** 15 **/  F       ins(glAttachShader                   ) N          
    /** 16 **/  F       ins(glLinkProgram                    ) N           
    /** 17 **/  F       ins(glGetProgramiv                   ) N          
    /** 18 **/  F       ins(glGetProgramInfoLog              ) N     
    /** 19 **/  F       ins(glDetachShader                   ) N          
    /** 20 **/  F       ins(glDeleteShader                   ) N          
    /** 21 **/  F       ins(glClear                          ) N                 
    /** 22 **/  F       ins(glUseProgram                     ) N            
    /** 23 **/  F       ins(glViewport                       ) N              
    /** 24 **/  F       ins(glClearColor                     ) N            
    /** 25 **/  F       ins(glGenVertexArrays                ) N       
    /** 26 **/  F       ins(glBindVertexArray                ) N       
    /** 27 **/  F       ins(glGenTextures                    ) N           
    /** 28 **/  F       ins(glBindTexture                    ) N           
    /** 29 **/  F       ins(glTexParameteri                  ) N         
    /** 30 **/  F       ins(glTexImage2D                     ) N            
    /** 31 **/  F       ins(glActiveTexture                  ) N         
    /** 32 **/  F       ins(glGetUniformLocation             ) N    
    /** 33 **/  F       ins(glUniform1i                      ) N             
    /** 34 **/  F       ins(glPixelStorei                    ) N           
    /** 35 **/  F       ins(glEnable                         ) N                
    /** 36 **/  F       ins(glFinish                         ) N                
    /** 37 **/  F       ins(glGetIntegerv                    ) N           
                    
    #undef      N  //:///////////////////////////////////////://
    #undef      F  //:///////////////////////////////////////://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
//:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP::OPENGL_FUNCTION_POINTERS://
//:OPEN_GL_ENUMERATIONS:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE://

    //:Sizes of various openGL types:
    //:     www.khronos.org/opengl/wiki/OpenGL_Type
    //:
    //:Good lookup tool to verify enum values:
    //:     docs.factorcode.org/search?search=GLbool

    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)
    //://////////////////////////////////////////////////////://
    #define  E_M BLUE_PENGUINS_ON_PARADE //:ERROR_MESSAGE
    #define  D_T U32                     //:DECLARE_TYPE(ALL)
    #define  E_0(con,msg) _Static_assert( con, msg )
    #define  E_1(t_t,msg) E_0(sizeof(t_t) > 0, msg )
    #define  A_1 _Static_assert
    #define  A_2(h_d,msg_nam) A_1(               h_d,#msg_nam )
    #define  A_3(h_d,nam,msg) A_2(               h_d, msg:nam )
    #define  A_4(h_d,nam,msg) A_3(               h_d, nam,msg )
    #define  A_5(nam,hex,dec) A_4(          hex==dec, nam,E_M )
    #define  A_6(nam,hex,dec) A_5(   nam  , hex ,dec          )
    #define  D_1(nam,hex    ) D_T INS(nam) = hex
    #define  D_2(nam,hex    ) D_1(    nam  , hex       )
    #define  DA1(nam,hex,dec) D_2(nam,hex) ; A_6(nam,hex,dec)
    #define  DA2(nam,hex,dec,eye_tot) DA1(nam,hex,dec)
        
        //:DA: Declare & Assert
        //:HackishChecksum:Check hex against decimal for match.
        DA2( gl_unsigned_byte        ,0x1401    , 5121  , 01 ) ;
        DA2( gl_texture_min_filter   ,0x2801    , 10241 , 02 ) ;
        DA2( gl_texture_mag_filter   ,0x2800    , 10240 , 03 ) ;
        DA2( gl_texture_wrap_s       ,0x2802    , 10242 , 04 ) ;       
        DA2( gl_texture_wrap_t       ,0x2803    , 10243 , 05 ) ;
        DA2( gl_nearest              ,0x2600    , 9728  , 06 ) ;
        DA2( gl_clamp_to_edge        ,0x812F    , 33071 , 07 ) ;
        DA2( gl_texture0             ,0x84C0    , 33984 , 08 ) ;
        DA2( gl_max_uniform_locations,1024      , 1024  , 09 ) ;
        DA2( gl_unpack_alignment     ,0x0CF5    , 3317  , 10 ) ;
        DA2( gl_texture_2d           ,0x0DE1    , 3553  , 11 ) ;
        DA2( gl_texture_binding_2d   ,0x8069    , 32873 , 12 ) ;
        DA2( gl_rgba_integer         ,0x8D99    , 36249 , 13 ) ;
        DA2( gl_active_texture       ,0x84E0    , 34016 , 14 ) ;
        DA2( gl_rgba8ui              ,0x8D7C    , 36220 , 15 ) ;
        DA2( gl_float                ,0x1406    , 5126  , 16 ) ;
        DA2( gl_true                 ,1         ,     1 , 17 ) ;
        DA2( gl_false                ,0         ,     0 , 18 ) ;
        DA2( gl_array_buffer         ,0x8892    , 34962 , 19 ) ;
        DA2( gl_static_draw          ,0x88E4    , 35044 , 20 ) ;
        DA2( gl_no_error             ,0x0       ,     0 , 21 ) ;
        DA2( gl_triangles            ,0x0004    ,     4 , 22 ) ;
        DA2( gl_triangle_fan         ,0x0006    ,     6 , 23 ) ;
        DA2( gl_triangle_strip       ,0x0005    ,     5 , 24 ) ;
        DA2( gl_vertex_shader        ,0x8B31    , 35633 , 25 ) ;
        DA2( gl_fragment_shader      ,0x8B30    , 35632 , 26 ) ;
        DA2( gl_compile_status       ,0x8B81    , 35713 , 27 ) ;
        DA2( gl_info_log_length      ,0x8B84    , 35716 , 28 ) ;
        DA2( gl_link_status          ,0x8B82    , 35714 , 29 ) ;
        DA2( gl_color_buffer_bit     ,0x00004000, 16384 , 30 ) ;

        //:E_#:Exists: Assert these INS(___) types exist
        //:    by using static type assertion and sizeof(...)
        //:    WRITTEN THIS WAY SO YOU CAN USE "CTRL+F" on
        //:    the name of the type and have an chance of
        //:    figuring out how+where it is defined. 
        //:    (It is defined  ABOVE in this macro section)
        //:    (And   verified BELOW in this macro section)
        E_1( INS(gl_unsigned_byte        ) , "eye_tot:01" );
        E_1( INS(gl_texture_min_filter   ) , "eye_tot:02" );
        E_1( INS(gl_texture_mag_filter   ) , "eye_tot:03" );
        E_1( INS(gl_texture_wrap_s       ) , "eye_tot:04" );
        E_1( INS(gl_texture_wrap_t       ) , "eye_tot:05" );
        E_1( INS(gl_nearest              ) , "eye_tot:06" );
        E_1( INS(gl_clamp_to_edge        ) , "eye_tot:07" );
        E_1( INS(gl_texture0             ) , "eye_tot:08" );
        E_1( INS(gl_max_uniform_locations) , "eye_tot:09" );
        E_1( INS(gl_unpack_alignment     ) , "eye_tot:10" );
        E_1( INS(gl_texture_2d           ) , "eye_tot:11" );
        E_1( INS(gl_texture_binding_2d   ) , "eye_tot:12" );
        E_1( INS(gl_rgba_integer         ) , "eye_tot:13" );
        E_1( INS(gl_active_texture       ) , "eye_tot:14" );
        E_1( INS(gl_rgba8ui              ) , "eye_tot:15" );
        E_1( INS(gl_float                ) , "eye_tot:16" );
        E_1( INS(gl_true                 ) , "eye_tot:17" );
        E_1( INS(gl_false                ) , "eye_tot:18" );
        E_1( INS(gl_array_buffer         ) , "eye_tot:19" );
        E_1( INS(gl_static_draw          ) , "eye_tot:20" );
        E_1( INS(gl_no_error             ) , "eye_tot:21" );
        E_1( INS(gl_triangles            ) , "eye_tot:22" );
        E_1( INS(gl_triangle_fan         ) , "eye_tot:23" );
        E_1( INS(gl_triangle_strip       ) , "eye_tot:24" );
        E_1( INS(gl_vertex_shader        ) , "eye_tot:25" );
        E_1( INS(gl_fragment_shader      ) , "eye_tot:26" );
        E_1( INS(gl_compile_status       ) , "eye_tot:27" );
        E_1( INS(gl_info_log_length      ) , "eye_tot:28" );
        E_1( INS(gl_link_status          ) , "eye_tot:29" );
        E_1( INS(gl_color_buffer_bit     ) , "eye_tot:30" );
            
    #undef   E_M    //://////////////////////////////////////://
    #undef   D_T    //://////////////////////////////////////://
    #undef   E_0    //://////////////////////////////////////://
    #undef   E_1    //://////////////////////////////////////://
    #undef   A_1    //://////////////////////////////////////://
    #undef   A_2    //://////////////////////////////////////://
    #undef   A_3    //://////////////////////////////////////://
    #undef   A_4    //://////////////////////////////////////://
    #undef   A_5    //://////////////////////////////////////://
    #undef   A_6    //://////////////////////////////////////://
    #undef   D_1    //://////////////////////////////////////://
    #undef   D_2    //://////////////////////////////////////://
    #undef   DA1    //://////////////////////////////////////://
    #undef   DA2    //://////////////////////////////////////://
    //://////////////////////////////////////////////////////://
    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)

//:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:OPEN_GL_ENUMERATIONS://
//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
    void EII(SRC_OPENGL_SETUP_main)(void){ //:///////////////://

        //:T1:Teir_1:Grab Teir 1 OpenGL Functions:
        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

        #define g_p_a FUN(SRC_NATIVE_CALLWRAP_GetProcAddress) //
        #define G_P_A( a ) g_p_a( "dll_gra",  a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!ins( a )){ H( #a"[IS_NULL]" ); };
        #define     N( a ) n( a ) //:////////////////////////://

            #define G0( a ) G( a )
            #define G1( a ) (TYP(F_01))G( a )
            #define G2( a ) (TYP(F_02))G( a )

            //:MACROS:
            //:     G: Calls GetProcAddress
            //:     N: Null  Checks Function Pointer

            //:wglGetProcAddress: IS_SPECIAL:
            //:wglGetProcAddress cant simply be casted to
            //:our regular generic function pointer type
            //:that returns (void*).
            //:WHY:
            //:void* is a generic datapointer, it needs to 
            //:return geneneric functionpointer to not violate
            //:strict C rules.
            ins(wglGetProcAddress   )=(
                (TYP(GPA_FUN))G( wglGetProcAddress    ));;

            ins(wglGetCurrentContext)=G0( wglGetCurrentContext);
            ins(wglCreateContext    )=G1( wglCreateContext    );
            ins(wglMakeCurrent      )=G2( wglMakeCurrent      );

            N(wglGetProcAddress   ); //:NULL_CHECKS
            N(wglGetCurrentContext); //:NULL_CHECKS
            N(wglCreateContext    ); //:NULL_CHECKS
            N(wglMakeCurrent      ); //:NULL_CHECKS

            #undef G0
            #undef G1
            #undef G2

        #undef  g_p_a  //:///////////////////////////////////://
        #undef  G_P_A  //:///////////////////////////////////://
        #undef      G  //:///////////////////////////////////://
        #undef      n  //:///////////////////////////////////://
        #undef      N  //:///////////////////////////////////://

        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
        
        //:get_window_device_context:
        //:con_win==windows_handle_to_device_context
        //:con_win::CONtext_WINdow
        void* var(con_win)=(
            FUN(SRC_NATIVE_WINDOW_CREATION_GetWinDC)( ) );;
        if(NIL==var(con_win)){ H("[FAIL:NIL_GET:con_win]");};
        if(NIL!=var(con_win)){ D("[PASS:GET_GOT:con_win]");};

        //:make:open_gl_rendering_context:AKA:OpenGL_Context
        //:con_gra==handle_to_gl_rendering_context
        //:con_gra::CONtext_GRAphics
        ins(con_gra)=( ins(wglCreateContext)( var(con_win) ) );
        if(NIL==ins(con_gra)){ H("[FAIL:NIL_MAKE:con_gra]");};
        if(NIL!=ins(con_gra)){ D("[PASS:GOT_MADE:con_gra]");};

        //# CONTEXT_MUST_BE_MADE_CURRENT_BEFORE_WE_CAN_FETCH #//
        //# OTHER_FUNCTIONS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! #//
        int v_2(wglMakeCurrent,worked)=( 0 );
            v_2(wglMakeCurrent,worked)=(
                (int)(U64)
                ins(wglMakeCurrent)(
                    var(con_win) //: HDC   ( void* )
                ,   ins(con_gra) //: HGLRC ( void* )
                )
            );;
            if( 1!=v_2(wglMakeCurrent,worked) ){ H("[M_C]");};
            if( 1==v_2(wglMakeCurrent,worked) ){ D("[M_C]");};

        //:T2:Teir_2:( 2nd_tier_opengl_function_pointers )
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
        //://////////////////////////////////////////////////://
        #define g_p_a fun(GetAnyGLFuncAddress)       //://///://
        #define G_P_A( a ) g_p_a(             a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!ins( a )){ H( #a"[IS_NULL]" ); };
        #define     o( a ) if( ins( a )){ D( "[OK_YEAH]"#a ); };
        #define     N( a ) n( a ) //:////////////////////////://

            //:G_N:Get_function_pointer_AND_check_for_null.
            //://////////////////////////////////////////////://
            #define G_N( a ) ins( a )=G( a );N( a ); o( a );

                    G_N( glGenBuffers               );//| 01 |//
                    G_N( glBindBuffer               );//| 02 |//
                    G_N( glBufferData               );//| 03 |//
                    G_N( glGetError                 );//| 04 |//
                    G_N( glEnableVertexAttribArray  );//| 05 |//
                    G_N( glVertexAttribPointer      );//| 06 |//
                    G_N( glDrawArrays               );//| 07 |//
                    G_N( glDisableVertexAttribArray );//| 08 |//
                    G_N( glCreateShader             );//| 09 |//
                    G_N( glShaderSource             );//| 10 |//
                    G_N( glCompileShader            );//| 11 |//
                    G_N( glGetShaderiv              );//| 12 |//
                    G_N( glGetShaderInfoLog         );//| 13 |//
                    G_N( glCreateProgram            );//| 14 |//
                    G_N( glAttachShader             );//| 15 |//
                    G_N( glLinkProgram              );//| 16 |//
                    G_N( glGetProgramiv             );//| 17 |//
                    G_N( glGetProgramInfoLog        );//| 18 |//
                    G_N( glDetachShader             );//| 19 |//
                    G_N( glDeleteShader             );//| 20 |//
                    G_N( glClear                    );//| 21 |//
                    G_N( glUseProgram               );//| 22 |//
                    G_N( glViewport                 );//| 23 |//
                    G_N( glClearColor               );//| 24 |//
                    G_N( glGenVertexArrays          );//| 25 |//
                    G_N( glBindVertexArray          );//| 26 |//
                    G_N( glGenTextures              );//| 27 |//
                    G_N( glBindTexture              );//| 28 |//
                    G_N( glTexParameteri            );//| 29 |//
                    G_N( glTexImage2D               );//| 30 |//
                    G_N( glActiveTexture            );//| 31 |//
                    G_N( glGetUniformLocation       );//| 32 |//
                    G_N( glUniform1i                );//| 33 |//
                    G_N( glPixelStorei              );//| 34 |//
                    G_N( glEnable                   );//| 35 |//
                    G_N( glFinish                   );//| 36 |//
                    G_N( glGetIntegerv              );//| 37 |//

            #undef  G_N //://////////////////////////////////://
            //://////////////////////////////////////////////://

        #undef  g_p_a   //://////////////////////////////////://
        #undef  G_P_A   //://////////////////////////////////://
        #undef      G   //://////////////////////////////////://
        #undef      n   //://////////////////////////////////://
        #undef      o   //://////////////////////////////////://
        #undef      N   //://////////////////////////////////://
        //://////////////////////////////////////////////////://
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://


    }    E_F(SRC_OPENGL_SETUP_main)  //://///////////////////://
//[MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:MAIN]//


//:AG:Any_GL:(BELOW):¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:                                                          ://
//: AG: Any GL ( Get Any OpenGL Function Pointer )           ://
//:                                                          ://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:wglGetProcAddress will not return function pointers from  ://
//:any OpenGL functions that are directly exported by the    ://
//:OpenGL32.DLL itself. This means the old ones from OpenGL  ://
//:version 1.1. Fortunately those functions can be obtained  ://
//:by the Win32's GetProcAddress. On the other hand          ://
//:GetProcAddress will not work for the functions for which  ://
//:wglGetProcAddress works. So in order to get the address of://
//:any GL function one can try with wglGetProcAddress and if ://
//:it fails,try again with the Win32's GetProcAddress:       ://
//:SOURCE[ URL[                                              ://
//:                                                          ://
//:      www.khronos.org/opengl/wiki/Load_OpenGL_Functions   ://
//:                                                          ://
//: ]URL]SOURCE                                              ://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
    TYP(FUN) fun(GetAnyGLFuncAddress)( //:///////////////////://
        const char* ARG(fun_nam) //:name_of_open_gl_function
    ){
        //:Remove const qualifier:
        char* fun_nam=(char*)ARG(fun_nam);

        //:This MIGHT be the only call you need:
        TYP(FUN) ret_pfn=( ins(wglGetProcAddress)( fun_nam ) );

        //:Unless some weird math with the function pointer
        //:or null is returned. SEE[ Load_OpenGL_Functions ]
        if(
            ( ret_pfn ==        0       ) ||
            ( ret_pfn == ( TYP(FUN) )0x1) || 
            ( ret_pfn == ( TYP(FUN) )0x2) ||
            ( ret_pfn == ( TYP(FUN) )0x3) ||
            ( ret_pfn == ( TYP(FUN) ) -1) ||
        0){
            //:If we are in this section, these are the special
            //:function pointers that require an opengl 
            //:instance. So if dll_gra is NIL, we did not
            //:do things in the correct order and consider
            //:the fact that it worked co-incidential.
            //:AKA:Undefined Behavior.
            if(NIL==INS(dll_gra) ){ H("[2020_04_28_0131AM]");};
            ret_pfn=FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
            /**/    "dll_gra" //:DLL_Graphics:OpenGL.dll
            ,       fun_nam   //:name_of_open_gl_function
            );;
            if(NIL==ret_pfn){ H("[2020_04_28_0205AM]"); };
        };;
        if(NULL==ret_pfn){ H("[2020_04_28_0128AM]");};;
        return(  ret_pfn );
    }E_F(GetAnyGLFuncAddress)//://///////////////////////////://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:AG:Any_GL:(ABOVE):________________________________________://


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//


//:COMMENTS_SECTION:

    //[#GL_FLOAT#]////|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //|On a platfrom that supports IEEE-754 float it's going |//
    //|to be 32 bit. On platforms that don't,different width |//
    //|will probably be the least of your problems. Bottom   |//
    //|line - use float and don't worry.                     |//
    //|stackoverflow.com/questions/18705192                  |//
    //|                                                      |//
    //|glcoarearb.h : typedef       khronos_float_t GLfloat; |//
    //|khrplatform.h: typedef float khronos_float_t        ; |// 
    //|                                                      |//
    //|THIS_WILL_BE_GOOD_ENOUGH:                             |//
    //|typedef float GLfloat;                                |//
    //|                                                      |//
    //|______________________________________________________|//