//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/DEPENDENCIES._


//:Dependencies:
#include <stdio.h> //:for: printf(...)
#include <assert.h> //:define NDEBUG to turn off assertions.


//:Not a fan of windows header injecting macros all over
//:the place into my code. We will use my "DLLL" hack instead.
////////////////////////////////////////////////////////////////
//: #include <windows.h> //:GetProcAddress, LoadLibrary

    //:Demo file: "V:\VG\03\W32\DLLL\DEMO\DLLL.C11"
    //:            Has the imports in this order:
    #include "V:/VG/03/W32/DLLL/DLLL.COMSET"
    #include "V:/VG/03/W32/DLLL/TARG/W10.X64"
    #include "V:/VG/03/W32/DLLL/DLLL.H"

    //:Access to:
    //:     DLLL_LoadLibraryA
    //:     DLLL_GetProcAddress

////////////////////////////////////////////////////////////////


//}
//++++EXE_CAT:ABOVE+//:./SRC/DEPENDENCIES._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/PROJECT_PREFIX.DEFINE._


#define MACRO_project_prefix_HIDDEN  vg04  
#define MACRO_project_prefix_VISIBLE VG04 

//:These macros are used to give the prefix "vg04" to
//:"private" data and "VG04" to public data.
//:
//: HIDDEN  == private
//: VISIBLE == public
//:
//:
//: Use the words "HIDDEN" and "VISIBLE" so that
//: can abbreviate as: "V" and "H" or "VIS" and "HID".
//:

//}
//++++EXE_CAT:ABOVE+//:./SRC/PROJECT_PREFIX.DEFINE._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/FUNCTION_TYPEDEF_PYRAMID._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1153AM_FTP, n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1153AM_FTP, n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1153AM_FTP, n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1153AM_FTP, n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1153AM_FTP, n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1153AM_FTP, n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1153AM_FTP, n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1153AM_FTP, n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1153AM_FTP, n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1153AM_FTP, n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1153AM_FTP, n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1153AM_FTP, n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1153AM_FTP, n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1153AM_FTP, n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1153AM_FTP, n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1153AM_FTP, n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

    #define  T typedef /////////////////////////////////: 01 :// 
    #define  V void* ///////////////////////////////////: 02 :// 
    #define  a void* ///////////////////////////////////: 03 :// 
    #define  b void* ///////////////////////////////////: 04 :// 
    #define  c void* ///////////////////////////////////: 05 :// 
    #define  d void* ///////////////////////////////////: 06 :// 
    #define  e void* ///////////////////////////////////: 07 :// 

    T V (*TYP(F_00) )( void );
    T V (*TYP(F_01) )( a                                      );
    T V (*TYP(F_02) )( a,a                                    );
    T V (*TYP(F_03) )( a,a,a                                  );
    T V (*TYP(F_04) )( a,a,a,a                                );
    T V (*TYP(F_05) )( a,a,a,a,b                              );
    T V (*TYP(F_06) )( a,a,a,a,b,b                            );
    T V (*TYP(F_07) )( a,a,a,a,b,b,b                          );
    T V (*TYP(F_08) )( a,a,a,a,b,b,b,b                        );
    T V (*TYP(F_09) )( a,a,a,a,b,b,b,b,c                      );
    T V (*TYP(F_10) )( a,a,a,a,b,b,b,b,c,c                    );
    T V (*TYP(F_11) )( a,a,a,a,b,b,b,b,c,c,c                  );
    T V (*TYP(F_12) )( a,a,a,a,b,b,b,b,c,c,c,c                );
    T V (*TYP(F_13) )( a,a,a,a,b,b,b,b,c,c,c,c,d              );
    T V (*TYP(F_14) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d            );
    T V (*TYP(F_15) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d          );
    T V (*TYP(F_16) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d        );
    T V (*TYP(F_17) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e      );
    T V (*TYP(F_18) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e    );
    T V (*TYP(F_19) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e  );
    T V (*TYP(F_20) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e,e);

    #undef   T /////////////////////////////////////////: 01 :// 
    #undef   V /////////////////////////////////////////: 02 :// 
    #undef   a /////////////////////////////////////////: 03 :// 
    #undef   b /////////////////////////////////////////: 04 :// 
    #undef   c /////////////////////////////////////////: 05 :// 
    #undef   d /////////////////////////////////////////: 06 :// 
    #undef   e /////////////////////////////////////////: 07 :// 

//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/FUNCTION_TYPEDEF_PYRAMID._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/MAINLOOP/looptable._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1134AM_LT , n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1134AM_LT , n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1134AM_LT , n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1134AM_LT , n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1134AM_LT , n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1134AM_LT , n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1134AM_LT , n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1134AM_LT , n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1134AM_LT , n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1134AM_LT , n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1134AM_LT , n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1134AM_LT , n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1134AM_LT , n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1134AM_LT , n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1134AM_LT , n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1134AM_LT , n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_MAINLOOP_LOOPTABLE ( 6437 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC_MAINLOOP_LOOPTABLE:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC_MAINLOOP_LOOPTABLE:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://
//:GLOBALS: GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG://

    //:HACK:Private copy so stub functions can reference:
    int ins(game_time_copy_for_stub_functions)=0;


//:GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG :GLOBALS://
//:STUB_FUNCTION:  SFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSF://

    //:I don't want the STUB_FUNCTION to be completely
    //:obfuscated as a private function. But use "hidden"
    //:access to communicate it is not public.
    #define STUB_FUNCTION( nam ) GM3(lib,STUB_FUNCTION,nam)
    #define GAM_TIM ins( game_time_copy_for_stub_functions )
       
        static void 
        STUB_FUNCTION(nat_win)( void ){
            if( GAM_TIM < 3 ){
                printf("[STUB_FUNCTION:nat_win]\n");
            };;
            if( GAM_TIM == 64){
                printf("[RUNNING_WITHOUT_ECHOS_NOW:nat_win]\n");
                fflush(stdout);
            };;
        }
        static void 
        STUB_FUNCTION(gam_obj)( void ){
            if( ins( game_time_copy_for_stub_functions )< 3 ){
                printf("[STUB_FUNCTION:gam_obj]\n");
            };;
            if( GAM_TIM == 64){
                printf("[RUNNING_WITHOUT_ECHOS_NOW:gam_obj]\n");
                fflush(stdout);
            };;
        }
        static void 
        STUB_FUNCTION(ren_log)( void ){
            if( ins( game_time_copy_for_stub_functions )< 3 ){
                printf("[STUB_FUNCTION:ren_log]\n");
            };;
            if( GAM_TIM == 64){
                printf("[RUNNING_WITHOUT_ECHOS_NOW:ren_log]\n");
                fflush(stdout);
            };;
        }

    #undef  GAM_TIM       //:////////////////////////////////://
    #undef  STUB_FUNCTION //:////////////////////////////////://
//:SFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSF  :STUB_FUNCTION://
//:STRUCTS: SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS://

    typedef void (*TYP(FUN))(void); //:GenericFunctionPointer

    struct TYP(looptable){

        unsigned long MEM(str_typ);

        int MEM(lop_tim); //:Loop_Times
        int MEM(gam_tim); //:Game_Time

        #define T TYP(FUN) //:///////////////////////////////://

                //:Native_Window_Update_Logic:
                //:native_window
                T MEM(nat_win); 

                //:Logic_Of_Game_Objects:
                //:Game_Logic_Upate
                //:game_objects
                T MEM(gam_obj); 

                //:Rendering_Engine_Logic
                //:Rendering_Update
                T MEM(ren_log);

        #undef  T //:////////////////////////////////////////://
    }INS(looptable)={
        .MEM(str_typ)=( 0x0 | ( 'L'<<0|'O'<<8|'O'<<16|'P'<<24) )

       ,.MEM(lop_tim)=(0)

        //:Stub functions are to be overwritten:
        #define STUB_FUNCTION( nam ) GM3(lib,STUB_FUNCTION,nam)

       ,.MEM(nat_win)=STUB_FUNCTION(nat_win)
       ,.MEM(gam_obj)=STUB_FUNCTION(gam_obj)
       ,.MEM(ren_log)=STUB_FUNCTION(ren_log)

        #undef STUB_FUNCTION ///////////////////////////////////
    };


//:SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS :STRUCTS://
//:FUNCTIONS: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF://

    void
    EII(SRC_MAINLOOP_looptable)( void ){

        //:Any initialization upon inclusion of file goes here.

    }

    //:Note: "Tick" and "Loop" functions are not namespaced
    //:      out very well. But don't worry about that until
    //:      a collision actually happens.

    void FUN(Tick)( void ){

        //:Not necessary to check for null, but probably
        //:should anyways. Can remove these checks when
        //:optimizing.
        int problems=( 0 );
        if( NIL == INS(looptable).MEM(nat_win) ){
            D("[NIL_LOOPTABLE_FUNC:nat_win]");
            problems++;
        };;
        if( NIL == INS(looptable).MEM(gam_obj) ){
            D("[NIL_LOOPTABLE_FUNC:gam_obj]");
            problems++;
        };;
        if( NIL == INS(looptable).MEM(ren_log) ){
            D("[NIL_LOOPTABLE_FUNC:ren_log]");
            problems++;
        };;
        if( problems > 0 ){
            H("[WEVE_GOT_SOME_NULL_POINTER_PROBLEMS]");
        };;

        //:Because we set stub functions when intializing
        //:the loop table, we never have to do nullchecks.
        //:before calling.
        INS(looptable).MEM(nat_win)();
        INS(looptable).MEM(gam_obj)();
        INS(looptable).MEM(ren_log)();

        //:Track number of completed loops:
        INS(looptable).MEM(lop_tim)++;

        //:Game_Time: In the case that we would like
        //:To pause game or slow down time, we can change
        //:this value at a slower rate in future.
        INS(looptable).MEM(gam_tim)++;
    
        //:Copy over game time variable so that stub
        //:functions have access to it:
        ins(game_time_copy_for_stub_functions)=(
            INS(looptable).MEM(gam_tim)
        );;
    }

    void FUN(Loop)( void ){ //:Loops forever, no exit

        while( 1 ){

            FUN(Tick)( /** NO_ARGUMENTS **/ );

        };;
    }

//:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF :FUNCTIONS://



//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/MAINLOOP/looptable._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/NATIVE/CALLWRAP/LoadLibrary._



//:SEE: GetProcAddress

#define SRC_NATIVE_CALLWRAP_LOADLIBRARY ( 1934 )

//}
//++++EXE_CAT:ABOVE+//:./SRC/NATIVE/CALLWRAP/LoadLibrary._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/NATIVE/CALLWRAP/GetProcAddress._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1139AM_GPA, n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1139AM_GPA, n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1139AM_GPA, n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1139AM_GPA, n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1139AM_GPA, n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1139AM_GPA, n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1139AM_GPA, n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1139AM_GPA, n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1139AM_GPA, n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1139AM_GPA, n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1139AM_GPA, n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1139AM_GPA, n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1139AM_GPA, n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1139AM_GPA, n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1139AM_GPA, n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1139AM_GPA, n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//



    #define SRC_NATIVE_CALLWRAP_GETPROCADDRESS ( 434 )
    


//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/NATIVE/CALLWRAP/GetProcAddress:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/NATIVE/CALLWRAP/GetProcAddress:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://


//:INSTANCES: //:////////////////////////////////////////////://

    void* INS( dll_k32 ) = NIL; //:Kernel32.dll pointer
    void* INS( dll_u32 ) = NIL; //:User32.dll   pointer
    void* INS( dll_g32 ) = NIL; //:Gdi32.dll    pointer
    void* INS( dll_vuk ) = NIL; //:vulkan-1.dll pointer

    //:If you have trouble getting pointers to OpenGL.dll
    //:You may have to add your "OPEN_CL_SEARCH_PATHS.TXT"
    //:and "OPEN_GL_SEARCH_PATHS.TXT" code to this project.
    //:I have a feeling this MIGHT be the case for OpenCL.
    void* INS( dll_gra ) = NIL; //:OpenGL.dll   pointer
    void* INS( dll_com ) = NIL; //:OpenCL.dll   pointer

//:TYPEDEFS: ////////////////////////////////////////////////://

    typedef void (* TYP(Func) )(void); //:Function pointer.
    typedef void*   TYP(Data)        ; //:Data     pointer.
    typedef const char* TYP(Str)     ; //:String   pointer.

    //:TYPEDEF_FARPROC / DLLL_FUNC / DFUN
    //:DFUN=="DLL Function"
    typedef
        unsigned long long               //:RETURNS
        ( __stdcall  *TYP(DFUN)       )  //:NAME
        ( /**NOT_SPECIFIED != void**/ ); //:PARAMS



//:FORWARD_DECLARATIONS: //://///////////////////////////////://

    void EII( SRC_NATIVE_CALLWRAP_getprocaddress )( void );

    TYP(Data) fun(LoadLibrary)( TYP(Str) dll_nam );

    TYP(Func) 
    FUN(GetProcAddress)(
        TYP(Str) dll_nam
    ,   TYP(Str) fun_nam
    );

    TYP(Func)
    fun(GetProcAddress)(
        TYP(Data) dll_ptr
    ,   TYP(Str)  fun_nam
    );

//:FUNCTIONS: //:////////////////////////////////////////////://

    //:Initializer code for this file:
    //:EII: Existance_Is_Initialization
    void EII( SRC_NATIVE_CALLWRAP_getprocaddress )( void ){
        D("[EII:BEG]");

        fun( LoadLibrary )( "dll_k32" );

        //:GPA Test:
        ////////////////////////////////////////////////////////
        printf("[GPA_TEST...]\n\n\n");

        TYP(Func) VAR(CreateWindowExW)=
        FUN(GetProcAddress)("dll_u32","CreateWindowExW");
        
        if( NIL == VAR(CreateWindowExW) ){
            printf("[FILE:GetProcAddress:FAIL:GPA_CWEXW]");
            fflush(stdout);exit(4);
        };;
        ////////////////////////////////////////////////////////

        //:Make absolutely sure all public variables are
        //:non-null before exiting "EII" function:
        //:EIIEIIEIIEIIEIIEIIEIIEII//EIIEIIEIIEIIEIIEIIEIIEII://

        //:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:DATE[2020_04_29]:                                 ://
        //:[BUG][ERROR]: Something about my code makes it so ://
        //:              NOT frontloading all of my DLL files://
        //:              and lazily loading causes failure   ://
        //:              to look up function pointer.        ://
        //:                                                  ://
        //:[SOLUTION]:[WONTFIX]:                             ://
        //:              Better if we front load all DLL     ://
        //:              files anyhow. So lets not work on   ://
        //:              fixing functionality we shouldn't   ://
        //:              even be using in the first place.   ://
        //:__________________________________________________://

        fun( LoadLibrary )( "dll_k32" ); //:Kernel32.dll
        fun( LoadLibrary )( "dll_u32" ); //:User32.dll
        fun( LoadLibrary )( "dll_g32" ); //:Gdi32.dll
        fun( LoadLibrary )( "dll_vuk" ); //:vulkan-1.dll
        fun( LoadLibrary )( "dll_gra" ); //:opengl32.dll
        fun( LoadLibrary )( "dll_com" ); //:OpenCL**.dll

        if( NIL == INS(dll_k32) ){ H("[NOLOAD:dll_k32]");};
        if( NIL == INS(dll_u32) ){ H("[NOLOAD:dll_u32]");};
        if( NIL == INS(dll_g32) ){ H("[NOLOAD:dll_g32]");};
        if( NIL == INS(dll_vuk) ){ H("[NOLOAD:dll_vuk]");};
        if( NIL == INS(dll_gra) ){ H("[NOLOAD:dll_gra]");};
        if( NIL == INS(dll_com) ){ H("[NOLOAD:dll_com]");};

        //:SC[VK4UP_SIMPLE]//////////////////////////////////://
        //:make_sure_all_function_pointers_unique:ver__simple://
        #define I1    INS(dll_k32) //:///////////////////////://
        #define I2    INS(dll_u32) //:///////////////////////://
        #define I3    INS(dll_g32) //:///////////////////////://
        #define I4    INS(dll_vuk) //:///////////////////////://
        #define I5    INS(dll_gra) //:///////////////////////://
        #define I6    INS(dll_com) //:///////////////////////://
        #define    L_E_N ( 6 )     //:///////////////////////://
        void* arr[ L_E_N ]={ I1,I2,I3,I4,I5,I6 };
        for( int a = 0; a < L_E_N; a++ ){  //:- - - - - - - -://
        for( int b = 0; b < L_E_N; b++ ){  //:- - - - - - - -://
            if( a==b ){ continue; };
            if( arr[a]==arr[b] ){ H("[FAIL:NOT_A_SET]");};
        };;};;D("[PASS:YES_A_SET]");
        #undef  L_E_N //:////////////////////////////////////://
        #undef  I1    //: dll_k32) //~///////////////////////://
        #undef  I2    //: dll_u32) //~///////////////////////://
        #undef  I3    //: dll_g32) //~///////////////////////://
        #undef  I4    //: dll_vuk) //~///////////////////////://
        #undef  I5    //: dll_gra) //~///////////////////////://
        #undef  I6    //: dll_com) //~///////////////////////://
        //:SC[VK4UP_SIMPLE]//////////////////////////////////://

        //:EIIEIIEIIEIIEIIEIIEIIEII//EIIEIIEIIEIIEIIEIIEIIEII://

        D("[EII:END]");
    } //:END:EII[SRC_NATIVE_CALLWRAP_getprocaddress]/////////://

    TYP(Data) fun(LoadLibrary)(
        TYP(Str) ARG(dll_nam)
    ){

        printf("[dll_nam]:%s\n", ARG(dll_nam));

        TYP(Data) 
        VAR(Data)=NIL;
        if( VAR(Data) ){ /** NOOP **/ };

        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_k32"
        &&  ARG(dll_nam)[4] == 'k' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:kernel32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("kernel32.dll");
            INS(dll_k32)=( VAR(Data) ); //:CACHE_YOUR_DLL

        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_u32"
        &&  ARG(dll_nam)[4] == 'u' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:user32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("user32.dll");
            INS(dll_u32)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_g32"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:gdi32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("gdi32.dll");
            INS(dll_g32)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_vuk" (vulkan-1.dll)
        &&  ARG(dll_nam)[4] == 'v' 
        &&  ARG(dll_nam)[5] == 'u' 
        &&  ARG(dll_nam)[6] == 'k' 
        ){
                    printf("[RESOLVES_TO:vulkan-1.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("vulkan-1.dll");
            INS(dll_vuk)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l'  
        &&  ARG(dll_nam)[3] == '_'  //:"dll_gra"
        &&  ARG(dll_nam)[4] == 'g'  //:(opengl32.dll)
        &&  ARG(dll_nam)[5] == 'r' 
        &&  ARG(dll_nam)[6] == 'a' 
        ){          //[ C:\Windows\System32\opengl32.dll     ]//
                    printf("[RESOLVES_TO:opengl32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("opengl32.dll");
            INS(dll_gra)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l'  
        &&  ARG(dll_nam)[3] == '_'  //:"dll_com"
        &&  ARG(dll_nam)[4] == 'c'  //:(OpenCL64.dll)
        &&  ARG(dll_nam)[5] == 'o' 
        &&  ARG(dll_nam)[6] == 'm' 
        ){  //[ C:/Program Files                             ]//
            //[  /NVIDIA Corporation\OpenCL\OpenCL64.dll     ]//

                    printf("[RESOLVES_TO:<OPEN_CL*>.dll]\n");

            const char* TODO_ADD_ABILITY_TO_SET_SEARCH_PATH_FOR_DLL_FILES=(
              //:  "C:/Program Files/NVIDIA Corporation/OpenCL/OpenCL64.dll"
              //:  "C:/Program Files/NVIDIA Corporation/OpenCL/OpenCL.dll"
                "OpenCL.dll"

                //#TODO#////[TODO]////+TODO+////|TODO|//!!!!!!!!
                //# Grabbing the WRONG DLL will allow you to #//
                //# successfully load function pointers, but #//
                //# when you call: clGetPlatformIDs you will #//
                //# Get Error:                               #//
                //# 0xFFFFFC17:CL_PLATFORM_NOT_FOUND_KHR     #//

            );;

            VAR(Data)=DLLL_LoadLibraryA(
                TODO_ADD_ABILITY_TO_SET_SEARCH_PATH_FOR_DLL_FILES
            );;
            INS(dll_com)=( VAR(Data) ); //:CACHE_YOUR_DLL

        }else
        if( 1 ){
            //:If dll_name is not a shorthand name,
            //:load it as is.

            printf("[CHECK:DoesDLLNameLookCorrect?]%s\n"
            , ARG(dll_nam) );fflush( stdout );

            VAR(Data)=DLLL_LoadLibraryA( ARG(dll_nam) );
        };;

        if( NIL == VAR(Data) ){
            printf("[NullLoadedLibrary]");
            fflush(stdout); exit(4);
        };;

        return(   VAR(Data) );
    }

    TYP(Func) 
    FUN(GetProcAddress)(
        TYP(Str)  ARG(dll_nam)
    ,   TYP(Str)  ARG(fun_nam)
    ){
        TYP(Data)   VAR(dll_ptr) =NIL;

        //:Make sure dll is loaded:
        ////////////////////////////////////////////////////////
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_k32"
        &&  ARG(dll_nam)[4] == 'k' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_k32 ) ){

                INS(dll_k32)= 
                fun( LoadLibrary )( "kernel32.dll" );
            };;
            assert(      INS(dll_k32) );
            VAR(dll_ptr)=INS(dll_k32);
                
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_u32"
        &&  ARG(dll_nam)[4] == 'u' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_u32 ) ){

                INS(dll_u32)= 
                fun( LoadLibrary )( "user32.dll" );
            };;
            assert(      INS(dll_u32) );
            VAR(dll_ptr)=INS(dll_u32);

        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_g32"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_g32 ) ){

                INS(dll_g32)= 
                fun( LoadLibrary )( "gdi32.dll" );
            };;
            assert(      INS(dll_g32) );
            VAR(dll_ptr)=INS(dll_g32);
                
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_vuk"
        &&  ARG(dll_nam)[4] == 'v' 
        &&  ARG(dll_nam)[5] == 'u' 
        &&  ARG(dll_nam)[6] == 'k' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL ==   INS( dll_vuk ) ){
                         INS( dll_vuk )=fun( LoadLibrary    )
                     /** INS( dll_vuk ) **/( "vulkan-1.dll" );
            };; assert(  INS( dll_vuk ) );
            VAR(dll_ptr)=INS( dll_vuk );
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_gra"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == 'r' 
        &&  ARG(dll_nam)[6] == 'a' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL ==   INS( dll_gra ) ){
                         INS( dll_gra )=fun( LoadLibrary    )
                     /** INS( dll_gra ) **/( "opengl32.dll" );
            };; assert(  INS( dll_gra ) );
            VAR(dll_ptr)=INS( dll_gra );
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_com"
        &&  ARG(dll_nam)[4] == 'c' 
        &&  ARG(dll_nam)[5] == 'o' 
        &&  ARG(dll_nam)[6] == 'm' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL ==   INS( dll_com ) ){
                         INS( dll_com )=fun( LoadLibrary    )
                     /** INS( dll_com ) **/( "OpenCL64.dll" );
            };; assert(  INS( dll_com ) );
            VAR(dll_ptr)=INS( dll_com );
        }else
        if( 1 ){
            printf("[UnknownValueOf:dll_nam]:%s\n"
            , ARG(dll_nam));;

            fflush(stdout);
            exit(4);
        };;
        ////////////////////////////////////////////////////////

        //:Assert DLL pointer is not null:
        if( NIL==VAR(dll_ptr) ){
            printf("[DLL_PTR_NULL]\n");
            fflush(stdout);
            exit(4);
        };;

        //:Get function address from dll:
        ////////////////////////////////////////////////////////
        TYP(Func)
        VAR(GetProcAddress)=
        fun(GetProcAddress)(
            VAR(dll_ptr)
        ,   ARG(fun_nam)
        );;
        ////////////////////////////////////////////////////////

        return( VAR(GetProcAddress) );

    }

    //:A wrapper function so when called from other files
    //:you know where the function is comming from
    TYP(Func)
    FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
        TYP(Str)    ARG(dll_nam)
    ,   TYP(Str)    ARG(fun_nam)
    ){
        TYP(Func) ret_pfn=((void*)0);
        ret_pfn=(
            FUN(GetProcAddress)(
                    ARG(dll_nam)
            ,       ARG(fun_nam)
            )
        );;
        if( ((void*)0)==ret_pfn ){ H("[2020_04_28_0201AM]");};
        return( ret_pfn );
    }

    //:Prviate version of "GetProcAddress" wrapper:
    TYP(Func)
    fun(GetProcAddress)(
        TYP(Data) ARG(dll_ptr)
    ,   TYP(Str)  ARG(fun_nam)
    ){
        TYP(DFUN) 
        VAR(DFUN)=DLLL_GetProcAddress( 
            ARG(dll_ptr)
        ,   ARG(fun_nam) 
        );;
        
        //:Cast dll function to generic function pointer:
        TYP(Func) RET(DFUN)=(
            (TYP(Func)) VAR(DFUN)
        );;

        //:Output/return:
        return( RET(DFUN) );
    }



//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/NATIVE/CALLWRAP/GetProcAddress._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/NATIVE/ping._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1206PM_PI , n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1206PM_PI , n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1206PM_PI , n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1206PM_PI , n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1206PM_PI , n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1206PM_PI , n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1206PM_PI , n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1206PM_PI , n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1206PM_PI , n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1206PM_PI , n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1206PM_PI , n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1206PM_PI , n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1206PM_PI , n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1206PM_PI , n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1206PM_PI , n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1206PM_PI , n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

    #define SRC_NATIVE_PING ( 1 )

    int FUN( SRC_NATIVE_ping )( void ){

        printf("[SRC_NATIVE_ping]\n");

        return( 0 );
    }


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/NATIVE/ping._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/NATIVE/WINDOW/creation._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1127AM_SNWC, n) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1127AM_SNWC, n) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1127AM_SNWC, n) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1127AM_SNWC, n) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1127AM_SNWC, n) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1127AM_SNWC, n) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1127AM_SNWC, n) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1127AM_SNWC, n) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1127AM_SNWC, n) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1127AM_SNWC, n) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1127AM_SNWC, n) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1127AM_SNWC, n) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1127AM_SNWC, n) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1127AM_SNWC, n) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1127AM_SNWC, n) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1127AM_SNWC, n) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:path to this file:
    #define  SRC_NATIVE_WINDOW_CREATION ( 1 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//[THINGS_ID_LIKE_YOU_TO_SEE_FIRST:11111111111111111111111111]//

    
    typedef void* 
        TYP(con_win);
        TYP(con_win) 
    FUN(SRC_NATIVE_WINDOW_CREATION_GetWinDC)( void );



//[11111111111111111111111111:THINGS_ID_LIKE_YOU_TO_SEE_FIRST]//
//:STRUCTS: SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS://

    //[  SEE[ VG03.ALL's F09_STRUCT_PIXELFORMATDESCRIPTOR ]  ]//
    //[  docs.microsoft.com/en-us/windows/win32/api/wingdi   ]//
    //[  /ns-wingdi-pixelformatdescriptor                    ]//
    #define B_04 unsigned long  /**DWORD **/  //:////////////://
    #define B_02 unsigned short /** WORD **/  //:////////////://
    #define B_01 unsigned char  /** BYTE **/  //:////////////://
    struct TYP(PIXELFORMATDESCRIPTOR) {  
    /**  01  **/    B_02  nSize;             
    /**  02  **/    B_02  nVersion;          
    /**  --  **/                          
    /**  03  **/    B_04  dwFlags;            
    /**  --  **/                          
    /**  04  **/    B_01  iPixelType;        
    /**  05  **/    B_01  cColorBits;        
    /**  06  **/    B_01  cRedBits;          
    /**  07  **/    B_01  cRedShift;         
    /**  08  **/    B_01  cGreenBits;        
    /**  09  **/    B_01  cGreenShift;       
    /**  10  **/    B_01  cBlueBits;         
    /**  11  **/    B_01  cBlueShift;        
    /**  12  **/    B_01  cAlphaBits;        
    /**  13  **/    B_01  cAlphaShift;       
    /**  14  **/    B_01  cAccumBits;        
    /**  15  **/    B_01  cAccumRedBits;     
    /**  16  **/    B_01  cAccumGreenBits;   
    /**  17  **/    B_01  cAccumBlueBits;    
    /**  18  **/    B_01  cAccumAlphaBits;   
    /**  19  **/    B_01  cDepthBits;        
    /**  20  **/    B_01  cStencilBits;      
    /**  21  **/    B_01  cAuxBuffers;       
    /**  22  **/    B_01  iLayerType;        
    /**  23  **/    B_01  bReserved;         
    /**  --  **/                          
    /**  24  **/    B_04  dwLayerMask;        
    /**  25  **/    B_04  dwVisibleMask;      
    /**  26  **/    B_04  dwDamageMask;       
    /**  --  **/
    };//[struct]//
    #undef  B_04 ////////////// /**DWORD **/  //:////////////://
    #undef  B_02 ////////////// /** WORD **/  //:////////////://
    #undef  B_01 ////////////// /** BYTE **/  //:////////////://

    //:winuser.h
    struct TYP(WIN32POINT){

        long x;         //:TAKEN_FROM:VGK03.ALL:
        long y;         //:F09_STRUCT_POINT && F09_STRUCT_MSG

    }ins(win32point)={
        0
    };

    //:winuser.h
    struct TYP(WINMSG){  //:WINDOW's "MSG" type:

        void*                    hwnd    ;  //: HWND    ://
        unsigned   int           message ;  //: UINT    ://
        unsigned __int64         wParam  ;  //: WPARAM  ://

                 __int64         lParam  ;  //: LPARAM  ://
        unsigned    long         time    ;  //: DWORD   ://

        struct  TYP(WIN32POINT)  pt      ;  //: POINT   ://
        unsigned    long         lPrivate;  //: DWORD   ://

    }ins(winmsg)={
        0
    };

//:SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS :STRUCTS://
//:TYPEDEFS: TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://

    //:Generic function pointer type:
    ////////////////////////////////////////////////////////////

    //:Did not expect something like TYP(FUN) to expanded
    //:correctly. But maybe we should avoid that?

    typedef 
        void (* TYP(FUN) )(void);

    typedef
        int TYP(TYP);
    ////////////////////////////////////////////////////////////

    //:Generic function pointer type:
    typedef void (* TYP(Func) )(void); //:Function pointer.
    typedef void*   TYP(Data)        ; //:Data     pointer.

    // ------------------------------------------------------ //
    typedef 
        __int64
        (__stdcall *TYP(WNDPROC) )(
            void*             //: HWND
        ,   unsigned   int    //: UINT
        ,   unsigned __int64  //: WPARAM
        ,            __int64  //: LPARAM
        );
    // ------------------------------------------------------ //
    struct TYP(WNDCLASSEXW) {
                    unsigned int   cbSize       ;
                    unsigned int   style        ;
                    TYP(WNDPROC)   lpfnWndProc  ;
                             int   cbClsExtra   ;
                             int   cbWndExtra   ;
                            void*  hInstance    ;
                            void*  hIcon        ;
                            void*  hCursor      ;
                            void*  hbrBackground;
            const unsigned short*  lpszMenuName ;
            const unsigned short*  lpszClassName;
                            void*  hIconSm      ;
    };
    // ------------------------------------------------------ //

//:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT: TYPEDEFS://
//:FORWARD_DECLARATIONS::FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF://
    __stdcall
    __int64 //:LRESULT
    fun(WinMsgHanWndPoc)(
    /**/           void*    han_win   //:HWND
    ,   unsigned   int      Msg       //:...?...
    ,   unsigned __int64    wParam    //:WPARAM
    ,            __int64    lParam    //:LPARAM
    );

    char*
    fun(MakeIntResourceA)( int i );

    //:This function is registered with the main game loop.
    //:It does NOT need to be public, since this file
    //:does the registering, not the game loop file.
    void fun( WindowTick )( void );

//:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF::FORWARD_DECLARATIONS://
//:INSTANCES: IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII://

    int ins(frames_without_window)=(0-1); //:negative==unset

    struct TYP(WNDCLASSEXW) INS(WNDCLASSEXW)={0};
    void*  INS(han_exe)=(NIL); //:AKA:handle_to_exe
    void*  INS(dek_win)=(NIL); //:AKA:the_desktop_window
    void*  ins(han_win)=(NIL); //:AKA:handle_to_YOUR_window
    void*  ins(con_win)=(NIL); //:AKA:window_device_context

    #define NOT_UNICODE_I_SWEAR const unsigned short //://///://
    //://////////////////////////////////////////////////////://

    NOT_UNICODE_I_SWEAR*      //:AKA:unique_window_name
    INS(win_nam)=( L"2020_4_22:UNIQUE_WINDOW_NAME"     );

    NOT_UNICODE_I_SWEAR*      //:AKA:titlebar_text
    INS(tib_tex)=( L"[FLIP_THE_FUCKING_TABLE!]((╯°□°）╯︵ ┻━┻))" );

    //://////////////////////////////////////////////////////://
    #undef  NOT_UNICODE_I_SWEAR //://////////////////////////://
    
    //:FUNCTION_POINTERS:  FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://
            
    TYP(FUN)    INS(CreateWindowExW  )=( NIL );
    TYP(FUN)    INS(GetDesktopWindow )=( NIL );
    TYP(FUN)    INS(RegisterClassExW )=( NIL );
    TYP(FUN)    INS(LoadIconA        )=( NIL );
    TYP(FUN)    INS(LoadCursorA      )=( NIL );
    TYP(FUN)    INS(GetModuleHandleW )=( NIL );
    TYP(FUN)    INS(DefWindowProcW   )=( NIL );
    TYP(FUN)    INS(DestroyWindow    )=( NIL );
    TYP(FUN)    INS(PostQuitMessage  )=( NIL );
    TYP(FUN)    INS(GetWindowDC      )=( NIL );
    TYP(FUN)    INS(ChoosePixelFormat)=( NIL );
    TYP(FUN)    INS(SetPixelFormat   )=( NIL );
    TYP(FUN)    INS(ShowWindow       )=( NIL );
    TYP(FUN)    INS(UpdateWindow     )=( NIL );
    TYP(FUN)    INS(SetFocus         )=( NIL );
    TYP(FUN)    INS(PeekMessageW     )=( NIL );
    TYP(FUN)    INS(TranslateMessage )=( NIL );
    TYP(FUN)    INS(DispatchMessageW )=( NIL );

    //:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP  :FUNCTION_POINTERS://

    struct TYP(PIXELFORMATDESCRIPTOR) INS(fod_pix)={0};
    int    ins(fmt_num)=( 0 ); //:pixel_format_number

//:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII: INSTANCES://

//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/NATIVE/WINDOW/creation._:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/NATIVE/WINDOW/creation._:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG:// 

int FUN( SRC_NATIVE_WINDOW_creation )( void ){
printf("[SRC_NATIVE_WINDOW_creation]\n");

    //:STEPS: 
    //: 1: EII: Existance_Is_Initialization
    //:         Front load resources first and make sure
    //:         they all are valid.
    //:
    //: 2: Register Your Window "Class".
    //:
    //: 3: .....todo...

    TYP(TYP)     int_a = 5;
    VG04_TYP_TYP int_b = 6;
    printf("[int_a]:%d\n", int_a);
    printf("[int_b]:%d\n", int_b);

    //:EII:Existance_Is_Initialization:(BELOW):--------------://
    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://

    //: INS( variable_names ) : Public, Init immediately here.
    //: ins( variable_names ) : Private,Init before func exits.
    //: MORE_INFO[ SC[ EII_INS_INS_RULES ] ]

    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://

    ////////////////////////////////////////////////////////////
    INS(CreateWindowExW)=
    FUN(GetProcAddress)("dll_u32","CreateWindowExW");

    INS(GetDesktopWindow)=
    FUN(GetProcAddress)("dll_u32","GetDesktopWindow");

    INS(RegisterClassExW)=
    FUN(GetProcAddress)("dll_u32","RegisterClassExW");

    INS(LoadIconA)=
    FUN(GetProcAddress)("dll_u32","LoadIconA");

    INS(LoadCursorA)=
    FUN(GetProcAddress)("dll_u32","LoadCursorA");

    INS(GetModuleHandleW)= //: "kernel32.dll"
    FUN(GetProcAddress)("dll_k32","GetModuleHandleW");

    INS(DefWindowProcW)=
    FUN(GetProcAddress)("dll_u32","DefWindowProcW");

    INS(DestroyWindow)=
    FUN(GetProcAddress)("dll_u32","DestroyWindow");

    INS(PostQuitMessage)=
    FUN(GetProcAddress)("dll_u32","PostQuitMessage");

    INS(GetWindowDC)=
    FUN(GetProcAddress)("dll_u32","GetWindowDC");

    INS(ChoosePixelFormat)= //: "gdi32.dll"
    FUN(GetProcAddress)("dll_g32","ChoosePixelFormat");

    INS(SetPixelFormat)= //: "gdi32.dll"
    FUN(GetProcAddress)("dll_g32","SetPixelFormat");

    INS(ShowWindow)=
    FUN(GetProcAddress)("dll_u32","ShowWindow");

    INS(UpdateWindow)=
    FUN(GetProcAddress)("dll_u32","UpdateWindow");

    INS(SetFocus)=
    FUN(GetProcAddress)("dll_u32","SetFocus");

    INS(PeekMessageW)=
    FUN(GetProcAddress)("dll_u32","PeekMessageW");

    INS(TranslateMessage)=
    FUN(GetProcAddress)("dll_u32","TranslateMessage");

    INS(DispatchMessageW)=
    FUN(GetProcAddress)("dll_u32","DispatchMessageW");



    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://
    if( ((void*)0) != INS(CreateWindowExW) ){
        D("[SUCCESS:CreateWindowExW]");
    }else{
        H("[FAILURE:CreateWindowExW]");
    };;
    if( ((void*)0) != INS(GetDesktopWindow) ){
        D("[SUCCESS:GetDesktopWindow]");
    }else{
        H("[FAILURE:GetDesktopWindow]");
    };;
    if( ((void*)0) != INS(RegisterClassExW) ){
        D("[SUCCESS:RegisterClassExW]");
    }else{
        H("[FAILURE:RegisterClassExW]");
    };;
    if( ((void*)0) != INS(LoadIconA) ){
        D("[SUCCESS:LoadIconA]");
    }else{
        H("[FAILURE:LoadIconA]");
    };;
    if( ((void*)0) != INS(LoadCursorA) ){
        D("[SUCCESS:LoadCursorA]");
    }else{
        H("[FAILURE:LoadCursorA]");
    };;
    if( ((void*)0) != INS(GetModuleHandleW) ){
        D("[SUCCESS:GetModuleHandleW]");
    }else{
        H("[FAILURE:GetModuleHandleW]");
    };;
    if( ((void*)0) != INS(DefWindowProcW) ){
        D("[SUCCESS:DefWindowProcW]");
    }else{
        H("[FAILURE:DefWindowProcW]");
    };;
    if( ((void*)0) != INS(DestroyWindow) ){
        D("[SUCCESS:DestroyWindow]");
    }else{
        H("[FAILURE:DestroyWindow]");
    };;
    if( ((void*)0) != INS(PostQuitMessage) ){
        D("[SUCCESS:PostQuitMessage]");
    }else{
        H("[FAILURE:PostQuitMessage]");
    };;
    if( ((void*)0) != INS(GetWindowDC) ){
        D("[SUCCESS:GetWindowDC]");
    }else{
        H("[FAILURE:GetWindowDC]");
    };;
    if( ((void*)0) != INS(ChoosePixelFormat) ){
        D("[SUCCESS:ChoosePixelFormat]");
    }else{
        H("[FAILURE:ChoosePixelFormat]");
    };;
    if( ((void*)0) != INS(SetPixelFormat) ){
        D("[SUCCESS:SetPixelFormat]");
    }else{
        H("[FAILURE:SetPixelFormat]");
    };;
    if( ((void*)0) != INS(ShowWindow) ){
        D("[SUCCESS:ShowWindow]");
    }else{
        H("[FAILURE:ShowWindow]");
    };;
    if( ((void*)0) != INS(UpdateWindow) ){
        D("[SUCCESS:UpdateWindow]");
    }else{
        H("[FAILURE:UpdateWindow]");
    };;
    if( ((void*)0) != INS(SetFocus) ){
        D("[SUCCESS:SetFocus]");
    }else{
        H("[FAILURE:SetFocus]");
    };;
    if( ((void*)0) != INS(PeekMessageW) ){
        D("[SUCCESS:PeekMessageW]");
    }else{
        H("[FAILURE:PeekMessageW]");
    };;
    if( ((void*)0) != INS(TranslateMessage) ){
        D("[SUCCESS:TranslateMessage]");
    }else{
        H("[FAILURE:TranslateMessage]");
    };;
    if( ((void*)0) != INS(DispatchMessageW) ){
        D("[SUCCESS:DispatchMessageW]");
    }else{
        H("[FAILURE:DispatchMessageW]");
    };;

    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://
    //[SC[MSA_FPU_CXX](BELOW)////////////////////////////////]//
    //:make_sure_all_function_pointers_unique:      //|  --  |//
    #define       L_E_N (         18+1)  //://///////////////://
    TYP(FUN) arr[ L_E_N ]={     0x00                //|  --  |//
    ,INS(CreateWindowExW   ) /**  01  **/           //|  01  |//
    ,INS(GetDesktopWindow  ) /**  02  **/           //|  02  |//
    ,INS(RegisterClassExW  ) /**  03  **/           //|  03  |//
    ,INS(LoadIconA         ) /**  04  **/           //|  04  |//
    ,INS(LoadCursorA       ) /**  05  **/           //|  05  |//
    ,INS(GetModuleHandleW  ) /**  06  **/           //|  06  |//
    ,INS(DefWindowProcW    ) /**  07  **/           //|  07  |//
    ,INS(DestroyWindow     ) /**  08  **/           //|  08  |//
    ,INS(PostQuitMessage   ) /**  09  **/           //|  09  |//
    ,INS(GetWindowDC       ) /**  10  **/           //|  10  |//
    ,INS(ChoosePixelFormat ) /**  11  **/           //|  11  |//
    ,INS(SetPixelFormat    ) /**  12  **/           //|  12  |//
    ,INS(ShowWindow        ) /**  13  **/           //|  13  |//
    ,INS(UpdateWindow      ) /**  14  **/           //|  14  |//
    ,INS(SetFocus          ) /**  15  **/           //|  15  |//
    ,INS(PeekMessageW      ) /**  16  **/           //|  16  |//
    ,INS(TranslateMessage  ) /**  17  **/           //|  17  |//
    ,INS(DispatchMessageW  ) /**  18  **/           //|  18  |//
    #define  L_E_N_DOUBLECHECK   (18+1) //:///////////:  --  ://
//: ,INS(function_pointer_name_here)                //|  19  |//
//: ,INS(function_pointer_name_here)                //|  20  |//
//: ,INS(function_pointer_name_here)                //|  31  |//
//: ,INS(function_pointer_name_here)                //|  32  |//
//: ,INS(function_pointer_name_here)                //|  33  |//
//: ,INS(function_pointer_name_here)                //|  34  |//
//: ,INS(function_pointer_name_here)                //|  35  |//
//: ,INS(function_pointer_name_here)                //|  36  |//
//: ,INS(function_pointer_name_here)                //|  37  |//
//: ,INS(function_pointer_name_here)                //|  38  |//
//: ,INS(function_pointer_name_here)                //|  39  |//
//: ,INS(function_pointer_name_here)                //|  40  |//
//: ,INS(function_pointer_name_here)                //|  41  |//
//: ,INS(function_pointer_name_here)                //|  42  |//
//: ,INS(function_pointer_name_here)                //|  43  |//
//: ,INS(function_pointer_name_here)                //|  44  |//
//: ,INS(function_pointer_name_here)                //|  45  |//
//: ,INS(function_pointer_name_here)                //|  46  |//
//: ,INS(function_pointer_name_here)                //|  47  |//
//: ,INS(function_pointer_name_here)                //|  48  |//
//: ,INS(function_pointer_name_here)                //|  49  |//
//: ,INS(function_pointer_name_here)                //|  50  |//
    };;//:////////////////////////////////////////////:  --  ://
    if( L_E_N != L_E_N_DOUBLECHECK ){
        H("[FAIL:MACRO_SETUP_FAIL:L_E_N_DOUBLECHECK]");
    };;
    for( int a = 0; a < L_E_N; a++ ){  //:- - - - - - - - - -://
    for( int b = 0; b < L_E_N; b++ ){  //:- - - - - - - - - -://
        if( a==b ){ continue; };
        if( arr[a]==arr[b] ){ H("[FAIL:NOTASET:2020_04_25]");};
    };;};;                    D("[PASS:YESASET:2020_04_25]");
    #undef  L_E_N //:////////////////////////////////////////://
    //[SC[MSA_FPU_CXX](ABOVE)////////////////////////////////]//
    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://

    INS(han_exe)=((TYP(F_01))INS(GetModuleHandleW))( NIL );
    INS(dek_win)=((TYP(F_00))INS(GetDesktopWindow))(     );

    if( NIL== INS(han_exe) ){ H("[NIL:han_exe]"); };
    if( NIL== INS(dek_win) ){ H("[NIL:dek_win]"); };
    
    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://

    //: LATER_IN_FUNCTION: 
    //: INS(fod_pix)==temp_pixel_format_descriptor_for_easy_init
    struct TYP(PIXELFORMATDESCRIPTOR)               
    temp_pixel_format_descriptor_for_easy_init={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct TYP(PIXELFORMATDESCRIPTOR) ),       //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;    
    //:eieieieieieieieieieieieieieieieieieieieieieieieieieiei://
    #define PIX INS(fod_pix) ///////////////////////////////////
    //: COPY_OVER + SMOKE_TEST : BELOW --------------------- ://

        //:Copy over temp to file scope variable:
        //:fod_pix==temp_pixel_format_descriptor_for_easy_init
                PIX=temp_pixel_format_descriptor_for_easy_init;

        //:Smoke_Test:
        ////////////////////////////////////////////////////////
        if(      32!=PIX.cColorBits   ){
            H( "[32!=PIX.cColorBits]" );
        };;
        if( 24 != PIX.cDepthBits  ){
            printf( 
                  "[PIX.cDepthBits]:%d\n"
            ,       PIX.cDepthBits  
            );;
            H("[24!=PIX.cDepthBits]");
        };;
        if(      8!=PIX.cStencilBits ){
           H( "[08!=PIX.cStencilBits]");
        };;     
    
        #define COLT_40 40 /////////////////////////////////////
 
        if( COLT_40 != 
            sizeof( struct TYP(PIXELFORMATDESCRIPTOR) )
        ){
            H("[COLT_40:1]");
        }else
        if( 
            COLT_40 != 
            sizeof( temp_pixel_format_descriptor_for_easy_init)
        ){
            H("[COLT_40:2]");
        }else
        if( COLT_40 != sizeof( PIX ) ){
            H("[COLT_40:3]");
        }else
        if( COLT_40 != sizeof( INS( fod_pix ) ) ){
            H("[COLT_40:4]");
        }else
        if( COLT_40 != INS( fod_pix ).nSize ){
            H("[COLT_40:5]");
        }else{
            D("[PIXELFORMATDESCRIPTOR:It_Checks_Out]");
        };;

        #undef  COLT_40  ///////////////////////////////////////

        ////////////////////////////////////////////////////////
             
    //: COPY_OVER + SMOKE_TEST : ABOVE --------------------- ://
    #undef  PIX ////////////////////////////////////////////////
    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://
    //:EII:Existance_Is_Initialization:(ABOVE):______________://


    //:R:Register:(BELOW):-----------------------------------://
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    //:Before creating window, must register window class:
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    
    
    //:SmokeTest:
    size_t struct_size =( sizeof( struct TYP(WNDCLASSEXW) ) );
    if( struct_size != 80 ){ H("[BadStructSize]"); };
    
    
    ////////////////////////////////////////////////////////////
    
    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////
    
    INS(WNDCLASSEXW).cbSize=sizeof( struct TYP(WNDCLASSEXW) );
    INS(WNDCLASSEXW).style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                    //| ...ClassWin32         |//
    0);;
    INS(WNDCLASSEXW).lpfnWndProc=fun(WinMsgHanWndPoc);
    INS(WNDCLASSEXW).cbClsExtra=0;
    INS(WNDCLASSEXW).cbWndExtra=0;
    INS(WNDCLASSEXW).hInstance =( INS( han_exe ) );
    
    char* idi_application = fun(MakeIntResourceA)( 32512 );
    char* idc_arrow       = fun(MakeIntResourceA)( 32512 );
    
    #define F2 TYP(F_02) ///////////////////////////////////////
    
        INS(WNDCLASSEXW).hIcon  =((F2)INS(LoadIconA))(  
            NULL
        ,   idi_application
        );;
        INS(WNDCLASSEXW).hCursor=((F2)INS(LoadCursorA))(  
            NULL
        ,   idc_arrow
        );;
    
    #undef  F2 /////////////////////////////////////////////////
    #define XX /////////////////////////////////////////////////
    
    //:SEE[ HBR_BACKGROUND_CAN_BE_NULL_FOR_VULKAN_WINDOW ]
    //:AKA[ HBC_BNF_VW ]
    INS(WNDCLASSEXW).hbrBackground=NULL;
    INS(WNDCLASSEXW).lpszMenuName=NULL;
    INS(WNDCLASSEXW).lpszClassName=INS(win_nam);
    
    #undef  XX /////////////////////////////////////////////////
    #define F2 TYP(F_02) ///////////////////////////////////////
    
    INS(WNDCLASSEXW).hIconSm=(
        ((F2)INS(LoadIconA))(
            NULL
        ,   idi_application
        )
    );;
    
    #undef  F2 /////////////////////////////////////////////////
    #define F3 TYP(F_03) ///////////////////////////////////////
    
    //:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
    //|If you forget to register your window class,the       |//
    //|observable effect is the window never opening,and the |//
    //|wait loop exiting immediately.                        |//
    //|
    //|RegisterClassExW:(MSDN_DOCS):
    //|Registers a window class for subsequent use in calls  |//
    //|to the CreateWindow or CreateWindowEx function.       |//
    //:______________________________________________________://
    int VAR( bool )=(
        (int)(unsigned long long)
        (  (TYP(F_01))  INS(RegisterClassExW)  )(  
            &( INS(WNDCLASSEXW) )
        )
    );;
    if( VAR( bool ) <= 0 ){
        H("[REGWINCLASS:FAIL]");
    }else{
        D("[REGWINCLASS:PASS]");
    };;
    
    #undef  F3 /////////////////////////////////////////////////
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    //:R:Register:(ABOVE):-----------------------------------://
    //:CREATE_WINDOW:::CWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCW://
    #define NIHILISM NIL //://///////////|///////////////////://
    #define V void       //://///////////|///////////////////://
    #define U64 unsigned long long int //:///////////////////://
    ins(han_win)=
    ((TYP(F_12))INS(CreateWindowExW))//:---------------------://
    (
    ////
        /**/(V*)0x00000008L  /** ws_ex_topmost **/
        ,   (V*)INS(win_nam) /** Window___Name **/
        ,   (V*)INS(tib_tex) /** Titlebar_Text **/
    ////
        , 
        (V*)(U64)
        (0
        |  0x00CF0000 /** ws_overlappedwindow **/ 
        |      0x0020 /** CS_OWNDC (2B/32b)  **/
        |
        0)
    ////    X_Y_WID_HIG
        ,   (V*)(U64) 22    //: _X_  -----------://
        ,   (V*)(U64) 22    //: _Y_  -----------://
        ,   (V*)(U64) 1024  //: WID  -----------://
        ,   (V*)(U64) 512   //: HIG  -----------://
    ////
        ,   INS(dek_win)    //:-- hWndParent ---://
        ,   ( NIHILISM )    //:-- hMenu      ---://
        ,   INS(han_exe)    //:-- hInstance  ---://        
        ,   ( NIHILISM )    //:-- lpParam    ---://  
    ////
    ); //:---------------------------------------------------://
    
    if(NIL==ins(han_win)){
        H("[FAIL:VKG04_WindowCreateFail]");
        return 0;
    }else{
        D("[PASS:VKG04_CreatedWindow:TODO:SetupWindowLoop]");
    };;
    #undef  U64      //://///////////////////////////////////://
    #undef  V        //://///////////////////////////////////://
    #undef  NIHILISM //://///////////////////////////////////://
    //:CWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCW:::CREATE_WINDOW://
    //:DEVICE_CONTEXT: DCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC://

    ins(con_win)=((TYP(F_01))INS(GetWindowDC))( ins(han_win) );
    if( NIL==ins(con_win) ){
        H("[FailedToGet:window_device_context/con_win]");
    }else{
        D("[PASS:con_win(window_device_context)]");
    };;

    //:DCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC :DEVICE_CONTEXT://

    //:PFN:Pixel_Format_Number: GET: ins(fmt_num):
    //::PFN:PFN:PFN:PFN:PFN:PFN::::::PFN:PFN:PFN:PFN:PFN:PFN:://
    ins(fmt_num)=( //:pixel_format_number
        //:CAST_RESULTS:
        (int)(unsigned long long)

        //:FUNCTION_CALL:
        (  (TYP(F_02))INS(ChoosePixelFormat /**GDI32.DLL**/ ))

        //:FUNCTION_PARAMETERS:
        (  
             ins(con_win)    /**window_device_context**/
        , &( INS(fod_pix) )  /**PIXELFORMATDESCRIPTOR**/
        )
    );;

    if( 0 == ins(fmt_num) ){
        H("[FAIL:DEFINITELY_FAILED:ChoosePixelFormat]");
    }else
    if( 0  > ins(fmt_num) ){ //:NEGATIVE
        //:Look more into documentation if this happens.
        //:but pretty sure it should be a positive number.
        //:Also watch out for errors due to sign extension.
        H("[fail?PROBABLY_FAILED:::ChoosePixelFormat]");
    }else
    if( 0  < ins(fmt_num) ){ //:POSITIVE
        D("[PASS:ALL_IS_GOOD_IN_THE_PIXELFORMAT_NEIGHBORHOOD]");
    }else{ //:WHAT_THE_FUCK
        H("[FAIL:WHAT_THE_FUCK:2020_04_25:0148PM]");
    };;
    //::PFN:PFN:PFN:PFN:PFN:PFN::::::PFN:PFN:PFN:PFN:PFN:PFN:://

    //:VC:Vulkan_Compatible:
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://
    //:VKG03.ALL:f09_MakeWindowCompatibleWith_GL
    //:Make the window compatible with openGL & Vulkan:
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((TYP(F_03))INS(SetPixelFormat))(
        /**/
        /**/        ins(con_win)  /** window_device_context **/
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        ins(fmt_num)  /** pixel_format_number   **/
        /**/    ,
        /**/     &( INS(fod_pix) )/** PIXELFORMATDESCRIPTOR **/
        )
    );;
    if( setting_pixel_format_worked ){
        D("[PASS:SET_PIXEL_FORMAT]");
    }else{
        H("[FAIL:SET_PIXEL_FORMAT]");
    };;
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://

    //:SEE:VG03.ALL:f09_WindowLoop

    //:LG:Loosey_Goosey:
    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    //: Because we are playing loosy-goosy without including
    //: any header files, we better check runtime size of
    //: the structs we re-created against observed sizes
    //: when compiling small project using <windows.h> header.
    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    if( 8 == sizeof( ins(win32point) ) ){
        D("[PASS:SIZECHECK:win32point]");
    }else{
        H("[FAIL:SIZECHECK:win32point]");
    };;
    if(48 == sizeof( ins(winmsg)     ) ){
        D("[PASS:SIZECHECK:winmsg]");
    }else{
        H("[FAIL:SIZECHECK:winmsg]");
    };;

    if( 8 == sizeof( struct TYP(WIN32POINT) ) ){
        D("[PASS:SIZECHECK:WIN32POINT]");
    }else{
        H("[FAIL:SIZECHECK:WIN32POINT]");
    };;
    if(48 == sizeof( struct TYP(WINMSG)     ) ){
        D("[PASS:SIZECHECK:WINMSG]");
    }else{
        H("[FAIL:SIZECHECK:WINMSG]");
    };;


    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    //:TP:TickPrep: Prepwork before doing a WindowTick(...):
    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://
    //:                                                      ://
    //:ALL_FUNCTIONS_FROM: "User32.dll"                      ://
    //:                                                      ://
    //: ShowWindow   :Set Visibility State Of Window:        ://
    //: UpdateWindow :Force WM_PAINT to top of message queue.://
    //: SetFocus     :Set keyboard focus to window:          ://
    //:                                                      ://
    //: han_win:-----: handle_to_a_window_instance           ://
    //:                ( handle_to_window )                  ://
    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://
    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;

    ( (TYP(F_02)) INS(ShowWindow)   )(  ins(han_win), show  );
    ( (TYP(F_01)) INS(UpdateWindow) )(  ins(han_win)        ); 
    ( (TYP(F_01)) INS(SetFocus)     )(  ins(han_win)        );

    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://

    //:We are not going to enter a window loop here.
    //:That would wreck the chain structure of our project
    //:setup. Instead we will register WindowTick function
    //:with the main game loop, and the game loop will 
    //:call it for us.
    INS(looptable).MEM(nat_win)=&( fun(WindowTick) );


    return( 0 );
}


int fun(TakeOrLookMessage)( //://////////////////////////////://

    //:ins(winmsg) / LPMSG
    struct TYP(WINMSG)* dont_prefix_message_with_and_symbol 
    ,
    int                 take_the_message
){ //:///////////////////////////////////////////////////////://

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        H("[FAIL:EXPECTED:Pos|Or|Zero]");
    };;

    int ret =(
        //:CAST_RETURN_DATA:
        (int)(unsigned long long)

        //:FUNCTION_TO_CALL:
        (  (TYP(F_05)) INS(PeekMessageW)  )

        //:ARGUMENTS_TO_FUNCTION:
        (
        /** -- **/    (void*)
        /** 01 **/    dont_prefix_message_with_and_symbol
        /** -- **/    ,
        /** 02 **/    NULL //:hWnd:NullToProcessThreadMessages
        /** -- **/    ,
        /** 03 **/    0    //:wMsgFilterMin
        /** -- **/    ,
        /** 04 **/    0    //:wMsgFilterMax
        /** -- **/    ,
        /** -- **/    (void*)(unsigned long long)
        /** 05 **/    look_or_take  //:wRemoveMsg
        )
    );;
    return( ret );

} //://////////////////////////////////////:TakeOrLookMessage://
int /** BOOL **/ fun(LookMessage)( //:///////////////////////://
    struct TYP(WINMSG)* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=fun(TakeOrLookMessage)(msg,look);
    return( ret );
} //:////////////////////////////////////////////:LookMessage://
int /** BOOL **/ fun(TakeMessage)( //:///////////////////////://
    struct TYP(WINMSG)* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=fun(TakeOrLookMessage)(msg,take);
    return( ret );
} //:////////////////////////////////////////////:TakeMessage://

//:I thought this needed to be public. But then I realized
//:it is this file's responsibility to register itself
//:with the main game loop.
void fun( WindowTick )( void )
{
    //:One tick of our window loop goes here.

    //:######################################################://
    #define M ins(winmsg) //:################################://

    fun(LookMessage)( &M );
    if( /** WHILE_CONVERTED_TO_AN_IF **/ //://///////////////://

        M.message != 0x12 /** UINT:wm_quit **/

    ){  //://////////////////////////////////////////////////://

        if( fun(TakeMessage)(    &M )){

            ( (TYP(F_01))INS(TranslateMessage) )( &M );

            ( (TYP(F_01))INS(DispatchMessageW) )( &M );

        };;

        ins(frames_without_window) = 0;

    }else{ //:///////////////////////////////////////////////://

        //:Notify console if the window is closed and the
        //:program is still executing.
        #define MSG_MAX_INDEX ( 5 ) //://////////////////////://
            ins(frames_without_window)++;
            char* no_more_window_message=(
                "[SRC/NATIVE/WINDOW/creation._:NOMOREWINDOW]\n"
            );;
            if( ins(frames_without_window) < MSG_MAX_INDEX ){
                //:TODO: Variables to let rendering system know
                //:      that the window is closed. For now 
                //:      a simple printf will do.
                printf(no_more_window_message);
                fflush(stdout);
            }else
            if( ins(frames_without_window) == MSG_MAX_INDEX ){
                printf("[StillNoWindowButBeingQuietNow...]\n");
                printf("[USE[CTRL+C]HERE_TO_EXIT_PROGRAM!]\n");
                fflush(stdout);
            };;
        #undef MSG_MAX_INDEX //://///////////////////////////://

    };; //://////////////////////////////////////////////////://

    #undef M //:#############################################://
    //:######################################################://

}
 






//:MakeIntResourceA /////////////////////////////////////////://
char*
fun(MakeIntResourceA)( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
} //:////////////////////////////////////// MakeIntResourceA ://
//:WinMsgHanWndPoc //////////////////////////////////////////://
__stdcall
__int64 //:LRESULT
fun(WinMsgHanWndPoc)(
/**/           void*    han_win   //:HWND
,   unsigned   int      Msg       //:...?...
,   unsigned __int64    wParam    //:WPARAM
,            __int64    lParam    //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[SRC/NATIVE/WINDOW/creation._:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 (( TYP(F_01) )(INS(DestroyWindow)))(han_win);

            if(0==ok){ H("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            (( TYP(F_01) )(INS(DestroyWindow)))(han_win);

        if(0==ok){ H("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((TYP(F_01))INS(PostQuitMessage))(0);

    case 0x000F /**wm_paint**/:
        
        //:SEE[ WM_PAINT_COMMENTS_SECTION ]

    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            (   (TYP(F_04))   (INS(DefWindowProcW))   )(
            /**/(void*)                han_win  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //://////////////////////////////////////// WinMsgHanWndPoc://

    void* //: [ TYP(con_win) == void* ]
    FUN(SRC_NATIVE_WINDOW_CREATION_GetWinDC)( void ){

        if(NIL==ins(con_win)){ H("[GetWinDC:NIL:con_win]"); };
        return( ins(con_win) );
    }

//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/NATIVE/WINDOW/creation._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/OPENGL/SETUP/main._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_1123AM_GL , n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_1123AM_GL , n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_1123AM_GL , n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_1123AM_GL , n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_1123AM_GL , n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_1123AM_GL , n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_1123AM_GL , n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_1123AM_GL , n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_1123AM_GL , n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_1123AM_GL , n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_1123AM_GL , n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_1123AM_GL , n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_1123AM_GL , n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_1123AM_GL , n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_1123AM_GL , n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_1123AM_GL , n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_OPENGL_SETUP_MAIN ( 2020+04+27 - 1154 + 'G' )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/OPENGL(GRAPHICS_LIB)/SETUP/main._:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/OPENGL(GRAPHICS_LIB)/SETUP/main._:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG:// 
//[THINGS_ID_LIKE_YOU_TO_SEE_FIRST:11111111111111111111111111]//

    //:IN: SRC/NATIVE/CALLWRAP/GetProcAddress._ 
    //:CORRECT[ dll_gra ]WRONG[ han_gra ]( open_gl_handle )
    extern void* INS(dll_gra); //:<--HandleTo:OpenGL32.dll
           void* ins(con_gra); //:<--Context:Graphics

//[11111111111111111111111111:THINGS_ID_LIKE_YOU_TO_SEE_FIRST]//
//:TYPEDEFS::TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD://


    //:SetupForPointerToA:GetProcAddress:Function:SC[GPA_FUN]
    //://////////////////////////////////////////////////////://
    //:                                                      ://
    //: Below we are constructing type:                      ://
    //:                         TYP(GPA_FUN) / T(GPA_FUN)    ://
    //:                                                      ://
    //: It is a is like a generic function pointer, EXCEPT   ://
    //: that it returns a function pointer rather than a     ://
    //: void*. We need this specialized generic function     ://
    //: pointer because we cannot mix data pointers and      ://
    //: function pointers when casting.                      ://
    //:                                                      ://
    //: NO!  TYP(FUN) f = (TYP(FUN))INS(gen_fun)("FuncName"); //
    //: OK:  TYP(FUN) f = (TYP(FUN))INS(gpa_fun)("FuncName"); //
    //: OK:  TYP(FUN) f =           INS(gpa_fun)("FuncName"); //
    //:                                                      ://
    //://////////////////////////////////////////////////////://
    #define T( nam ) TYP( nam ) //://////////////////////////://

    typedef void       (* T(GEN_FUN) )(void);  //:Generic:FUNC
    typedef void          T(GEN_DAT)        ;  //:Generic:DATA
    typedef T(GEN_FUN) (* T(GPA_FUN) )(void*); //:GPA_Pointer

    #undef  T //:////////////////////////////////////////////://

//:TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD::TYPEDEFS://
//:FORWARD_DECLARATIONS::FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD://

    TYP(FUN) fun(GetAnyGLFuncAddress)( const char* );

//:FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD::FORWARD_DECLARATIONS://
//:OPENGL_FUNCTION_POINTERS::FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://

    //:T1:Teir_1:Teir_1_OpenGL_Function_Pointers:------------://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
    #define    N  =(NIL);/////////://////////////////////////://  
    #define    G  TYP(GPA_FUN)  //://////////////////////////://
    #define    F  TYP(FUN)      //://////////////////////////://  

        //:These function pointers can be immediately fetched.
        //:Other OpenGL function pointers require an OpenGL
        //:context to be created first. I believe because
        //:the function pointers are [instance/member]
        //:methods of your context. 
        G            ins(wglGetProcAddress   )                 N
        F            ins(wglGetCurrentContext)                 N
        TYP(F_01)    ins(wglCreateContext    )                 N
        TYP(F_02)    ins(wglMakeCurrent      )                 N
                    
        //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
        //|You must call wglMakeCurrent after m_hDC has been |//
        //|setup. stackoverflow.com/questions/2348332 SC[    |//
        //|mc-after-dc-url ]                                 |//
        //| - - - - - - - - - - - -- - - - - - - - - - - - - |//
        //|Before you can use OpenGL,the context you created |//
        //|must be made current. This is done with the       |//
        //|wglMakeCurrent function.                          |//
        //| - - - - - - - - - - - -- - - - - - - - - - - - - |//
        //|SEE:SC[ make_context_current_you_must_url ]       |//
        //|www.khronos.org/opengl/wiki/                      |//
        //|Creating_an_OpenGL_Context_(WGL)                  |//
        //|#Simple_Context_Creation                          |//
        //|COMMENT_RIPPED_FROM[ V:\GLEB\GLEB.H ]*************|//
        //|__________________________________________________|//

    #undef     N  //:////////////////////////////////////////://
    #undef     G  //:////////////////////////////////////////://
    #undef     F  //:////////////////////////////////////////://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

    //:T2:Teir_2:Teir_1_OpenGL_Function_Pointers:------------://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
    #define     N  =(NIL);/////////://///////////////////////://  
    #define     F  TYP(FUN)      //://///////////////////////://    

    /** 01 **/  F       ins(glGenBuffers                     ) N            
    /** 02 **/  F       ins(glBindBuffer                     ) N            
    /** 03 **/  F       ins(glBufferData                     ) N            
    /** 04 **/  F       ins(glGetError                       ) N            
    /** 05 **/  F       ins(glEnableVertexAttribArray        ) N
    /** 06 **/  F       ins(glVertexAttribPointer            ) N   
    /** 07 **/  F       ins(glDrawArrays                     ) N            
    /** 08 **/  F       ins(glDisableVertexAttribArray       ) N
    /** 09 **/  F       ins(glCreateShader                   ) N          
    /** 10 **/  F       ins(glShaderSource                   ) N          
    /** 11 **/  F       ins(glCompileShader                  ) N         
    /** 12 **/  F       ins(glGetShaderiv                    ) N           
    /** 13 **/  F       ins(glGetShaderInfoLog               ) N      
    /** 14 **/  F       ins(glCreateProgram                  ) N         
    /** 15 **/  F       ins(glAttachShader                   ) N          
    /** 16 **/  F       ins(glLinkProgram                    ) N           
    /** 17 **/  F       ins(glGetProgramiv                   ) N          
    /** 18 **/  F       ins(glGetProgramInfoLog              ) N     
    /** 19 **/  F       ins(glDetachShader                   ) N          
    /** 20 **/  F       ins(glDeleteShader                   ) N          
    /** 21 **/  F       ins(glClear                          ) N                 
    /** 22 **/  F       ins(glUseProgram                     ) N            
    /** 23 **/  F       ins(glViewport                       ) N              
    /** 24 **/  F       ins(glClearColor                     ) N            
    /** 25 **/  F       ins(glGenVertexArrays                ) N       
    /** 26 **/  F       ins(glBindVertexArray                ) N       
    /** 27 **/  F       ins(glGenTextures                    ) N           
    /** 28 **/  F       ins(glBindTexture                    ) N           
    /** 29 **/  F       ins(glTexParameteri                  ) N         
    /** 30 **/  F       ins(glTexImage2D                     ) N            
    /** 31 **/  F       ins(glActiveTexture                  ) N         
    /** 32 **/  F       ins(glGetUniformLocation             ) N    
    /** 33 **/  F       ins(glUniform1i                      ) N             
    /** 34 **/  F       ins(glPixelStorei                    ) N           
    /** 35 **/  F       ins(glEnable                         ) N                
    /** 36 **/  F       ins(glFinish                         ) N                
    /** 37 **/  F       ins(glGetIntegerv                    ) N           
                    
    #undef      N  //:///////////////////////////////////////://
    #undef      F  //:///////////////////////////////////////://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
//:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP::OPENGL_FUNCTION_POINTERS://
//:OPEN_GL_ENUMERATIONS:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE://

    //:Sizes of various openGL types:
    //:     www.khronos.org/opengl/wiki/OpenGL_Type
    //:
    //:Good lookup tool to verify enum values:
    //:     docs.factorcode.org/search?search=GLbool

    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)
    //://////////////////////////////////////////////////////://
    #define  E_M BLUE_PENGUINS_ON_PARADE //:ERROR_MESSAGE
    #define  D_T U32                     //:DECLARE_TYPE(ALL)
    #define  E_0(con,msg) _Static_assert( con, msg )
    #define  E_1(t_t,msg) E_0(sizeof(t_t) > 0, msg )
    #define  A_1 _Static_assert
    #define  A_2(h_d,msg_nam) A_1(               h_d,#msg_nam )
    #define  A_3(h_d,nam,msg) A_2(               h_d, msg:nam )
    #define  A_4(h_d,nam,msg) A_3(               h_d, nam,msg )
    #define  A_5(nam,hex,dec) A_4(          hex==dec, nam,E_M )
    #define  A_6(nam,hex,dec) A_5(   nam  , hex ,dec          )
    #define  D_1(nam,hex    ) D_T INS(nam) = hex
    #define  D_2(nam,hex    ) D_1(    nam  , hex       )
    #define  DA1(nam,hex,dec) D_2(nam,hex) ; A_6(nam,hex,dec)
    #define  DA2(nam,hex,dec,eye_tot) DA1(nam,hex,dec)
        
        //:DA: Declare & Assert
        //:HackishChecksum:Check hex against decimal for match.
        DA2( gl_unsigned_byte        ,0x1401    , 5121  , 01 ) ;
        DA2( gl_texture_min_filter   ,0x2801    , 10241 , 02 ) ;
        DA2( gl_texture_mag_filter   ,0x2800    , 10240 , 03 ) ;
        DA2( gl_texture_wrap_s       ,0x2802    , 10242 , 04 ) ;       
        DA2( gl_texture_wrap_t       ,0x2803    , 10243 , 05 ) ;
        DA2( gl_nearest              ,0x2600    , 9728  , 06 ) ;
        DA2( gl_clamp_to_edge        ,0x812F    , 33071 , 07 ) ;
        DA2( gl_texture0             ,0x84C0    , 33984 , 08 ) ;
        DA2( gl_max_uniform_locations,1024      , 1024  , 09 ) ;
        DA2( gl_unpack_alignment     ,0x0CF5    , 3317  , 10 ) ;
        DA2( gl_texture_2d           ,0x0DE1    , 3553  , 11 ) ;
        DA2( gl_texture_binding_2d   ,0x8069    , 32873 , 12 ) ;
        DA2( gl_rgba_integer         ,0x8D99    , 36249 , 13 ) ;
        DA2( gl_active_texture       ,0x84E0    , 34016 , 14 ) ;
        DA2( gl_rgba8ui              ,0x8D7C    , 36220 , 15 ) ;
        DA2( gl_float                ,0x1406    , 5126  , 16 ) ;
        DA2( gl_true                 ,1         ,     1 , 17 ) ;
        DA2( gl_false                ,0         ,     0 , 18 ) ;
        DA2( gl_array_buffer         ,0x8892    , 34962 , 19 ) ;
        DA2( gl_static_draw          ,0x88E4    , 35044 , 20 ) ;
        DA2( gl_no_error             ,0x0       ,     0 , 21 ) ;
        DA2( gl_triangles            ,0x0004    ,     4 , 22 ) ;
        DA2( gl_triangle_fan         ,0x0006    ,     6 , 23 ) ;
        DA2( gl_triangle_strip       ,0x0005    ,     5 , 24 ) ;
        DA2( gl_vertex_shader        ,0x8B31    , 35633 , 25 ) ;
        DA2( gl_fragment_shader      ,0x8B30    , 35632 , 26 ) ;
        DA2( gl_compile_status       ,0x8B81    , 35713 , 27 ) ;
        DA2( gl_info_log_length      ,0x8B84    , 35716 , 28 ) ;
        DA2( gl_link_status          ,0x8B82    , 35714 , 29 ) ;
        DA2( gl_color_buffer_bit     ,0x00004000, 16384 , 30 ) ;

        //:E_#:Exists: Assert these INS(___) types exist
        //:    by using static type assertion and sizeof(...)
        //:    WRITTEN THIS WAY SO YOU CAN USE "CTRL+F" on
        //:    the name of the type and have an chance of
        //:    figuring out how+where it is defined. 
        //:    (It is defined  ABOVE in this macro section)
        //:    (And   verified BELOW in this macro section)
        E_1( INS(gl_unsigned_byte        ) , "eye_tot:01" );
        E_1( INS(gl_texture_min_filter   ) , "eye_tot:02" );
        E_1( INS(gl_texture_mag_filter   ) , "eye_tot:03" );
        E_1( INS(gl_texture_wrap_s       ) , "eye_tot:04" );
        E_1( INS(gl_texture_wrap_t       ) , "eye_tot:05" );
        E_1( INS(gl_nearest              ) , "eye_tot:06" );
        E_1( INS(gl_clamp_to_edge        ) , "eye_tot:07" );
        E_1( INS(gl_texture0             ) , "eye_tot:08" );
        E_1( INS(gl_max_uniform_locations) , "eye_tot:09" );
        E_1( INS(gl_unpack_alignment     ) , "eye_tot:10" );
        E_1( INS(gl_texture_2d           ) , "eye_tot:11" );
        E_1( INS(gl_texture_binding_2d   ) , "eye_tot:12" );
        E_1( INS(gl_rgba_integer         ) , "eye_tot:13" );
        E_1( INS(gl_active_texture       ) , "eye_tot:14" );
        E_1( INS(gl_rgba8ui              ) , "eye_tot:15" );
        E_1( INS(gl_float                ) , "eye_tot:16" );
        E_1( INS(gl_true                 ) , "eye_tot:17" );
        E_1( INS(gl_false                ) , "eye_tot:18" );
        E_1( INS(gl_array_buffer         ) , "eye_tot:19" );
        E_1( INS(gl_static_draw          ) , "eye_tot:20" );
        E_1( INS(gl_no_error             ) , "eye_tot:21" );
        E_1( INS(gl_triangles            ) , "eye_tot:22" );
        E_1( INS(gl_triangle_fan         ) , "eye_tot:23" );
        E_1( INS(gl_triangle_strip       ) , "eye_tot:24" );
        E_1( INS(gl_vertex_shader        ) , "eye_tot:25" );
        E_1( INS(gl_fragment_shader      ) , "eye_tot:26" );
        E_1( INS(gl_compile_status       ) , "eye_tot:27" );
        E_1( INS(gl_info_log_length      ) , "eye_tot:28" );
        E_1( INS(gl_link_status          ) , "eye_tot:29" );
        E_1( INS(gl_color_buffer_bit     ) , "eye_tot:30" );
            
    #undef   E_M    //://////////////////////////////////////://
    #undef   D_T    //://////////////////////////////////////://
    #undef   E_0    //://////////////////////////////////////://
    #undef   E_1    //://////////////////////////////////////://
    #undef   A_1    //://////////////////////////////////////://
    #undef   A_2    //://////////////////////////////////////://
    #undef   A_3    //://////////////////////////////////////://
    #undef   A_4    //://////////////////////////////////////://
    #undef   A_5    //://////////////////////////////////////://
    #undef   A_6    //://////////////////////////////////////://
    #undef   D_1    //://////////////////////////////////////://
    #undef   D_2    //://////////////////////////////////////://
    #undef   DA1    //://////////////////////////////////////://
    #undef   DA2    //://////////////////////////////////////://
    //://////////////////////////////////////////////////////://
    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)

//:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:OPEN_GL_ENUMERATIONS://
//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
    void EII(SRC_OPENGL_SETUP_main)(void){ //:///////////////://

        //:T1:Teir_1:Grab Teir 1 OpenGL Functions:
        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

        #define g_p_a FUN(SRC_NATIVE_CALLWRAP_GetProcAddress) //
        #define G_P_A( a ) g_p_a( "dll_gra",  a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!ins( a )){ H( #a"[IS_NULL]" ); };
        #define     N( a ) n( a ) //:////////////////////////://

            #define G0( a ) G( a )
            #define G1( a ) (TYP(F_01))G( a )
            #define G2( a ) (TYP(F_02))G( a )

            //:MACROS:
            //:     G: Calls GetProcAddress
            //:     N: Null  Checks Function Pointer

            //:wglGetProcAddress: IS_SPECIAL:
            //:wglGetProcAddress cant simply be casted to
            //:our regular generic function pointer type
            //:that returns (void*).
            //:WHY:
            //:void* is a generic datapointer, it needs to 
            //:return geneneric functionpointer to not violate
            //:strict C rules.
            ins(wglGetProcAddress   )=(
                (TYP(GPA_FUN))G( wglGetProcAddress    ));;

            ins(wglGetCurrentContext)=G0( wglGetCurrentContext);
            ins(wglCreateContext    )=G1( wglCreateContext    );
            ins(wglMakeCurrent      )=G2( wglMakeCurrent      );

            N(wglGetProcAddress   ); //:NULL_CHECKS
            N(wglGetCurrentContext); //:NULL_CHECKS
            N(wglCreateContext    ); //:NULL_CHECKS
            N(wglMakeCurrent      ); //:NULL_CHECKS

            #undef G0
            #undef G1
            #undef G2

        #undef  g_p_a  //:///////////////////////////////////://
        #undef  G_P_A  //:///////////////////////////////////://
        #undef      G  //:///////////////////////////////////://
        #undef      n  //:///////////////////////////////////://
        #undef      N  //:///////////////////////////////////://

        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
        
        //:get_window_device_context:
        //:con_win==windows_handle_to_device_context
        //:con_win::CONtext_WINdow
        void* var(con_win)=(
            FUN(SRC_NATIVE_WINDOW_CREATION_GetWinDC)( ) );;
        if(NIL==var(con_win)){ H("[FAIL:NIL_GET:con_win]");};
        if(NIL!=var(con_win)){ D("[PASS:GET_GOT:con_win]");};

        //:make:open_gl_rendering_context:AKA:OpenGL_Context
        //:con_gra==handle_to_gl_rendering_context
        //:con_gra::CONtext_GRAphics
        ins(con_gra)=( ins(wglCreateContext)( var(con_win) ) );
        if(NIL==ins(con_gra)){ H("[FAIL:NIL_MAKE:con_gra]");};
        if(NIL!=ins(con_gra)){ D("[PASS:GOT_MADE:con_gra]");};

        //# CONTEXT_MUST_BE_MADE_CURRENT_BEFORE_WE_CAN_FETCH #//
        //# OTHER_FUNCTIONS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! #//
        int v_2(wglMakeCurrent,worked)=( 0 );
            v_2(wglMakeCurrent,worked)=(
                (int)(U64)
                ins(wglMakeCurrent)(
                    var(con_win) //: HDC   ( void* )
                ,   ins(con_gra) //: HGLRC ( void* )
                )
            );;
            if( 1!=v_2(wglMakeCurrent,worked) ){ H("[M_C]");};
            if( 1==v_2(wglMakeCurrent,worked) ){ D("[M_C]");};

        //:T2:Teir_2:( 2nd_tier_opengl_function_pointers )
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
        //://////////////////////////////////////////////////://
        #define g_p_a fun(GetAnyGLFuncAddress)       //://///://
        #define G_P_A( a ) g_p_a(             a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!ins( a )){ H( #a"[IS_NULL]" ); };
        #define     o( a ) if( ins( a )){ D( "[OK_YEAH]"#a ); };
        #define     N( a ) n( a ) //:////////////////////////://

            //:G_N:Get_function_pointer_AND_check_for_null.
            //://////////////////////////////////////////////://
            #define G_N( a ) ins( a )=G( a );N( a ); o( a );

                    G_N( glGenBuffers               );//| 01 |//
                    G_N( glBindBuffer               );//| 02 |//
                    G_N( glBufferData               );//| 03 |//
                    G_N( glGetError                 );//| 04 |//
                    G_N( glEnableVertexAttribArray  );//| 05 |//
                    G_N( glVertexAttribPointer      );//| 06 |//
                    G_N( glDrawArrays               );//| 07 |//
                    G_N( glDisableVertexAttribArray );//| 08 |//
                    G_N( glCreateShader             );//| 09 |//
                    G_N( glShaderSource             );//| 10 |//
                    G_N( glCompileShader            );//| 11 |//
                    G_N( glGetShaderiv              );//| 12 |//
                    G_N( glGetShaderInfoLog         );//| 13 |//
                    G_N( glCreateProgram            );//| 14 |//
                    G_N( glAttachShader             );//| 15 |//
                    G_N( glLinkProgram              );//| 16 |//
                    G_N( glGetProgramiv             );//| 17 |//
                    G_N( glGetProgramInfoLog        );//| 18 |//
                    G_N( glDetachShader             );//| 19 |//
                    G_N( glDeleteShader             );//| 20 |//
                    G_N( glClear                    );//| 21 |//
                    G_N( glUseProgram               );//| 22 |//
                    G_N( glViewport                 );//| 23 |//
                    G_N( glClearColor               );//| 24 |//
                    G_N( glGenVertexArrays          );//| 25 |//
                    G_N( glBindVertexArray          );//| 26 |//
                    G_N( glGenTextures              );//| 27 |//
                    G_N( glBindTexture              );//| 28 |//
                    G_N( glTexParameteri            );//| 29 |//
                    G_N( glTexImage2D               );//| 30 |//
                    G_N( glActiveTexture            );//| 31 |//
                    G_N( glGetUniformLocation       );//| 32 |//
                    G_N( glUniform1i                );//| 33 |//
                    G_N( glPixelStorei              );//| 34 |//
                    G_N( glEnable                   );//| 35 |//
                    G_N( glFinish                   );//| 36 |//
                    G_N( glGetIntegerv              );//| 37 |//

            #undef  G_N //://////////////////////////////////://
            //://////////////////////////////////////////////://

        #undef  g_p_a   //://////////////////////////////////://
        #undef  G_P_A   //://////////////////////////////////://
        #undef      G   //://////////////////////////////////://
        #undef      n   //://////////////////////////////////://
        #undef      o   //://////////////////////////////////://
        #undef      N   //://////////////////////////////////://
        //://////////////////////////////////////////////////://
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://


    }    E_F(SRC_OPENGL_SETUP_main)  //://///////////////////://
//[MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:MAIN]//


//:AG:Any_GL:(BELOW):¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:                                                          ://
//: AG: Any GL ( Get Any OpenGL Function Pointer )           ://
//:                                                          ://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:wglGetProcAddress will not return function pointers from  ://
//:any OpenGL functions that are directly exported by the    ://
//:OpenGL32.DLL itself. This means the old ones from OpenGL  ://
//:version 1.1. Fortunately those functions can be obtained  ://
//:by the Win32's GetProcAddress. On the other hand          ://
//:GetProcAddress will not work for the functions for which  ://
//:wglGetProcAddress works. So in order to get the address of://
//:any GL function one can try with wglGetProcAddress and if ://
//:it fails,try again with the Win32's GetProcAddress:       ://
//:SOURCE[ URL[                                              ://
//:                                                          ://
//:      www.khronos.org/opengl/wiki/Load_OpenGL_Functions   ://
//:                                                          ://
//: ]URL]SOURCE                                              ://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
    TYP(FUN) fun(GetAnyGLFuncAddress)( //:///////////////////://
        const char* ARG(fun_nam) //:name_of_open_gl_function
    ){
        //:Remove const qualifier:
        char* fun_nam=(char*)ARG(fun_nam);

        //:This MIGHT be the only call you need:
        TYP(FUN) ret_pfn=( ins(wglGetProcAddress)( fun_nam ) );

        //:Unless some weird math with the function pointer
        //:or null is returned. SEE[ Load_OpenGL_Functions ]
        if(
            ( ret_pfn ==        0       ) ||
            ( ret_pfn == ( TYP(FUN) )0x1) || 
            ( ret_pfn == ( TYP(FUN) )0x2) ||
            ( ret_pfn == ( TYP(FUN) )0x3) ||
            ( ret_pfn == ( TYP(FUN) ) -1) ||
        0){
            //:If we are in this section, these are the special
            //:function pointers that require an opengl 
            //:instance. So if dll_gra is NIL, we did not
            //:do things in the correct order and consider
            //:the fact that it worked co-incidential.
            //:AKA:Undefined Behavior.
            if(NIL==INS(dll_gra) ){ H("[2020_04_28_0131AM]");};
            ret_pfn=FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
            /**/    "dll_gra" //:DLL_Graphics:OpenGL.dll
            ,       fun_nam   //:name_of_open_gl_function
            );;
            if(NIL==ret_pfn){ H("[2020_04_28_0205AM]"); };
        };;
        if(NULL==ret_pfn){ H("[2020_04_28_0128AM]");};;
        return(  ret_pfn );
    }E_F(GetAnyGLFuncAddress)//://///////////////////////////://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:AG:Any_GL:(ABOVE):________________________________________://


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//


//:COMMENTS_SECTION:

    //[#GL_FLOAT#]////|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //|On a platfrom that supports IEEE-754 float it's going |//
    //|to be 32 bit. On platforms that don't,different width |//
    //|will probably be the least of your problems. Bottom   |//
    //|line - use float and don't worry.                     |//
    //|stackoverflow.com/questions/18705192                  |//
    //|                                                      |//
    //|glcoarearb.h : typedef       khronos_float_t GLfloat; |//
    //|khrplatform.h: typedef float khronos_float_t        ; |// 
    //|                                                      |//
    //|THIS_WILL_BE_GOOD_ENOUGH:                             |//
    //|typedef float GLfloat;                                |//
    //|                                                      |//
    //|______________________________________________________|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/OPENGL/SETUP/main._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/OPENCL/SETUP/main._


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:ESTABLISH_NAMESPACE::::::::::::::::::::::::::::::////| == |//
//:SEE[ SRC\PROJECT_PREFIX.DEFINE._ ]:::::::::::::::////| == |//
//:For definitions of:               :::::::::::::::////| == |//
//:      1:    MACRO_project_prefix_HIDDEN :::::::::////| == |//
//:      2:    MACRO_project_prefix_VISIBLE:::::::::////| == |//
#define    lib MACRO_project_prefix_HIDDEN            //| 01 |//
#define    LIB MACRO_project_prefix_VISIBLE           //| 02 |//
//:TEMPORRARY_HELPER_MACROS:::::::::::::::::::::::::////| -- |//
#define    gm2( a , b )      a## _ ##b                //| 03 |//
#define    GM2( a , b ) gm2( a   ,   b )              //| 04 |//
#define    gm3( a,b,c )      a## _ ##b##   _ ##c      //| 05 |//
#define    GM3( a,b,c ) gm3( a   ,   b     ,   c )    //| 06 |//
//:USABLE_SCOPES: VISIBLE/PUBLIC/LOCAL/GLOBAL:::::::////| -- |//
#define    INS( n ) GM3( LIB ,INS, n )  //:INSTANCE:////| 07 |//
#define    TYP( n ) GM3( LIB ,TYP, n )  //:TYPE:::::////| 08 |//
#define    EII( n ) GM3( LIB ,EII, n )  //:E.I.I.:::////| 09 |//
#define    MEM( n ) GM3( LIB ,MEM, n )  //:MEMBER:::////| 10 |//
#define    FUN( n ) GM3( LIB ,FUN, n )  //:FUNCTION:////| 11 |//
//:SubBranch.TYPE==BRA, SubBranch.INST==SUB:::::::::////| -- |//
#define    BRA( n ) GM3( lib, bra,n )   //:TYPE:::::////| 12 |//
#define    SUB( n ) GM3( lib, sub,n )   //:INSTANCE:////| 13 |//
//:ARGument+RETurn+VARiable:Local+Public only:::::::////| -- |//
#define    ARG( n ) GM2(      ARG,n )   //:ARGUMENT:////| 14 |//
#define    RET( n ) GM2(      RET,n )   //:RET_VAL::////| 15 |//
#define    VAR( n ) GM2(      VAR,n )   //:LOCALVAR:////| 16 |//
//:PRIVATE_VIA_OBFUSCATION:Use_As_Local_Or_Global:::////| -- |//
#define    var( n ) GM2( v_2020_04_29_0714AM_CL , n ) //| 17 |//
#define    eii( n ) GM2( e_2020_04_29_0714AM_CL , n ) //| 18 |//
#define    mem( n ) GM2( m_2020_04_29_0714AM_CL , n ) //| 19 |//
#define    ins( n ) GM2( i_2020_04_29_0714AM_CL , n ) //| 20 |//
#define    fun( n ) GM2( f_2020_04_29_0714AM_CL , n ) //| 21 |//
#define    typ( n ) GM2( t_2020_04_29_0714AM_CL , n ) //| 22 |//
#define    arg( n ) GM2( a_2020_04_29_0714AM_CL , n ) //| 23 |//
#define    ret( n ) GM2( r_2020_04_29_0714AM_CL , n ) //| 24 |//
#define    bra( n ) GM2( b_2020_04_29_0714AM_CL , n ) //| 25 |//
#define    sub( n ) GM2( s_2020_04_29_0714AM_CL , n ) //| 26 |//
#define    obj( n ) GM2( o_2020_04_29_0714AM_CL , n ) //| 27 |//
#define    poi( n ) GM2( p_2020_04_29_0714AM_CL , n ) //| 28 |//
#define    siz( n ) GM2( S_2020_04_29_0714AM_CL , n ) //| 29 |//
#define    num( n ) GM2( N_2020_04_29_0714AM_CL , n ) //| 30 |//
#define    arr( n ) GM2( A_2020_04_29_0714AM_CL , n ) //| 31 |//
#define    dex( n ) GM2( D_2020_04_29_0714AM_CL , n ) //| 32 |//
//:PRIVATE_GLOBALS:(Private,but not obfuscated):::::////| -- |//
#define  GLO_1(G,a    ) G ##_## a                     //| 33 |//
#define  GLO_2(G,a,b  ) G ##_## a ##_## b             //| 34 |//
#define  GLO_3(G,a,b,c) G ##_## a ##_## b ##_## c     //| 35 |//
#define    g_1(a      ) GLO_1( lib, a      )          //| 36 |//
#define    g_2(a,b    ) GLO_2( lib, a,b    )          //| 37 |//
#define    g_3(a,b,c  ) GLO_3( lib, a,b,c  )          //| 38 |//
//:Local_Variables:(Namespace=="V_")::::::::::::::::////| -- |//
#define  VAR_1(V,a    ) V ##_## a                     //| 39 |//
#define  VAR_2(V,a,b  ) V ##_## a ##_## b             //| 40 |//
#define  VAR_3(V,a,b,c) V ##_## a ##_## b ##_## c     //| 41 |//
#define    v_1(a      ) VAR_1(   V, a      )          //| 42 |//
#define    v_2(a,b    ) VAR_2(   V, a,b    )          //| 43 |//
#define    v_3(a,b,c  ) VAR_3(   V, a,b,c  )          //| 44 |//
//:MISC:::::::::::::::::::::::::::::::::::::::::::::////| -- |//
#define termin //:TERMINAL_STRUCT_NODE://             //| 45 |//
#define    NIL        ((void*)0)                      //| 46 |//
#define    E_S(  nam  )   ;  // END_STRUCT            //| 47 |//
#define    E_F(  nam  )      // END_FUNCTION          //| 48 |//
#define      s ;                                      //| 49 |//
#define      S ;                                      //| 50 |//
#define      _                                        //| 51 |//
#define      H          fun( Halt )                   //| 52 |//
#define      D          fun( Dmsg )                   //| 53 |//
//:PRIMITIVE_TYPES::::::::::::::::::::::::::::::::::////| -- |//
#define    U32 unsigned           int                 //| 54 |//
#define    I32 signed             int                 //| 55 |//
#define    U64 unsigned long long int                 //| 56 |//
#define    I64 signed   long long int                 //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
//:V_* can be confused as a local variable.      :::////| == |//
//:F_* can be confused as function pyramid type. :::////| == |//
//:g_ : private global. (File scope variable.)   :::////| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_OPENCL_SETUP_MAIN ( 2020+04+27 - 1154 + 'C' )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/OPENCL(COMPUTE_LIB)/SETUP/main._:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/OPENCL(COMPUTE_LIB)/SETUP/main._:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://        
//:TYPEDEFS::TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD://


    //:SetupForPointerToA:GetProcAddress:Function:SC[GPA_FUN]
    //://////////////////////////////////////////////////////://
    //:                                                      ://
    //: Below we are constructing type:                      ://
    //:                         TYP(GPA_FUN) / T(GPA_FUN)    ://
    //:                                                      ://
    //: It is a is like a generic function pointer, EXCEPT   ://
    //: that it returns a function pointer rather than a     ://
    //: void*. We need this specialized generic function     ://
    //: pointer because we cannot mix data pointers and      ://
    //: function pointers when casting.                      ://
    //:                                                      ://
    //: NO!  TYP(FUN) f = (TYP(FUN))INS(gen_fun)("FuncName"); //
    //: OK:  TYP(FUN) f = (TYP(FUN))INS(gpa_fun)("FuncName"); //
    //: OK:  TYP(FUN) f =           INS(gpa_fun)("FuncName"); //
    //:                                                      ://
    //://////////////////////////////////////////////////////://
    #define T( nam ) TYP( nam ) //://////////////////////////://

    typedef void       (* T(GEN_FUN) )(void);  //:Generic:FUNC
    typedef void          T(GEN_DAT)        ;  //:Generic:DATA
    typedef T(GEN_FUN) (* T(GPA_FUN) )(void*); //:GPA_Pointer

    #undef  T //:////////////////////////////////////////////://

//:TDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTDTD::TYPEDEFS://
//:FORWARD_DECLARATIONS::FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD://

    TYP(FUN) fun(GetAnyCLFuncAddress)( const char* );

//:FDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFD::FORWARD_DECLARATIONS://
//:OPENCL_FUNCTION_POINTERS::FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://

    //:T1:Teir_1:Teir_1_OpenCL_Function_Pointers:------------://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
    #define    N  =(NIL);/////////://////////////////////////://  
    #define    G  TYP(GPA_FUN)  //://////////////////////////://
    #define    F  TYP(FUN)      //://////////////////////////://  

    //: //:OpenCL function pointers that can be immediately
    //: //:Fetched without requiring an OpenCL instance.
    //: G            ins(wclGetProcAddress   )                 N
    //: F            ins(wclGetCurrentContext)                 N
    //: TYP(F_01)    ins(wclCreateContext    )                 N
    //: TYP(F_02)    ins(wclMakeCurrent      )                 N

    #undef     N  //:////////////////////////////////////////://
    #undef     G  //:////////////////////////////////////////://
    #undef     F  //:////////////////////////////////////////://
    //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

    //:T2:Teir_2:Teir_1_OpenCL_Function_Pointers:------------://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
    #define  N      =(NIL);   //:////////////////////////////://  
    #define  F    TYP(FUN)    //:////////////////////////////://   
    #define  F_01 TYP(F_01)   //:////////////////////////////://
    #define  F_02 TYP(F_02)   //:////////////////////////////://
    #define  F_03 TYP(F_03)   //:////////////////////////////://
    #define  F_04 TYP(F_04)   //:////////////////////////////://
    #define  F_05 TYP(F_05)   //:////////////////////////////://
    #define  F_06 TYP(F_06)   //:////////////////////////////://
    #define  F_07 TYP(F_07)   //:////////////////////////////://
    #define  F_08 TYP(F_08)   //:////////////////////////////://
    #define  F_09 TYP(F_09)   //:////////////////////////////://

    //:OpenCL: 1.2  
    //:------------------------------------------------------://
    #define MACRO_01 clGetExtensionFunctionAddressForPlatform
    //:------------------------------------------------------://
    F_01  INS( clFinish                   ) N         //| 01 |//
    F_01  INS( clFlush                    ) N         //| 02 |//
    F_01  INS( clReleaseKernel            ) N         //| 03 |//
    F_01  INS( clReleaseProgram           ) N         //| 04 |//
    F_01  INS( clReleaseMemObject         ) N         //| 05 |//
    F_01  INS( clReleaseCommandQueue      ) N         //| 06 |//
    F_01  INS( clReleaseContext           ) N         //| 07 |//
    F_02  INS( clWaitForEvents            ) N         //| 08 |//
    F_02  INS( MACRO_01                   ) N         //| 09 |//
    F_03  INS( clGetPlatformIDs           ) N         //| 10 |//
    F_03  INS( clCreateKernel             ) N         //| 11 |//
    F_04  INS( clCreateCommandQueue       ) N         //| 12 |//
    F_04  INS( clSetKernelArg             ) N         //| 13 |//
    F_05  INS( clCreateBuffer             ) N         //| 14 |//
    F_05  INS( clCreateProgramWithSource  ) N         //| 15 |//
    F_05  INS( clGetDeviceIDs             ) N         //| 16 |//
    F_05  INS( clGetDeviceInfo            ) N         //| 17 |//
    F_05  INS( clGetContextInfo           ) N         //| 18 |//
    F_05  INS( clGetCommandQueueInfo      ) N         //| 19 |//
    F_05  INS( clGetKernelInfo            ) N         //| 20 |//
    F_05  INS( clGetPlatformInfo          ) N         //| 21 |//
    F_06  INS( clGetProgramBuildInfo      ) N         //| 22 |//
    F_06  INS( clBuildProgram             ) N         //| 23 |//
    F_06  INS( clCreateContext            ) N         //| 24 |//
    F_09  INS( clEnqueueReadBuffer        ) N         //| 25 |//
    F_09  INS( clEnqueueNDRangeKernel     ) N         //| 26 |//
    F_09  INS( clEnqueueWriteBuffer       ) N         //| 27 |//
    //:------------------------------------------------------://
    #undef MACRO_01 //://////////////////////////////////////://
    //:------------------------------------------------------://

    //:CL 2.0 only.
    //:F_04  INS( clCreateCommandQueueWithProperties       ) N 
          
    #undef  N     //:////////////////////////////////////////://
    #undef  F     //:////////////////////////////////////////://
    #undef  F_01  //:////////////////////////////////////////://
    #undef  F_02  //:////////////////////////////////////////://
    #undef  F_03  //:////////////////////////////////////////://
    #undef  F_04  //:////////////////////////////////////////://
    #undef  F_05  //:////////////////////////////////////////://
    #undef  F_06  //:////////////////////////////////////////://
    #undef  F_07  //:////////////////////////////////////////://
    #undef  F_08  //:////////////////////////////////////////://
    #undef  F_09  //:////////////////////////////////////////://
    //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
//:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP::OPENCL_FUNCTION_POINTERS://
//:OPEN_CL_ENUMERATIONS:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE://

    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)
    //://////////////////////////////////////////////////////://
    #define  E_M CLEAR_CRYSTAL_BALL_WITCH_PARTY //:ERROR_MESSAGE
    #define  D_T U32                     //:DECLARE_TYPE(ALL)
    #define  E_0(con,msg) _Static_assert( con, msg )
    #define  E_1(t_t,msg) E_0(sizeof(t_t) > 0, msg )
    #define  A_1 _Static_assert
    #define  A_2(h_d,msg_nam) A_1(               h_d,#msg_nam )
    #define  A_3(h_d,nam,msg) A_2(               h_d, msg:nam )
    #define  A_4(h_d,nam,msg) A_3(               h_d, nam,msg )
    #define  A_5(nam,hex,dec) A_4(          hex==dec, nam,E_M )
    #define  A_6(nam,hex,dec) A_5(   nam  , hex ,dec          )
    #define  D_1(nam,hex    ) D_T INS(nam) = hex
    #define  D_2(nam,hex    ) D_1(    nam  , hex       )
    #define  DA1(nam,hex,dec) D_2(nam,hex) ; A_6(nam,hex,dec)
    #define  DA2(nam,hex,dec,eye_tot) DA1(nam,hex,dec)
        
        //:DA: Declare & Assert
        //:HackishChecksum:Check hex against decimal for match.
        DA2( cl_mem_read_write      ,   0x1 , (1<<0) , A_01 ) ;
        DA2( cl_mem_write_only      ,   0x2 , (1<<1) , A_02 ) ;
        DA2( cl_mem_read_only       ,   0x4 , (1<<2) , A_03 ) ;
        DA2( cl_mem_use_host_ptr    ,   0x8 , (1<<3) , A_04 ) ;       
        DA2( cl_mem_alloc_host_ptr  ,  0x10 , (1<<4) , A_05 ) ;
        DA2( cl_mem_copy_host_ptr   ,  0x20 , (1<<5) , A_06 ) ;
        ///( RESERVED               ,  0x40 , (1<<6) , A_07 ) ;
        DA2( cl_mem_host_write_only ,  0x80 , (1<<7) , A_08 ) ;
        DA2( cl_mem_host_read_only  , 0x100 , (1<<8) , A_09 ) ;
        DA2( cl_mem_host_no_access  , 0x200 , (1<<9) , A_10 ) ;

        DA2( cl_device_type_default     ,0x1, (1<<0) , B_01 ) ;
        DA2( cl_device_type_cpu         ,0x2, (1<<1) , B_02 ) ;
        DA2( cl_device_type_gpu         ,0x4, (1<<2) , B_03 ) ;
        DA2( cl_device_type_accelerator ,0x8, (1<<3) , B_04 ) ;

        //:cl_platform_info:
        DA2( cl_platform_profile    ,
                               0x0900, (0x900 + 0) , C_01 ) ;
        DA2( cl_platform_version    ,
                               0x0901, (0x900 + 1) , C_02 ) ;
        DA2( cl_platform_name       ,
                               0x0902, (0x900 + 2) , C_03 ) ;
        DA2( cl_platform_vendor     ,
                               0x0903, (0x900 + 3) , C_04 ) ;
        DA2( cl_platform_extensions ,
                               0x0904, (0x900 + 4) , C_05 ) ;

        //:E_#:Exists: Assert these INS(___) types exist
        //:SEE[ STATIC_ASSERT_EXIST_HACK ]
        E_1( INS(cl_mem_read_write         ) , "eye_tot:A_01" );
        E_1( INS(cl_mem_write_only         ) , "eye_tot:A_02" );
        E_1( INS(cl_mem_read_only          ) , "eye_tot:A_03" );
        E_1( INS(cl_mem_use_host_ptr       ) , "eye_tot:A_04" );
        E_1( INS(cl_mem_alloc_host_ptr     ) , "eye_tot:A_05" );
        E_1( INS(cl_mem_copy_host_ptr      ) , "eye_tot:A_06" );
        ///( INS(RESERVED                  ) , "eye_tot:A_07" );
        E_1( INS(cl_mem_host_write_only    ) , "eye_tot:A_08" );
        E_1( INS(cl_mem_host_read_only     ) , "eye_tot:A_09" );
        E_1( INS(cl_mem_host_no_access     ) , "eye_tot:A_10" );

        E_1( INS(cl_device_type_default    ) , "eye_tot:B_01" );
        E_1( INS(cl_device_type_cpu        ) , "eye_tot:B_02" );
        E_1( INS(cl_device_type_gpu        ) , "eye_tot:B_03" );
        E_1( INS(cl_device_type_accelerator) , "eye_tot:B_04" );

        E_1( INS(cl_platform_profile       ) , "eye_tot:C_01" );
        E_1( INS(cl_platform_version       ) , "eye_tot:C_02" );
        E_1( INS(cl_platform_name          ) , "eye_tot:C_03" );
        E_1( INS(cl_platform_vendor        ) , "eye_tot:C_04" );
        E_1( INS(cl_platform_extensions    ) , "eye_tot:C_05" );

    #undef   E_M    //://////////////////////////////////////://
    #undef   D_T    //://////////////////////////////////////://
    #undef   E_0    //://////////////////////////////////////://
    #undef   E_1    //://////////////////////////////////////://
    #undef   A_1    //://////////////////////////////////////://
    #undef   A_2    //://////////////////////////////////////://
    #undef   A_3    //://////////////////////////////////////://
    #undef   A_4    //://////////////////////////////////////://
    #undef   A_5    //://////////////////////////////////////://
    #undef   A_6    //://////////////////////////////////////://
    #undef   D_1    //://////////////////////////////////////://
    #undef   D_2    //://////////////////////////////////////://
    #undef   DA1    //://////////////////////////////////////://
    #undef   DA2    //://////////////////////////////////////://
    //://////////////////////////////////////////////////////://
    //:SC[VK04_DECLARE_ASSERT_EXIST-(edit|paste|help)](BELOW)

//:EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:OPEN_CL_ENUMERATIONS://
//:FILESCOPE_WHATEVERS:FWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFW://

    //://////////////0xAARRGGBB
    #define ALT_555 (0x55555555)

    U64 ins(gar_byt_01) = ALT_555;
    char file_scope_arr[256]={0};
    U64 ins(gar_byt_02) = ALT_555;
    
    //|RISK: The host side type ‘cl_uint’ is guaranteed to be|//
    //|the same format as the device side type ‘uint’.       |//
    //|Depending of the platform,‘unsigned int’ may be       |//
    //|something different.                                  |//
    //|community.khronos.org/t/unsigned-int-or-cl-uint/2200  |//

    #define VOD void //://///////////////////////////////////://
  
    //:PLATFORM_ID: cl_platform_id[ ] :::::::::::::::::::::::://
    #define PID_CAP ( 10 ) //:///////////////////////////////://
    VOD* g_2(plat_id, pid_arr)  [ PID_CAP ]={0}; //:arr_dat
    U32  g_2(plat_id, pid_num) =(    0    );     //:arr_num
    int  g_2(plat_id, pid_cap) =( PID_CAP );     //:arr_cap
    int  g_2(plat_id, pid_dex) =( 0  -  1 );     //:sel_dex
    #undef PID_CAP //:///////////////////////////////////////://

    //:DEVICE_ID:     cl_device_id[ ] :::::::::::::::::::::::://
    #define DEV_CAP ( 10 ) //:///////////////////////////////://
    VOD* g_2(devi_id,dev_arr) [ DEV_CAP ]={0}; //:arr_dat
    U32  g_2(devi_id,dev_num)=(    0    );     //:arr_num
    int  g_2(devi_id,dev_cap)=( DEV_CAP );     //:arr_cap
    int  g_2(devi_id,dev_dex)=( 0  -  1 );     //:sel_dex
    #undef DEV_CAP //:///////////////////////////////////////://
    
    //:CONTEXT:cl_context+cl_context_properties :::::::::::::://
    VOD* g_2(con_com,context)=( NIL ); //:cl_context
    VOD* g_2(con_com,con_pro)=( NIL ); //:cl_context_properties
   
    #undef  VOD //://////////////////////////////////////////://
           

//:FWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFWFW:FILESCOPE_WHATEVERS://
//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
    void EII(SRC_OPENCL_SETUP_main)(void){ //:///////////////://

        //:T1:Teir_1:Grab Teir 1 OpenCL Functions:
        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://

        #define g_p_a FUN(SRC_NATIVE_CALLWRAP_GetProcAddress) //
        #define G_P_A( a ) g_p_a( "dll_gra",  a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!ins( a )){ H( #a"[IS_NULL]" ); };
        #define     N( a ) n( a ) //:////////////////////////://

            #define G0( a ) G( a )
            #define G1( a ) (TYP(F_01))G( a )
            #define G2( a ) (TYP(F_02))G( a )

            //:Unlike openGL code, I don't think we need
            //:to separate into teir1 and teir2 functions,
            //:but just in case, leave this code here for
            //:now.

            //////  //:MACROS:
            //////  //:     G: Calls GetProcAddress
            //////  //:     N: Null  Checks Function Pointer
            //////  
            //////  //:SEE[ GPA_POINTERS_ARE_SPECIAL ]
            //////  ins(wclGetProcAddress   )=(
            //////      (TYP(GPA_FUN))G( wclGetProcAddress    ));;
            //////  
            //////  ins(wclGetCurrentContext)=G0( wclGetCurrentContext);
            //////  ins(wclCreateContext    )=G1( wclCreateContext    );
            //////  ins(wclMakeCurrent      )=G2( wclMakeCurrent      );
            //////  
            //////  N(wclGetProcAddress   ); //:NULL_CHECKS
            //////  N(wclGetCurrentContext); //:NULL_CHECKS
            //////  N(wclCreateContext    ); //:NULL_CHECKS
            //////  N(wclMakeCurrent      ); //:NULL_CHECKS

            #undef G0
            #undef G1
            #undef G2

        #undef  g_p_a  //:///////////////////////////////////://
        #undef  G_P_A  //:///////////////////////////////////://
        #undef      G  //:///////////////////////////////////://
        #undef      n  //:///////////////////////////////////://
        #undef      N  //:///////////////////////////////////://

        //:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
        
        //[ TODO: Any setup code that might be needed between]//
        //[       Teir_1 and Teir_2 function pointer fetch.  ]//

        //:T2:Teir_2:( 2nd_tier_opencl_function_pointers )
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://
        //://////////////////////////////////////////////////://
        #define g_p_a fun(GetAnyCLFuncAddress)       //://///://
        #define G_P_A( a ) g_p_a(             a )    //://///://
        #define     G( a ) G_P_A(            #a )    //://///://
        #define     n( a ) if(!INS( a )){ H( #a"[IS_NULL]" ); };
        #define     o( a ) if( INS( a )){ D( "[OK_YEAH]"#a ); };
        #define     N( a ) n( a ) //:////////////////////////://

            //:G_N:Get_function_pointer_AND_check_for_null.
            //://////////////////////////////////////////////://
            #define G_N( a ) INS( a )=G( a );N( a ); o( a );

            #define G0( a ) INS( a )=(TYP(F_00))G( a ) _ _ _ _ _
            #define G1( a ) INS( a )=(TYP(F_01))G( a ) _ _ _ _ _
            #define G2( a ) INS( a )=(TYP(F_02))G( a ) _ _ _ _ _
            #define G3( a ) INS( a )=(TYP(F_03))G( a ) _ _ _ _ _
            #define G4( a ) INS( a )=(TYP(F_04))G( a ) _ _ _ _ _
            #define G5( a ) INS( a )=(TYP(F_05))G( a ) _ _ _ _ _
            #define G6( a ) INS( a )=(TYP(F_06))G( a ) _ _ _ _ _
            #define G7( a ) INS( a )=(TYP(F_07))G( a ) _ _ _ _ _
            #define G8( a ) INS( a )=(TYP(F_08))G( a ) _ _ _ _ _
            #define G9( a ) INS( a )=(TYP(F_09))G( a ) _ _ _ _ _

            #define G_0( a ) G0( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_1( a ) G1( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_2( a ) G2( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_3( a ) G3( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_4( a ) G4( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_5( a ) G5( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_6( a ) G6( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_7( a ) G7( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_8( a ) G8( a );N( a ); o( a ); _ _ _ _ _ _
            #define G_9( a ) G9( a );N( a ); o( a ); _ _ _ _ _ _

//:----------------------------------------------------------://
#define MACRO_01 clGetExtensionFunctionAddressForPlatform //:://
//:----------------------------------------------------------://

                    G_1( clFinish                  ); //| 01 |//
                    G_1( clFlush                   ); //| 02 |//
                    G_1( clReleaseKernel           ); //| 03 |//
                    G_1( clReleaseProgram          ); //| 04 |//
                    G_1( clReleaseMemObject        ); //| 05 |//
                    G_1( clReleaseCommandQueue     ); //| 06 |//
                    G_1( clReleaseContext          ); //| 07 |//
                    G_2( clWaitForEvents           ); //| 08 |//
                    G_2( MACRO_01                  ); //| 09 |//
                    G_3( clGetPlatformIDs          ); //| 10 |//
                    G_3( clCreateKernel            ); //| 11 |//
                    G_4( clCreateCommandQueue      ); //| 12 |//
                    G_4( clSetKernelArg            ); //| 13 |//
                    G_5( clCreateBuffer            ); //| 14 |//
                    G_5( clCreateProgramWithSource ); //| 15 |//
                    G_5( clGetDeviceIDs            ); //| 16 |//
                    G_5( clGetDeviceInfo           ); //| 17 |//
                    G_5( clGetContextInfo          ); //| 18 |//
                    G_5( clGetCommandQueueInfo     ); //| 19 |//
                    G_5( clGetKernelInfo           ); //| 20 |//
                    G_5( clGetPlatformInfo         ); //| 21 |//
                    G_6( clGetProgramBuildInfo     ); //| 22 |//
                    G_6( clBuildProgram            ); //| 23 |//
                    G_6( clCreateContext           ); //| 24 |//
                    G_9( clEnqueueReadBuffer       ); //| 25 |//
                    G_9( clEnqueueNDRangeKernel    ); //| 26 |//
                    G_9( clEnqueueWriteBuffer      ); //| 27 |//

//:----------------------------------------------------------://
#undef MACRO_01 //://////////////////////////////////////////://
//:----------------------------------------------------------://

            #undef   G0 //://////////////////////////////////://
            #undef   G1 //://////////////////////////////////://
            #undef   G2 //://////////////////////////////////://
            #undef   G3 //://////////////////////////////////://
            #undef   G4 //://////////////////////////////////://
            #undef   G5 //://////////////////////////////////://
            #undef   G6 //://////////////////////////////////://
            #undef   G7 //://////////////////////////////////://
            #undef   G8 //://////////////////////////////////://
            #undef   G9 //://////////////////////////////////://
                        //://////////////////////////////////://
            #undef  G_0 //://////////////////////////////////://
            #undef  G_1 //://////////////////////////////////://
            #undef  G_2 //://////////////////////////////////://
            #undef  G_3 //://////////////////////////////////://
            #undef  G_4 //://////////////////////////////////://
            #undef  G_5 //://////////////////////////////////://
            #undef  G_6 //://////////////////////////////////://
            #undef  G_7 //://////////////////////////////////://
            #undef  G_8 //://////////////////////////////////://
            #undef  G_9 //://////////////////////////////////://

            #undef  G_N //://////////////////////////////////://
            //://////////////////////////////////////////////://

        #undef  g_p_a   //://////////////////////////////////://
        #undef  G_P_A   //://////////////////////////////////://
        #undef      G   //://////////////////////////////////://
        #undef      n   //://////////////////////////////////://
        #undef      o   //://////////////////////////////////://
        #undef      N   //://////////////////////////////////://
        //://////////////////////////////////////////////////://
        //:T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2T2://

    //:======================================================://
    //:ABOVE:GrabbinThemFunctionPointers:
    //:BELOW:COG_CreateContext_OpenComputeLanguage:
    //:======================================================://



        { //:SCOPE: GET_PLATFORM_IDS:
        #define VOD void //://///////////////////////////////://
        extern VOD* g_2(plat_id, pid_arr)[10]; //:arr_dat
        extern U32  g_2(plat_id, pid_num); //:arr_num
        extern int  g_2(plat_id, pid_cap); //:arr_cap
        extern int  g_2(plat_id, pid_dex); //:sel_dex
        #undef  VOD //://////////////////////////////////////://

            #define ARR  g_2(plat_id, pid_arr) //:///////////://
            #define NUM  g_2(plat_id, pid_num) //:///////////://
            #define CAP  g_2(plat_id, pid_cap) //:///////////://
            #define DEX  g_2(plat_id, pid_dex) //:///////////://

            int RET(clGetPlatformIDs) = (0-333);

            //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
            //://////////////////////////////////////////////://
            //:Before We call clGetPlatformIDs, make sure it is
            //:not null. Let's not do this on all calls. Just
            //:the first one as a sanity check on our function
            //:pointer fetching macros:
            //://////////////////////////////////////////////://
            if(NIL==INS(clGetPlatformIDs)){ H("[NIL:CGPID]");};
            TYP(F_03) var(fun)=(
                (TYP(F_03))
                FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
                    "dll_com"
                ,   "clGetPlatformIDs"
                )
            );;
            if( var(fun) != INS(clGetPlatformIDs)){
                H("[FAIL:DIFF:FUNCTION_POINTER]");
            }else{
                D("[PASS:SAME:FUNCTION_POINTER]");
            };;
            //://////////////////////////////////////////////://

            RET(clGetPlatformIDs)=(U32)(U64)
            INS(clGetPlatformIDs)(	
                (void*)(U32)0//: num_entries   01 ://
            ,         NIL         //: platforms     02 ://
            ,      &( NUM )       //: num_platforms 03 ://
            );;       
                
            //:CR:Check_Return:CheckReturnCode:
            //:CRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCR://
            if( RET(clGetPlatformIDs) != 0 /**CL_SUCCESS**/ ){
                D("[WHAT_THE_FUCKING_HELL]");
                printf("[RET(clGetPlatformIDs):%u\n",
                         RET(clGetPlatformIDs) );;

                if( 0xFFFFFC17 == (U32)RET(clGetPlatformIDs) ){
                    D("[0xFFFFFC17:CL_PLATFORM_NOT_FOUND_KHR]");
                    D("[FIX:Load_A_Different:OpenCL*.dll]");
                };;

                H("[WHAT_THE_FUCKING_HELL]");
            }else{
                D("[CL_SUCCES]");
            };;
            //:CRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCRCR://
            
            //:Truncate capacity if needed:
            printf( "#1:g_2(plat_id, pid_num)::%d\n",
                        g_2(plat_id, pid_num) );; 
            if((int)NUM >      CAP ){
                    NUM = (U32)CAP ;   
                D("[WARN:RoomForPlatformsIs:NOT_ENOUGH]");
            }else{
                D("[PASS:RoomForPlatformsIs:ENOUGHROOM]");
            };;

            //:Actually get platforms:
            INS(clGetPlatformIDs)(
            /**/ (void*)(U64) NUM       //: num_entries   01 ://
            ,    (void*)(U64) ARR       //: platforms     02 ://
            ,    (void*)(U64) NIL       //: num_platforms 03 ://
            );;
            printf( "#2:g_2(plat_id, pid_num)::%d\n",
                        g_2(plat_id, pid_num) );; 
            //|______________________________________________|//

            //:TODO: More detailed logic on platform
            //:      selection than simply using the
            //:      first (zeroth) one.
            DEX=( 0 ); 

            #undef  ARR  //:////  g_2(plat_id, pid_arr)  ////://
            #undef  NUM  //:////  g_2(plat_id, pid_num)  ////://
            #undef  CAP  //:////  g_2(plat_id, pid_cap)  ////://
            #undef  DEX  //:////  g_2(plat_id, pid_dex)  ////://
        } //:SCOPE: GET_PLATFORM_IDS:
        { //:SCOPE: GET_PLATFORM_VERSION:

            D("[LetsGetPlatformInfo...]");
    

            #define WILD_WEST_CAST (void*)(U64) //://////////://

            int siz=( 0 );

            //:Selected platform handle:
            void* han_pla=(
                g_2(plat_id, pid_arr)[
                g_2(plat_id, pid_dex)]
            );;

            INS(clGetPlatformInfo)(
                WILD_WEST_CAST  han_pla
            ,   WILD_WEST_CAST  INS(cl_platform_version)
            ,   WILD_WEST_CAST  0
            ,   WILD_WEST_CAST  NIL
            ,   WILD_WEST_CAST  &siz
            );;

            //:platform_version
           //:  char pid_ver[256]={0}; 
           //:  if( siz <= 0 ){ H("[WTF_SIZE]"); };
            if( siz > (256-1) ){
                D("[NOT_ENOUGH_ROOM_TO_GET_STRING]");
            }else{
                D("[ENOUGH_ROOM_TO_GET_STRING]");

               printf( "siz:%d\n", siz );

              // char* platform_version =( 
              //     malloc(256) 
              // );

              //  char* platform_version=(
              //      calloc(1,256)
              //  );;
                
                #error TODO: Fix this mess.
                #error figure out why declaring random variable
                #error before calling this function makes the
                #error string get populated.
                #error Add the actual function prototype to
                #error this file to make sure you are calling
                #error function correctly and read up on valgrind.

              // char str[25];
              // str[0]='x';
                //U32 guard_byte = ALT_555;
               // if( whatever ){ /**NOOP**/ };

               // char* platform_version=NIL; //: ( str );

                //char platform_version[256]={0};

                ///char platform_version[256]="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
            
                INS(clGetPlatformInfo)(
                    WILD_WEST_CAST  han_pla
                ,   WILD_WEST_CAST  INS(cl_platform_version)
                ,   WILD_WEST_CAST  siz  

              //  ,   WILD_WEST_CAST  &(platform_version[0])

                ,   WILD_WEST_CAST  file_scope_arr
               // ,   WILD_WEST_CAST  &(str[0])


                ,   WILD_WEST_CAST  NIL
                );; 
            
                
                printf("[pid_ver/platform_version]:%s\n"
                        ,file_scope_arr
                );;
             //  printf("[pid_ver/platform_version]:%s\n"
             //          ,&(platform_version[0])
             //  );;

                fflush(stdout);

               // if( guard_byte != ALT_555 ){
               //     H("gottouched]");
               // };; 
                if( ins(gar_byt_01) != ALT_555 ){
                    H("gottouched]");
                };; 
                if( ins(gar_byt_02) != ALT_555 ){
                    H("gottouched]");
                };; 
            
                //free( platform_version );
            };;



            #undef  WILD_WEST_CAST //:///////////////////////://

//       size_t siz = 0;
//       CLEB_AF_Success( "[ERROR:GPI#1]",
//           CLEB.clGetPlatformInfo(
//           /**/PID->arr[P] //:<---1st plaform
//           ,   CL_PLATFORM_VERSION //:param_name
//           ,   0     //:param_value_size
//           ,   NULL  //:param_value
//           ,   &siz  //:param_value_size_ret
//           )
//       );;CLEB_PV_size_t("[siz]",siz);
//       char* platform_version =( malloc(siz) );
//       CLEB_AF_Success( "[ERROR:GPI#2]",
//           CLEB.clGetPlatformInfo(
//           /**/PID->arr[P]
//           ,   CL_PLATFORM_VERSION
//           ,   siz
//           ,   platform_version
//           ,   NULL
//           )
//       );;CLEB_PV_STR("[platform_version]"
//                       ,platform_version );
//
//       free( platform_version );

        } //:SCOPE:GET_PLATFORM_VERSION
////    { //:SCOPE: clGetDeviceIDs ::::::::::::::::::::::::::://
////    //://////////////////////////////////////////////////://
////    #define VOD void //://///////////////////////////////://
////    extern VOD* g_2(devi_id, dev_arr)[10]; //:arr_dat
////    extern U32  g_2(devi_id, dev_num);     //:arr_num
////    extern int  g_2(devi_id, dev_cap);     //:arr_cap
////    extern int  g_2(devi_id, dev_dex);     //:sel_dex
////    #undef  VOD //://////////////////////////////////////://
////        
////        #define dev_ARR  g_2(devi_id, dev_arr) //:///////://
////        #define dev_NUM  g_2(devi_id, dev_num) //:///////://
////        #define dev_CAP  g_2(devi_id, dev_cap) //:///////://
////        #define dev_DEX  g_2(devi_id, dev_dex) //:///////://
////
////        int err=(0 - 444);
////        U32 typ_gpu=( INS(cl_device_type_gpu) );
////       
////        //:Get target platform handle:
////        //:han_pla == pid_arr[ pid_dex ]
////        //:platform_handle=platform_array[ selected_index ]
////        void* han_pla=(
////            g_2(plat_id, pid_arr)[
////            g_2(plat_id, pid_dex)]
////        );;
////
////        if(NIL==han_pla){  H("[PlatformHandleIsNull]"); };
////        
////        err=(int)(U64)INS(clGetDeviceIDs)(
////        /**/(void*)(U64)  han_pla    //:platform
////        ,   (void*)(U64)  typ_gpu    //:device_type
////        ,   (void*)(U64)  0          //:num_entries
////        ,   (void*)(U64)  NIL        //:devices
////        ,   (void*)(U64)&(dev_NUM)   //:num_devices
////        );;
////
////        //:Does pre allocated array have enough room
////        //:for all devices?
////        if( err != 0 ){ 
////            printf("[err]:%d\n", err );
////            printf("[err]:%0x\n", err );
////            if( err == (0-32)/**CL_INVALID_PLATFORM**/){
////                D("[(0-32):0xFFFFFFE0:INVALID_PLATFORM]");
////            };;
////            H("[2020_04_30:1238PM-A]");
////        };;
////
////        if( dev_NUM <= 0 ){ H("[NO_DEVICES]"); };
////        if( (int)dev_NUM > (int)dev_CAP ){
////            dev_NUM = (U32)dev_CAP;
////            D("[WARNING:Not_Enough_Slots:DEVICES]");
////        }else{
////            D("[OK:ENOUGH_ROOM_FOR_ALL_DEVICES]");
////        };;
////
////        printf("[NUM_DEVICES:%d\n",dev_NUM);
////        
////        err=(int)(U64)INS(clGetDeviceIDs)(
////        /**/(void*)(U64) han_pla      //:platform
////        ,   (void*)(U64) typ_gpu      //:device_type
////        ,   (void*)(U64) dev_NUM      //:num_entries
////        ,   (void*)(U64) dev_ARR      //:devices
////        ,   (void*)(U64) NIL          //:num_devices
////        );;
////
////        if( err != 0 ){ H("[2020_04_30:1238PM-B]");};
////
////        dev_DEX=( 0 );
////        D("[TODO: Logic for selecting device index]");
////
////        #undef  dev_ARR  //:    g_2(plat_id, pid_arr)    :// 
////        #undef  dev_NUM  //:    g_2(plat_id, pid_num)    :// 
////        #undef  dev_CAP  //:    g_2(plat_id, pid_cap)    :// 
////        #undef  dev_DEX  //:    g_2(plat_id, pid_dex)    :// 
////
////    //://////////////////////////////////////////////////://
////    }//:SCOPE: clGetDeviceIDs  ::::::::::::::::::::::::::://



    }    E_F(SRC_OPENCL_SETUP_main)  //://///////////////////://
//[MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:MAIN]//


//:AG:Any_CL:(BELOW):¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:                                                          ://
//: Decided to make a "GetAnyCLFuncAddress" to mirror        ://
//: the Open_Graphics_Library function of similiar name:     ://
//: "GetAnyGLFunctionAddress". Uncertain if this will        ://
//: be a needed function.                                    ://
//:                                                          ://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
    TYP(FUN) fun(GetAnyCLFuncAddress)( //:///////////////////://
        const char* ARG(fun_nam) //:name_of_open_cl_function
    ){
        
        TYP(FUN) 
        RET(FUN)=( FUN(SRC_NATIVE_CALLWRAP_GetProcAddress)(
            "dll_com" //: dll_nam: "dll_com"==OpenCL*.DLL
        ,ARG(fun_nam) //: dll_com:dll_compute
        ));;

        return( RET(FUN) );

    }E_F(GetAnyCLFuncAddress)//://///////////////////////////://
//:AGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAG://
//:AG:Any_CL:(ABOVE):________________________________________://


//|¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//
#undef     lib                                        //| 01 |//
#undef     LIB                                        //| 02 |//
//://---------                                        //::--:://
#undef     gm2                                        //| 03 |//
#undef     GM2                                        //| 04 |//
#undef     gm3                                        //| 05 |//
#undef     GM3                                        //| 06 |//
//://---------                                        //::--:://
#undef     INS                                        //| 07 |//
#undef     TYP                                        //| 08 |//
#undef     EII                                        //| 09 |//
#undef     MEM                                        //| 10 |//
#undef     FUN                                        //| 11 |//
//://---------                                        //::--:://
#undef     BRA                                        //| 12 |//
#undef     SUB                                        //| 13 |//
//://---------                                        //::--:://
#undef     ARG                                        //| 14 |//
#undef     RET                                        //| 15 |//
#undef     VAR                                        //| 16 |//
//://---------                                        //::--:://
#undef     var                                        //| 17 |//
#undef     eii                                        //| 18 |//
#undef     mem                                        //| 19 |//
#undef     ins                                        //| 20 |//
#undef     fun                                        //| 21 |//
#undef     typ                                        //| 22 |//
#undef     arg                                        //| 23 |//
#undef     ret                                        //| 24 |//
#undef     bra                                        //| 25 |//
#undef     sub                                        //| 26 |//
#undef     obj                                        //| 27 |//
#undef     poi                                        //| 28 |//
#undef     siz                                        //| 29 |//
#undef     num                                        //| 30 |//
#undef     arr                                        //| 31 |//
#undef     dex                                        //| 32 |//
//://---------                                        //::--:://
#undef   GLO_1                                        //| 33 |//
#undef   GLO_2                                        //| 34 |//
#undef   GLO_3                                        //| 35 |//
#undef     g_1                                        //| 36 |//
#undef     g_2                                        //| 37 |//
#undef     g_3                                        //| 38 |//
//://---------                                        //::--:://
#undef   VAR_1                                        //| 39 |//
#undef   VAR_2                                        //| 40 |//
#undef   VAR_3                                        //| 41 |//
#undef     v_1                                        //| 42 |//
#undef     v_2                                        //| 43 |//
#undef     v_3                                        //| 44 |//
//://---------                                        //::--:://
#undef  termin                                        //| 45 |//
#undef     NIL                                        //| 46 |//
#undef     E_S                                        //| 47 |//
#undef     E_F                                        //| 48 |//
#undef       s                                        //| 49 |//
#undef       S                                        //| 50 |//
#undef       _                                        //| 51 |//
#undef       H                                        //| 52 |//
#undef       D                                        //| 53 |//
//://---------                                        //::--:://
#undef     U32                                        //| 54 |//
#undef     I32                                        //| 55 |//
#undef     U64                                        //| 56 |//
#undef     I64                                        //| 57 |//
//:BANNED_MACROS:SEE[MACRO_BAN_ABOUT]:::::::::::::::////| == |//
#if defined( MSG ) || defined( msg )                  //| == |//
    #error DID_WINDOWS_DOT_H_GET_INCLUDED_SOMEHOW?    //| == |//
#endif                                                //| == |//
#if defined( PTR ) || defined( ptr )                  //| == |//
    #error WE_USE:POI:for_pointer:NOT:PTR             //| == |//
#endif                                                //| == |//
#if defined( SIZ )                                    //| == |//
    #error   SIZ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( NUM )                                    //| == |//
    #error   NUM(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( ARR )                                    //| == |//
    #error   ARR(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( OBJ )                                    //| == |//
    #error   OBJ(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( POI )                                    //| == |//
    #error   POI(UPPERCASE):Used_As_Local_Macro       //| == |//
#endif                                                //| == |//
#if defined( v_1 ) || defined( VAR_1 )                //| == |//
    //:I found a need for this. Allow it.:::::::::::////| == |//
#endif                                                //| == |//
#if defined( f_1 ) || defined( F_1 )                  //| == |//
    #error USE: g_1,g_3,g_3,g_4 (NOT:F_)              //| == |//
#endif                                                //| == |//
//|_________|V4_MEGAHEADER:DATE_OF_REVISION:2020_04_29_0937AM|//

//}
//++++EXE_CAT:ABOVE+//:./SRC/OPENCL/SETUP/main._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./MAIN.C11


#define lib MACRO_project_prefix_HIDDEN  //: Private  //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //: Public   //: 02 ://
#define GM1( a , b )      a## _ ##b      //: GLUEMAC  //: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //: GLUEMAC  //: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 
#define EII(  nam  ) K_2( LIB ,EII, nam )//:INIT_FUNC //: 12 :// 
#define ASS   assert 

////////////////////////////////////////////////////////////////
int  INS(        AT_END_OF_CHAIN ) = ( 0 );
////////////////////////////////////////////////////////////////

int main( void ){

    printf("[HELLO_WORLD]\n");

    ////////////////////////////////////////////////////////////

    #if( SRC_MAINLOOP_LOOPTABLE >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        EII(SRC_MAINLOOP_looptable)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    ////////////////////////////////////////////////////////////

    #if( SRC_NATIVE_CALLWRAP_LOADLIBRARY >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        //:No code for this, just a stub. All logic
        //:is inside "GetProcAddress._"
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    ////////////////////////////////////////////////////////////

    #if( SRC_NATIVE_CALLWRAP_GETPROCADDRESS >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        EII(SRC_NATIVE_CALLWRAP_getprocaddress)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    ////////////////////////////////////////////////////////////
    
    #if(    SRC_NATIVE_PING  >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        FUN(SRC_NATIVE_ping)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif
    
    ////////////////////////////////////////////////////////////
    
    #if(    SRC_NATIVE_WINDOW_CREATION  >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        FUN(SRC_NATIVE_WINDOW_creation)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    //://////////////////////////////////////////////////////://

        //:SETUP_LIBRARIES:
    
/////   //://////////////////////////////////////////////////://
/////   //:VULKAN:
/////   #if(    SRC_VULKAN_SETUP_MAIN  >= 1 )
/////       ASS( INS( AT_END_OF_CHAIN ) <= 0 );
/////       EII(SRC_VULKAN_SETUP_main)();
/////   #else
/////       INS(AT_END_OF_CHAIN)++;
/////   #endif
        //://////////////////////////////////////////////////://
        //:OPENGL:
        #if(    SRC_OPENGL_SETUP_MAIN  >= 1 )
            ASS( INS( AT_END_OF_CHAIN ) <= 0 );
            EII(SRC_OPENGL_SETUP_main)();
        #else
            INS(AT_END_OF_CHAIN)++;
        #endif 
        //://////////////////////////////////////////////////://
        //:OPENCL:
        #if(    SRC_OPENCL_SETUP_MAIN  >= 1 )
            ASS( INS( AT_END_OF_CHAIN ) <= 0 );
            EII(SRC_OPENCL_SETUP_main)();
        #else
            INS(AT_END_OF_CHAIN)++;
        #endif
        //://////////////////////////////////////////////////://

    //://////////////////////////////////////////////////////://




    //:ML:Main_Loop: (AKA: LOOPTABLE):
    //:MLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLML://
    #if( SRC_MAINLOOP_LOOPTABLE >= 1 )
        
        printf("\n\n\n");
        printf("[Entering:MainLoop:USE[CTRL+V]TO[EXIT_EXE]]\n");
        printf("\n\n\n");
        fflush(stdout);
        
        //: Loop_Forever_Because_This_Is_The_Main_Game_Loop
        //: SRC/MAINLOOP/looptable._ :: FUN(Loop):
        FUN(Loop)(/**void**/);

    #endif
    //:MLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLML://



}


#undef  lib ////////////////////////////////////////////: 01 ://
#undef  LIB ////////////////////////////////////////////: 02 ://
#undef  GM1 ////////////////////////////////////////////: 03 ://
#undef  GM2 ////////////////////////////////////////////: 04 ://
#undef  K_1 ////////////////////////////////////////////: 05 ://
#undef  K_2 ////////////////////////////////////////////: 06 ://                                   
#undef  MAK ////////////////////////////////////////////: 07 ://   
#undef  TYP ////////////////////////////////////////////: 08 ://   
#undef  INS ////////////////////////////////////////////: 09 ://   
#undef  FUN ////////////////////////////////////////////: 10 ://
#undef  EXA ////////////////////////////////////////////: 11 ://
#undef  EII ////////////////////////////////////////////: 12 ://
#undef  ASS

//}
//++++EXE_CAT:ABOVE+//:./MAIN.C11
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/CHAIN_FILE.UNDEF._



    //:A:About:
    //:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA://
    //:     Undefine Chain Files:                            ://
    //:                                                      ://
    //:     There is no "CHAIN_FILE.DEFINE._"                ://
    //:     File because those macros are added              ://
    //:     when different files are concatted               ://
    //:     together in the building bash script.            ://
    //:                                                      ://
    //:     Try to undefine in the exact same                ://
    //:     order as they were defined.                      ://
    //:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA://

    //:ML:MainLoop:
    //:MLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLML://

        //:looptable._
        #undef SRC_MAINLOOP_LOOPTABLE              

    //:MLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLML://
    //:N:Native:
    //:NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN://

        //:LoadLibrary._
        #undef SRC_NATIVE_CALLWRAP_LOADLIBRARY  

        //:GetProcAddress._
        #undef SRC_NATIVE_CALLWRAP_GETPROCADDRESS 

        //:ping:
        #undef SRC_NATIVE_PING

        //:creation._
        #undef SRC_NATIVE_WINDOW_CREATION
    
    //:NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN://
    //:AS:API_Setup:
    //:ASASASASASASASASASASASASASASASASASASASASASASASASASASAS://

        #undef SRC_OPENGL_SETUP_MAIN
        #undef SRC_OPENCL_SETUP_MAIN
        #undef SRC_VULKAN_SETUP_MAIN

    //:ASASASASASASASASASASASASASASASASASASASASASASASASASASAS://

//}
//++++EXE_CAT:ABOVE+//:./SRC/CHAIN_FILE.UNDEF._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//{//+EXE_CAT:BELOW+//:./SRC/PROJECT_PREFIX.UNDEF._


#undef  MACRO_project_prefix_HIDDEN   
#undef  MACRO_project_prefix_VISIBLE  


//}
//++++EXE_CAT:ABOVE+//:./SRC/PROJECT_PREFIX.UNDEF._
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
