//:Dependencies:
#include <stdio.h> //:for: printf(...)
#include <assert.h> //:define NDEBUG to turn off assertions.


//:Not a fan of windows header injecting macros all over
//:the place into my code. We will use my "DLLL" hack instead.
////////////////////////////////////////////////////////////////
//: #include <windows.h> //:GetProcAddress, LoadLibrary

    //:Demo file: "V:\VG\03\W32\DLLL\DEMO\DLLL.C11"
    //:            Has the imports in this order:
    #include "V:/VG/03/W32/DLLL/DLLL.COMSET"
    #include "V:/VG/03/W32/DLLL/TARG/W10.X64"
    #include "V:/VG/03/W32/DLLL/DLLL.H"

    //:Access to:
    //:     DLLL_LoadLibraryA
    //:     DLLL_GetProcAddress

////////////////////////////////////////////////////////////////


#define MACRO_project_prefix_HIDDEN  vg04  
#define MACRO_project_prefix_VISIBLE VG04 

//:These macros are used to give the prefix "vg04" to
//:"private" data and "VG04" to public data.
//:
//: HIDDEN  == private
//: VISIBLE == public
//:
//:
//: Use the words "HIDDEN" and "VISIBLE" so that
//: can abbreviate as: "V" and "H" or "VIS" and "HID".
//:

#define lib MACRO_project_prefix_HIDDEN  //:Private   //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //:Public    //: 02 ://
#define GM1( a , b )      a## _ ##b      //:GLUEMAC_01//: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //:GLUEMAC_02//: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 
#define VAR(  nam  ) GM2( VAR   ,   nam )//:Local_Var //: 12 ://

    #define  T typedef ///////////////////////////////////////// 
    #define  V void* /////////////////////////////////////////// 
    #define  a void* /////////////////////////////////////////// 
    #define  b void* /////////////////////////////////////////// 
    #define  c void* /////////////////////////////////////////// 
    #define  d void* /////////////////////////////////////////// 
    #define  e void* /////////////////////////////////////////// 

    T V (*TYP(F_00) )( void );
    T V (*TYP(F_01) )( a                                      );
    T V (*TYP(F_02) )( a,a                                    );
    T V (*TYP(F_03) )( a,a,a                                  );
    T V (*TYP(F_04) )( a,a,a,a                                );
    T V (*TYP(F_05) )( a,a,a,a,b                              );
    T V (*TYP(F_06) )( a,a,a,a,b,b                            );
    T V (*TYP(F_07) )( a,a,a,a,b,b,b                          );
    T V (*TYP(F_08) )( a,a,a,a,b,b,b,b                        );
    T V (*TYP(F_09) )( a,a,a,a,b,b,b,b,c                      );
    T V (*TYP(F_10) )( a,a,a,a,b,b,b,b,c,c                    );
    T V (*TYP(F_11) )( a,a,a,a,b,b,b,b,c,c,c                  );
    T V (*TYP(F_12) )( a,a,a,a,b,b,b,b,c,c,c,c                );
    T V (*TYP(F_13) )( a,a,a,a,b,b,b,b,c,c,c,c,d              );
    T V (*TYP(F_14) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d            );
    T V (*TYP(F_15) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d          );
    T V (*TYP(F_16) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d        );
    T V (*TYP(F_17) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e      );
    T V (*TYP(F_18) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e    );
    T V (*TYP(F_19) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e  );
    T V (*TYP(F_20) )( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e,e);

    #undef   T ///////////////////////////////////////////////// 
    #undef   V ///////////////////////////////////////////////// 
    #undef   a ///////////////////////////////////////////////// 
    #undef   b ///////////////////////////////////////////////// 
    #undef   c ///////////////////////////////////////////////// 
    #undef   d ///////////////////////////////////////////////// 
    #undef   e ///////////////////////////////////////////////// 

#undef  lib ////////////////////////////////////////////: 01 ://
#undef  LIB ////////////////////////////////////////////: 02 ://
#undef  GM1 ////////////////////////////////////////////: 03 ://
#undef  GM2 ////////////////////////////////////////////: 04 ://
#undef  K_1 ////////////////////////////////////////////: 05 ://
#undef  K_2 ////////////////////////////////////////////: 06 ://                                   
#undef  MAK ////////////////////////////////////////////: 07 ://   
#undef  TYP ////////////////////////////////////////////: 08 ://   
#undef  INS ////////////////////////////////////////////: 09 ://   
#undef  FUN ////////////////////////////////////////////: 10 ://
#undef  EXA ////////////////////////////////////////////: 11 ://
#undef  VAR ////////////////////////////////////////////: 12 ://

//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
#define lib MACRO_project_prefix_HIDDEN  // Private   //| 01 |//
#define LIB MACRO_project_prefix_VISIBLE // Public    //| 02 |//
#define GM1( a , b )      a## _ ##b      // GLUEMAC_01//| 03 |//
#define GM2( a , b ) GM1( a   ,   b )    // GLUEMAC_02//| 04 |//
#define K_1( a,b,c )      a## _ ##b## _ ##c  // KIND  //| 05 |//
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )// KIND  //| 06 |//                            
#define TYP(  nam  ) K_2( LIB ,TYP, nam )// TYP:TYPE  //| 07 |//   
#define INS(  nam  ) K_2( LIB ,INS, nam )// INS:INST  //| 08 |//   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )// FUN:FUNC  //| 09 |// 
#define EII(  nam  ) K_2( LIB, EII, nam )// SEE[EII]  //| 10 |//
#define MEM(  nam  ) K_2( LIB ,MEM, nam )// Member    //| 11 |//
#define ARG(  nam  ) GM2( ARG   ,   nam )// Argument  //| 12 |//
#define VAR(  nam  ) GM2( VAR   ,   nam )// Local_Var //| 13 |//
#define RET(  nam  ) GM2( RET   ,   nam )// RET___Var //| 14 |//                                            
#define fun(  nam  ) GM2( f_2020_04_24_0240AM , nam ) //| 15 |// 
#define ins(  nam  ) GM2( i_2020_04_24_0240PM , nam ) //| 16 |//
#define  H    fun( Halt )                             //| 17 |//
#define  D    fun( Dmsg ) // DebugPrint/DebugMessage  //| 18 |//
#define NIL ((void*)0)                                //| 19 |//
//|__________________________________________________________|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_MAINLOOP_LOOPTABLE ( 6437 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC_MAINLOOP_LOOPTABLE:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC_MAINLOOP_LOOPTABLE:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://
//:GLOBALS: GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG://

    //:HACK:Private copy so stub functions can reference:
    int ins(game_time_copy_for_stub_functions)=0;


//:GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG :GLOBALS://
//:STUB_FUNCTION:  SFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSF://

    //:I don't want the STUB_FUNCTION to be completely
    //:obfuscated as a private function. But use "hidden"
    //:access to communicate it is not public.
    #define STUB_FUNCTION( nam ) K_2(lib,STUB_FUNCTION,nam)
    #define GAM_TIM ins( game_time_copy_for_stub_functions )
       
        static void 
        STUB_FUNCTION(nat_win)( void ){
            if( GAM_TIM < 3 ){
                printf("[STUB_FUNCTION:nat_win]\n");
            };;
            if( GAM_TIM == 64){
                printf("[RUNNING_WITHOUT_ECHOS_NOW:nat_win]\n");
                fflush(stdout);
            };;
        }
        static void 
        STUB_FUNCTION(gam_obj)( void ){
            if( ins( game_time_copy_for_stub_functions )< 3 ){
                printf("[STUB_FUNCTION:gam_obj]\n");
            };;
            if( GAM_TIM == 64){
                printf("[RUNNING_WITHOUT_ECHOS_NOW:gam_obj]\n");
                fflush(stdout);
            };;
        }
        static void 
        STUB_FUNCTION(ren_log)( void ){
            if( ins( game_time_copy_for_stub_functions )< 3 ){
                printf("[STUB_FUNCTION:ren_log]\n");
            };;
            if( GAM_TIM == 64){
                printf("[RUNNING_WITHOUT_ECHOS_NOW:ren_log]\n");
                fflush(stdout);
            };;
        }

    #undef  GAM_TIM       //:////////////////////////////////://
    #undef  STUB_FUNCTION //:////////////////////////////////://
//:SFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSF  :STUB_FUNCTION://
//:STRUCTS: SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS://

    typedef void (*TYP(FUN))(void); //:GenericFunctionPointer

    struct TYP(looptable){

        unsigned long MEM(str_typ);

        int MEM(lop_tim); //:Loop_Times
        int MEM(gam_tim); //:Game_Time

        #define T TYP(FUN) //:///////////////////////////////://

                //:Native_Window_Update_Logic:
                //:native_window
                T MEM(nat_win); 

                //:Logic_Of_Game_Objects:
                //:Game_Logic_Upate
                //:game_objects
                T MEM(gam_obj); 

                //:Rendering_Engine_Logic
                //:Rendering_Update
                T MEM(ren_log);

        #undef  T //:////////////////////////////////////////://
    }INS(looptable)={
        .MEM(str_typ)=( 0x0 | ( 'L'<<0|'O'<<8|'O'<<16|'P'<<24) )

       ,.MEM(lop_tim)=(0)

        //:Stub functions are to be overwritten:
        #define STUB_FUNCTION( nam ) K_2(lib,STUB_FUNCTION,nam)

       ,.MEM(nat_win)=STUB_FUNCTION(nat_win)
       ,.MEM(gam_obj)=STUB_FUNCTION(gam_obj)
       ,.MEM(ren_log)=STUB_FUNCTION(ren_log)

        #undef STUB_FUNCTION ///////////////////////////////////
    };


//:SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS :STRUCTS://
//:FUNCTIONS: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF://

    void
    EII(SRC_MAINLOOP_looptable)( void ){

        //:Any initialization upon inclusion of file goes here.

    }

    //:Note: "Tick" and "Loop" functions are not namespaced
    //:      out very well. But don't worry about that until
    //:      a collision actually happens.

    void FUN(Tick)( void ){

        //:Not necessary to check for null, but probably
        //:should anyways. Can remove these checks when
        //:optimizing.
        int problems=( 0 );
        if( NIL == INS(looptable).MEM(nat_win) ){
            D("[NIL_LOOPTABLE_FUNC:nat_win]");
            problems++;
        };;
        if( NIL == INS(looptable).MEM(gam_obj) ){
            D("[NIL_LOOPTABLE_FUNC:gam_obj]");
            problems++;
        };;
        if( NIL == INS(looptable).MEM(ren_log) ){
            D("[NIL_LOOPTABLE_FUNC:ren_log]");
            problems++;
        };;
        if( problems > 0 ){
            H("[WEVE_GOT_SOME_NULL_POINTER_PROBLEMS]");
        };;

        //:Because we set stub functions when intializing
        //:the loop table, we never have to do nullchecks.
        //:before calling.
        INS(looptable).MEM(nat_win)();
        INS(looptable).MEM(gam_obj)();
        INS(looptable).MEM(ren_log)();

        //:Track number of completed loops:
        INS(looptable).MEM(lop_tim)++;

        //:Game_Time: In the case that we would like
        //:To pause game or slow down time, we can change
        //:this value at a slower rate in future.
        INS(looptable).MEM(gam_tim)++;
    
        //:Copy over game time variable so that stub
        //:functions have access to it:
        ins(game_time_copy_for_stub_functions)=(
            INS(looptable).MEM(gam_tim)
        );;
    }

    void FUN(Loop)( void ){ //:Loops forever, no exit

        while( 1 ){

            FUN(Tick)( /** NO_ARGUMENTS **/ );

        };;
    }

//:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF :FUNCTIONS://



//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
#undef  lib  ///////////////////////////////////////////| 01 |//
#undef  LIB  ///////////////////////////////////////////| 02 |//
#undef  GM1  ///////////////////////////////////////////| 03 |//
#undef  GM2  ///////////////////////////////////////////| 04 |//
#undef  K_1  ///////////////////////////////////////////| 05 |//
#undef  K_2  ///////////////////////////////////////////| 06 |//                                   
#undef  TYP  ///////////////////////////////////////////| 07 |//   
#undef  INS  ///////////////////////////////////////////| 08 |//   
#undef  FUN  ///////////////////////////////////////////| 09 |// 
#undef  EII  ///////////////////////////////////////////| 10 |//
#undef  MEM  ///////////////////////////////////////////| 11 |//
#undef  ARG  ///////////////////////////////////////////| 12 |//
#undef  VAR  ///////////////////////////////////////////| 13 |//
#undef  RET  ///////////////////////////////////////////| 14 |//                                            
#undef  fun  ///////////////////////////////////////////| 15 |// 
#undef  ins  ///////////////////////////////////////////| 16 |//
#undef   H   ///////////////////////////////////////////| 17 |//
#undef   D   ///////////////////////////////////////////| 18 |//
#undef  NIL  ///////////////////////////////////////////| 19 |//
//|__________________________________________________________|//


//:Thoughts:
    //: function: TitleCase
    //: variable: snake_case
    //:   struct: alllowercase ( matches file name )
    //:           (Inspired by ID DOOM codebase)

//:Goal of this class: (The looptable class)
//:
//:   To maintain the chainfile concept with minimal
//:   disruption. Before I tried solving the problem
//:   using threads. But multi-threading leads to weird
//:   things happening. So really shouldn't multi-thread
//:   until you've got something basic working.
//:
//:   Basically, when new code that needs to be executed
//:   every game tick is added, it can register itself
//:   with the looptable.
//:
//:   This way we can still keep the whole idea of:
//:   "I can remove any number of files from the end"
//:   "of the list of files to compile and the project"
//:   "still compiles and runs".
//:
//:   This... "Build at any layer" "chainfile" concept is
//:   my way of making sure when shit goes really wrong
//:   somewhere I can divide and conquere to see what
//:   source code is probably responsible.


//:SEE: GetProcAddress

#define SRC_NATIVE_CALLWRAP_LOADLIBRARY ( 1934 )

#define lib MACRO_project_prefix_HIDDEN  //: Private  //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //: Public   //: 02 ://
#define GM1( a , b )      a## _ ##b      //: GLUEMAC  //: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //: GLUEMAC  //: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 
#define EII(  nam  ) K_2( LIB, EII, nam )//:INIT_FUNC //: 12 ://
#define ARG(  nam  ) GM2( ARG   ,   nam )//:Argument  //: 13 ://
#define VAR(  nam  ) GM2( VAR   ,   nam )//:Local_Var //: 14 ://
#define RET(  nam  ) GM2( RET   ,   nam )//:RET___Var //: 15 ://
#define fun(  nam  ) GM2( f_2020_04_23_0258AM, nam )  //: 16 :// 
#define NIL  ((void*)0)                               //: 17 ://
#define  H   fun(Halt)                                //: 18 ://
#define  D   fun(Dmsg)                                //: 19 ://



    #define SRC_NATIVE_CALLWRAP_GETPROCADDRESS ( 434 )
    


//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC/NATIVE/CALLWRAP/GetProcAddress:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC/NATIVE/CALLWRAP/GetProcAddress:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://


//:INSTANCES: //:////////////////////////////////////////////://

    void* INS( dll_k32 ) = NIL; //:Kernel32.dll pointer
    void* INS( dll_u32 ) = NIL; //:User32.dll   pointer
    void* INS( dll_g32 ) = NIL; //:Gdi32.dll    pointer
    void* INS( dll_vuk ) = NIL; //:vulkan-1.dll pointer

//:TYPEDEFS: ////////////////////////////////////////////////://

    typedef void (* TYP(Func) )(void); //:Function pointer.
    typedef void*   TYP(Data)        ; //:Data     pointer.
    typedef const char* TYP(Str)     ; //:String   pointer.

    //:TYPEDEF_FARPROC / DLLL_FUNC / DFUN
    //:DFUN=="DLL Function"
    typedef
        unsigned long long               //:RETURNS
        ( __stdcall  *TYP(DFUN)       )  //:NAME
        ( /**NOT_SPECIFIED != void**/ ); //:PARAMS



//:FORWARD_DECLARATIONS: //://///////////////////////////////://

    void EII( SRC_NATIVE_CALLWRAP_getprocaddress )( void );

    TYP(Data) fun(LoadLibrary)( TYP(Str) dll_nam );

    TYP(Func) 
    FUN(GetProcAddress)(
        TYP(Str) dll_nam
    ,   TYP(Str) fun_nam
    );

    TYP(Func)
    fun(GetProcAddress)(
        TYP(Data) dll_ptr
    ,   TYP(Str)  fun_nam
    );

//:FUNCTIONS: //:////////////////////////////////////////////://

    //:Initializer code for this file:
    //:EII: Existance_Is_Initialization
    void EII( SRC_NATIVE_CALLWRAP_getprocaddress )( void ){
        D("[EII:BEG]");

        fun( LoadLibrary )( "dll_k32" );

        //:GPA Test:
        ////////////////////////////////////////////////////////
        printf("[GPA_TEST...]\n\n\n");

        TYP(Func) VAR(CreateWindowExW)=
        FUN(GetProcAddress)("dll_u32","CreateWindowExW");
        
        if( NIL == VAR(CreateWindowExW) ){
            printf("[FILE:GetProcAddress:FAIL:GPA_CWEXW]");
            fflush(stdout);exit(4);
        };;
        ////////////////////////////////////////////////////////

        //:Make absolutely sure all public variables are
        //:non-null before exiting "EII" function:
        //:EIIEIIEIIEIIEIIEIIEIIEII//EIIEIIEIIEIIEIIEIIEIIEII://

        fun( LoadLibrary )( "dll_k32" ); //:Kernel32.dll
        fun( LoadLibrary )( "dll_u32" ); //:User32.dll
        fun( LoadLibrary )( "dll_g32" ); //:Gdi32.dll
        fun( LoadLibrary )( "dll_vuk" ); //:vulkan-1.dll

        if( NIL == INS(dll_k32) ){ H("[NOLOAD:dll_k32]");};
        if( NIL == INS(dll_u32) ){ H("[NOLOAD:dll_u32]");};
        if( NIL == INS(dll_g32) ){ H("[NOLOAD:dll_g32]");};
        if( NIL == INS(dll_vuk) ){ H("[NOLOAD:dll_vuk]");};

        //:SC[VK4UP_SIMPLE]//////////////////////////////////://
        //:make_sure_all_function_pointers_unique:ver__simple://
        #define I1    INS(dll_k32) //:///////////////////////://
        #define I2    INS(dll_u32) //:///////////////////////://
        #define I3    INS(dll_g32) //:///////////////////////://
        #define I4    INS(dll_vuk) //:///////////////////////://
        #define    L_E_N ( 4 )     //:///////////////////////://
        void* arr[ L_E_N ]={ I1,I2,I3,I4 };
        for( int a = 0; a < L_E_N; a++ ){  //:- - - - - - - -://
        for( int b = 0; b < L_E_N; b++ ){  //:- - - - - - - -://
            if( a==b ){ continue; };
            if( arr[a]==arr[b] ){ H("[FAIL:NOT_A_SET]");};
        };;};;D("[PASS:YES_A_SET]");
        #undef  L_E_N //:////////////////////////////////////://
        #undef  I1    //: dll_k32) //~///////////////////////://
        #undef  I2    //: dll_u32) //~///////////////////////://
        #undef  I3    //: dll_g32) //~///////////////////////://
        #undef  I4    //: dll_vuk) //~///////////////////////://
        //:SC[VK4UP_SIMPLE]//////////////////////////////////://

        //:EIIEIIEIIEIIEIIEIIEIIEII//EIIEIIEIIEIIEIIEIIEIIEII://

        D("[EII:END]");
    } //:END:EII[SRC_NATIVE_CALLWRAP_getprocaddress]/////////://

    TYP(Data) fun(LoadLibrary)(
        TYP(Str) ARG(dll_nam)
    ){

        printf("[dll_nam]:%s\n", ARG(dll_nam));

        TYP(Data) 
        VAR(Data)=NIL;
        if( VAR(Data) ){ /** NOOP **/ };

        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_k32"
        &&  ARG(dll_nam)[4] == 'k' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:kernel32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("kernel32.dll");
            INS(dll_k32)=( VAR(Data) ); //:CACHE_YOUR_DLL

        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_u32"
        &&  ARG(dll_nam)[4] == 'u' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:user32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("user32.dll");
            INS(dll_u32)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_g32"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
                    printf("[RESOLVES_TO:gdi32.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("gdi32.dll");
            INS(dll_g32)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_vuk" (vulkan-1.dll)
        &&  ARG(dll_nam)[4] == 'v' 
        &&  ARG(dll_nam)[5] == 'u' 
        &&  ARG(dll_nam)[6] == 'k' 
        ){
                    printf("[RESOLVES_TO:vulkan-1.dll]\n");
            VAR(Data)=DLLL_LoadLibraryA("vulkan-1.dll");
            INS(dll_vuk)=( VAR(Data) ); //:CACHE_YOUR_DLL
        }else
        if( 1 ){
            //:If dll_name is not a shorthand name,
            //:load it as is.

            printf("[CHECK:DoesDLLNameLookCorrect?]%s\n"
            , ARG(dll_nam) );fflush( stdout );

            VAR(Data)=DLLL_LoadLibraryA( ARG(dll_nam) );
        };;

        if( NIL == VAR(Data) ){
            printf("[NullLoadedLibrary]");
            fflush(stdout); exit(4);
        };;

        return(   VAR(Data) );
    }

    TYP(Func) 
    FUN(GetProcAddress)(
        TYP(Str)  ARG(dll_nam)
    ,   TYP(Str)  ARG(fun_nam)
    ){
        TYP(Data)   VAR(dll_ptr) =NIL;

        //:Make sure dll is loaded:
        ////////////////////////////////////////////////////////
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_k32"
        &&  ARG(dll_nam)[4] == 'k' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_k32 ) ){

                INS(dll_k32)= 
                fun( LoadLibrary )( "kernel32.dll" );
            };;
            assert(      INS(dll_k32) );
            VAR(dll_ptr)=INS(dll_k32);
                
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_u32"
        &&  ARG(dll_nam)[4] == 'u' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_u32 ) ){

                INS(dll_u32)= 
                fun( LoadLibrary )( "user32.dll" );
            };;
            assert(      INS(dll_u32) );
            VAR(dll_ptr)=INS(dll_u32);

        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_g32"
        &&  ARG(dll_nam)[4] == 'g' 
        &&  ARG(dll_nam)[5] == '3' 
        &&  ARG(dll_nam)[6] == '2' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL == INS( dll_g32 ) ){

                INS(dll_g32)= 
                fun( LoadLibrary )( "gdi32.dll" );
            };;
            assert(      INS(dll_g32) );
            VAR(dll_ptr)=INS(dll_g32);
                
        }else
        if( ARG(dll_nam)[0] == 'd' 
        &&  ARG(dll_nam)[1] == 'l' 
        &&  ARG(dll_nam)[2] == 'l' 
        &&  ARG(dll_nam)[3] == '_'  //:"dll_vuk"
        &&  ARG(dll_nam)[4] == 'v' 
        &&  ARG(dll_nam)[5] == 'u' 
        &&  ARG(dll_nam)[6] == 'k' 
        ){
            //:if_library_not_loaded____load_now:
            if( NIL ==   INS( dll_vuk ) ){
                         INS( dll_vuk )=fun( LoadLibrary    )
                     /** INS( dll_vuk ) **/( "vulkan-1.dll" );
            };; assert(  INS( dll_vuk ) );
            VAR(dll_ptr)=INS( dll_vuk );
        }else
        if( 1 ){
            printf("[UnknownValueOf:dll_nam]:%s\n"
            , ARG(dll_nam));;

            fflush(stdout);
            exit(4);
        };;
        ////////////////////////////////////////////////////////

        //:Assert DLL pointer is not null:
        if( NIL==VAR(dll_ptr) ){
            printf("[DLL_PTR_NULL]\n");
            fflush(stdout);
            exit(4);
        };;

        //:Get function address from dll:
        ////////////////////////////////////////////////////////
        TYP(Func)
        VAR(GetProcAddress)=
        fun(GetProcAddress)(
            VAR(dll_ptr)
        ,   ARG(fun_nam)
        );;
        ////////////////////////////////////////////////////////

        return( VAR(GetProcAddress) );

    }

    //:Prviate version of "GetProcAddress" wrapper:
    TYP(Func)
    fun(GetProcAddress)(
        TYP(Data) ARG(dll_ptr)
    ,   TYP(Str)  ARG(fun_nam)
    ){
        TYP(DFUN) 
        VAR(DFUN)=DLLL_GetProcAddress( 
            ARG(dll_ptr)
        ,   ARG(fun_nam) 
        );;
        
        //:Cast dll function to generic function pointer:
        TYP(Func) RET(DFUN)=(
            (TYP(Func)) VAR(DFUN)
        );;

        //:Output/return:
        return( RET(DFUN) );
    }



#undef  lib  ///////////////////////////////////////////: 01 ://
#undef  LIB  ///////////////////////////////////////////: 02 ://
#undef  GM1  ///////////////////////////////////////////: 03 ://
#undef  GM2  ///////////////////////////////////////////: 04 ://
#undef  K_1  ///////////////////////////////////////////: 05 ://
#undef  K_2  ///////////////////////////////////////////: 06 ://                                   
#undef  MAK  ///////////////////////////////////////////: 07 ://   
#undef  TYP  ///////////////////////////////////////////: 08 ://   
#undef  INS  ///////////////////////////////////////////: 09 ://   
#undef  FUN  ///////////////////////////////////////////: 10 :// 
#undef  EXA  ///////////////////////////////////////////: 11 :// 
#undef  EII  ///////////////////////////////////////////: 12 ://
#undef  ARG  ///////////////////////////////////////////: 13 ://
#undef  VAR  ///////////////////////////////////////////: 14 ://
#undef  RET  ///////////////////////////////////////////: 15 ://
#undef  fun  ///////////////////////////////////////////: 16 :// 
#undef  NIL  ///////////////////////////////////////////: 17 ://
#undef   H   ///////////////////////////////////////////: 18 ://
#undef   D   ///////////////////////////////////////////: 19 ://


#define lib MACRO_project_prefix_HIDDEN  //:Private   //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //:Public    //: 02 ://
#define GM1( a , b )      a## _ ##b      //:GLUEMAC_01//: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //:GLUEMAC_02//: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 

    #define SRC_NATIVE_PING ( 1 )

    int FUN( SRC_NATIVE_ping )( void ){

        printf("[SRC_NATIVE_ping]\n");

        return( 0 );
    }


#undef  lib ////////////////////////////////////////////: 01 ://
#undef  LIB ////////////////////////////////////////////: 02 ://
#undef  GM1 ////////////////////////////////////////////: 03 ://
#undef  GM2 ////////////////////////////////////////////: 04 ://
#undef  K_1 ////////////////////////////////////////////: 05 ://
#undef  K_2 ////////////////////////////////////////////: 06 ://                                   
#undef  MAK ////////////////////////////////////////////: 07 ://   
#undef  TYP ////////////////////////////////////////////: 08 ://   
#undef  INS ////////////////////////////////////////////: 09 ://   
#undef  FUN ////////////////////////////////////////////: 10 ://
#undef  EXA ////////////////////////////////////////////: 11 ://


#define lib MACRO_project_prefix_HIDDEN  //:Private   //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //:Public    //: 02 ://
#define GM1( a , b )      a## _ ##b      //:GLUEMAC_01//: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //:GLUEMAC_02//: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 
#define VAR(  nam  ) GM2( VAR   ,   nam )//:Local_Var //: 12 ://
                                                      //: -- ://
//:Effectively private via obfuscation:               //: -- ://
#define fun(  nam  ) GM2( f_2020_04_22_0657AM , nam ) //: 13 :// 
#define  H    fun( Halt )                             //: 14 ://
#define  D    fun( DebugPrint )                       //: 15 ://
                                                      //: -- ://
#define NIL ((void*)0)                                //: 16 ://
#define ins(  nam  ) GM2( i_2020_04_22_1047PM , nam ) //: 17 ://
#define MEM(  nam  ) K_2( LIB ,MEM, nam )// Member    //| 18 |//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //:path to this file:
    #define  SRC_NATIVE_WINDOW_CREATION ( 1 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//:STRUCTS: SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS://

    //[  SEE[ VG03.ALL's F09_STRUCT_PIXELFORMATDESCRIPTOR ]  ]//
    //[  docs.microsoft.com/en-us/windows/win32/api/wingdi   ]//
    //[  /ns-wingdi-pixelformatdescriptor                    ]//
    #define B_04 unsigned long  /**DWORD **/  //:////////////://
    #define B_02 unsigned short /** WORD **/  //:////////////://
    #define B_01 unsigned char  /** BYTE **/  //:////////////://
    struct TYP(PIXELFORMATDESCRIPTOR) {  
    /**  01  **/    B_02  nSize;             
    /**  02  **/    B_02  nVersion;          
    /**  --  **/                          
    /**  03  **/    B_04  dwFlags;            
    /**  --  **/                          
    /**  04  **/    B_01  iPixelType;        
    /**  05  **/    B_01  cColorBits;        
    /**  06  **/    B_01  cRedBits;          
    /**  07  **/    B_01  cRedShift;         
    /**  08  **/    B_01  cGreenBits;        
    /**  09  **/    B_01  cGreenShift;       
    /**  10  **/    B_01  cBlueBits;         
    /**  11  **/    B_01  cBlueShift;        
    /**  12  **/    B_01  cAlphaBits;        
    /**  13  **/    B_01  cAlphaShift;       
    /**  14  **/    B_01  cAccumBits;        
    /**  15  **/    B_01  cAccumRedBits;     
    /**  16  **/    B_01  cAccumGreenBits;   
    /**  17  **/    B_01  cAccumBlueBits;    
    /**  18  **/    B_01  cAccumAlphaBits;   
    /**  19  **/    B_01  cDepthBits;        
    /**  20  **/    B_01  cStencilBits;      
    /**  21  **/    B_01  cAuxBuffers;       
    /**  22  **/    B_01  iLayerType;        
    /**  23  **/    B_01  bReserved;         
    /**  --  **/                          
    /**  24  **/    B_04  dwLayerMask;        
    /**  25  **/    B_04  dwVisibleMask;      
    /**  26  **/    B_04  dwDamageMask;       
    /**  --  **/
    };//[struct]//
    #undef  B_04 ////////////// /**DWORD **/  //:////////////://
    #undef  B_02 ////////////// /** WORD **/  //:////////////://
    #undef  B_01 ////////////// /** BYTE **/  //:////////////://

    //:winuser.h
    struct TYP(WIN32POINT){

        long x;         //:TAKEN_FROM:VGK03.ALL:
        long y;         //:F09_STRUCT_POINT && F09_STRUCT_MSG

    }ins(win32point)={
        0
    };

    //:winuser.h
    struct TYP(WINMSG){  //:WINDOW's "MSG" type:

        void*                    hwnd    ;  //: HWND    ://
        unsigned   int           message ;  //: UINT    ://
        unsigned __int64         wParam  ;  //: WPARAM  ://

                 __int64         lParam  ;  //: LPARAM  ://
        unsigned    long         time    ;  //: DWORD   ://

        struct  TYP(WIN32POINT)  pt      ;  //: POINT   ://
        unsigned    long         lPrivate;  //: DWORD   ://

    }ins(winmsg)={
        0
    };

//:SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS :STRUCTS://
//:TYPEDEFS: TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT://

    //:Generic function pointer type:
    ////////////////////////////////////////////////////////////

    //:Did not expect something like TYP(FUN) to expanded
    //:correctly. But maybe we should avoid that?

    typedef 
        void (* TYP(FUN) )(void);

    typedef
        int TYP(TYP);
    ////////////////////////////////////////////////////////////

    //:Generic function pointer type:
    typedef void (* TYP(Func) )(void); //:Function pointer.
    typedef void*   TYP(Data)        ; //:Data     pointer.

    // ------------------------------------------------------ //
    typedef 
        __int64
        (__stdcall *TYP(WNDPROC) )(
            void*             //: HWND
        ,   unsigned   int    //: UINT
        ,   unsigned __int64  //: WPARAM
        ,            __int64  //: LPARAM
        );
    // ------------------------------------------------------ //
    struct TYP(WNDCLASSEXW) {
                    unsigned int   cbSize       ;
                    unsigned int   style        ;
                    TYP(WNDPROC)   lpfnWndProc  ;
                             int   cbClsExtra   ;
                             int   cbWndExtra   ;
                            void*  hInstance    ;
                            void*  hIcon        ;
                            void*  hCursor      ;
                            void*  hbrBackground;
            const unsigned short*  lpszMenuName ;
            const unsigned short*  lpszClassName;
                            void*  hIconSm      ;
    };
    // ------------------------------------------------------ //

//:TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT: TYPEDEFS://
//:FORWARD_DECLARATIONS::FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF://
    __stdcall
    __int64 //:LRESULT
    fun(WinMsgHanWndPoc)(
    /**/           void*    han_win   //:HWND
    ,   unsigned   int      Msg       //:...?...
    ,   unsigned __int64    wParam    //:WPARAM
    ,            __int64    lParam    //:LPARAM
    );

    char*
    fun(MakeIntResourceA)( int i );

    //:This function is registered with the main game loop.
    //:It does NOT need to be public, since this file
    //:does the registering, not the game loop file.
    void fun( WindowTick )( void );

//:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF::FORWARD_DECLARATIONS://
//:INSTANCES: IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII://

    int ins(frames_without_window)=(0-1); //:negative==unset

    struct TYP(WNDCLASSEXW) INS(WNDCLASSEXW)={0};
    void*  INS(han_exe)=(NIL); //:AKA:handle_to_exe
    void*  INS(dek_win)=(NIL); //:AKA:the_desktop_window
    void*  ins(han_win)=(NIL); //:AKA:handle_to_YOUR_window
    void*  ins(con_win)=(NIL); //:AKA:window_device_context

    #define NOT_UNICODE_I_SWEAR const unsigned short //://///://
    //://////////////////////////////////////////////////////://

    NOT_UNICODE_I_SWEAR*      //:AKA:unique_window_name
    INS(win_nam)=( L"2020_4_22:UNIQUE_WINDOW_NAME"     );

    NOT_UNICODE_I_SWEAR*      //:AKA:titlebar_text
    INS(tib_tex)=( L"[FLIP_THE_FUCKING_TABLE!]((╯°□°）╯︵ ┻━┻))" );

    //://////////////////////////////////////////////////////://
    #undef  NOT_UNICODE_I_SWEAR //://////////////////////////://
    
    //:FUNCTION_POINTERS:  FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP://
            
    TYP(FUN)    INS(CreateWindowExW  )=( NIL );
    TYP(FUN)    INS(GetDesktopWindow )=( NIL );
    TYP(FUN)    INS(RegisterClassExW )=( NIL );
    TYP(FUN)    INS(LoadIconA        )=( NIL );
    TYP(FUN)    INS(LoadCursorA      )=( NIL );
    TYP(FUN)    INS(GetModuleHandleW )=( NIL );
    TYP(FUN)    INS(DefWindowProcW   )=( NIL );
    TYP(FUN)    INS(DestroyWindow    )=( NIL );
    TYP(FUN)    INS(PostQuitMessage  )=( NIL );
    TYP(FUN)    INS(GetWindowDC      )=( NIL );
    TYP(FUN)    INS(ChoosePixelFormat)=( NIL );
    TYP(FUN)    INS(SetPixelFormat   )=( NIL );
    TYP(FUN)    INS(ShowWindow       )=( NIL );
    TYP(FUN)    INS(UpdateWindow     )=( NIL );
    TYP(FUN)    INS(SetFocus         )=( NIL );
    TYP(FUN)    INS(PeekMessageW     )=( NIL );
    TYP(FUN)    INS(TranslateMessage )=( NIL );
    TYP(FUN)    INS(DispatchMessageW )=( NIL );

    //:FPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFPFP  :FUNCTION_POINTERS://

    struct TYP(PIXELFORMATDESCRIPTOR) INS(fod_pix)={0};
    int    ins(fmt_num)=( 0 ); //:pixel_format_number

//:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII: INSTANCES://






//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
//[H:Halt: The_First_Function_Is_Always_Halt                 ]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//                                               
/*-//[*/                                                /*]//-*/
/*-//[*/    static void                                 /*]//-*/
/*-//[*/    fun(Halt)( const char* msg ){               /*]//-*/
/*-//[*/        printf(                                 /*]//-*/
/*-//[*/            "[2020_04_08:Halt]:%s\n"            /*]//-*/
/*-//[*/        ,   msg                                 /*]//-*/
/*-//[*/        );;                                     /*]//-*/
/*-//[*/        fflush(stdout); exit(64);               /*]//-*/
/*-//[*/    }                                           /*]//-*/
/*-//[*/                                                /*]//-*/
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

    static void
    fun( DebugPrint )( const char* msg ){
        printf("[2020_04_22:DebugPrint:MSG]:%s\n",msg);
        fflush( stdout );
    }






int FUN( SRC_NATIVE_WINDOW_creation )( void ){
printf("[SRC_NATIVE_WINDOW_creation]\n");

    //:STEPS: 
    //: 1: EII: Existance_Is_Initialization
    //:         Front load resources first and make sure
    //:         they all are valid.
    //:
    //: 2: Register Your Window "Class".
    //:
    //: 3: .....todo...

    TYP(TYP)     int_a = 5;
    VG04_TYP_TYP int_b = 6;
    printf("[int_a]:%d\n", int_a);
    printf("[int_b]:%d\n", int_b);

    //:EII:Existance_Is_Initialization:(BELOW):--------------://
    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://

    //: INS( variable_names ) : Public, Init immediately here.
    //: ins( variable_names ) : Private,Init before func exits.
    //: MORE_INFO[ SC[ EII_INS_INS_RULES ] ]

    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://

    ////////////////////////////////////////////////////////////
    INS(CreateWindowExW)=
    FUN(GetProcAddress)("dll_u32","CreateWindowExW");

    INS(GetDesktopWindow)=
    FUN(GetProcAddress)("dll_u32","GetDesktopWindow");

    INS(RegisterClassExW)=
    FUN(GetProcAddress)("dll_u32","RegisterClassExW");

    INS(LoadIconA)=
    FUN(GetProcAddress)("dll_u32","LoadIconA");

    INS(LoadCursorA)=
    FUN(GetProcAddress)("dll_u32","LoadCursorA");

    INS(GetModuleHandleW)= //: "kernel32.dll"
    FUN(GetProcAddress)("dll_k32","GetModuleHandleW");

    INS(DefWindowProcW)=
    FUN(GetProcAddress)("dll_u32","DefWindowProcW");

    INS(DestroyWindow)=
    FUN(GetProcAddress)("dll_u32","DestroyWindow");

    INS(PostQuitMessage)=
    FUN(GetProcAddress)("dll_u32","PostQuitMessage");

    INS(GetWindowDC)=
    FUN(GetProcAddress)("dll_u32","GetWindowDC");

    INS(ChoosePixelFormat)= //: "gdi32.dll"
    FUN(GetProcAddress)("dll_g32","ChoosePixelFormat");

    INS(SetPixelFormat)= //: "gdi32.dll"
    FUN(GetProcAddress)("dll_g32","SetPixelFormat");

    INS(ShowWindow)=
    FUN(GetProcAddress)("dll_u32","ShowWindow");

    INS(UpdateWindow)=
    FUN(GetProcAddress)("dll_u32","UpdateWindow");

    INS(SetFocus)=
    FUN(GetProcAddress)("dll_u32","SetFocus");

    INS(PeekMessageW)=
    FUN(GetProcAddress)("dll_u32","PeekMessageW");

    INS(TranslateMessage)=
    FUN(GetProcAddress)("dll_u32","TranslateMessage");

    INS(DispatchMessageW)=
    FUN(GetProcAddress)("dll_u32","DispatchMessageW");



    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://
    if( ((void*)0) != INS(CreateWindowExW) ){
        D("[SUCCESS:CreateWindowExW]");
    }else{
        H("[FAILURE:CreateWindowExW]");
    };;
    if( ((void*)0) != INS(GetDesktopWindow) ){
        D("[SUCCESS:GetDesktopWindow]");
    }else{
        H("[FAILURE:GetDesktopWindow]");
    };;
    if( ((void*)0) != INS(RegisterClassExW) ){
        D("[SUCCESS:RegisterClassExW]");
    }else{
        H("[FAILURE:RegisterClassExW]");
    };;
    if( ((void*)0) != INS(LoadIconA) ){
        D("[SUCCESS:LoadIconA]");
    }else{
        H("[FAILURE:LoadIconA]");
    };;
    if( ((void*)0) != INS(LoadCursorA) ){
        D("[SUCCESS:LoadCursorA]");
    }else{
        H("[FAILURE:LoadCursorA]");
    };;
    if( ((void*)0) != INS(GetModuleHandleW) ){
        D("[SUCCESS:GetModuleHandleW]");
    }else{
        H("[FAILURE:GetModuleHandleW]");
    };;
    if( ((void*)0) != INS(DefWindowProcW) ){
        D("[SUCCESS:DefWindowProcW]");
    }else{
        H("[FAILURE:DefWindowProcW]");
    };;
    if( ((void*)0) != INS(DestroyWindow) ){
        D("[SUCCESS:DestroyWindow]");
    }else{
        H("[FAILURE:DestroyWindow]");
    };;
    if( ((void*)0) != INS(PostQuitMessage) ){
        D("[SUCCESS:PostQuitMessage]");
    }else{
        H("[FAILURE:PostQuitMessage]");
    };;
    if( ((void*)0) != INS(GetWindowDC) ){
        D("[SUCCESS:GetWindowDC]");
    }else{
        H("[FAILURE:GetWindowDC]");
    };;
    if( ((void*)0) != INS(ChoosePixelFormat) ){
        D("[SUCCESS:ChoosePixelFormat]");
    }else{
        H("[FAILURE:ChoosePixelFormat]");
    };;
    if( ((void*)0) != INS(SetPixelFormat) ){
        D("[SUCCESS:SetPixelFormat]");
    }else{
        H("[FAILURE:SetPixelFormat]");
    };;
    if( ((void*)0) != INS(ShowWindow) ){
        D("[SUCCESS:ShowWindow]");
    }else{
        H("[FAILURE:ShowWindow]");
    };;
    if( ((void*)0) != INS(UpdateWindow) ){
        D("[SUCCESS:UpdateWindow]");
    }else{
        H("[FAILURE:UpdateWindow]");
    };;
    if( ((void*)0) != INS(SetFocus) ){
        D("[SUCCESS:SetFocus]");
    }else{
        H("[FAILURE:SetFocus]");
    };;
    if( ((void*)0) != INS(PeekMessageW) ){
        D("[SUCCESS:PeekMessageW]");
    }else{
        H("[FAILURE:PeekMessageW]");
    };;
    if( ((void*)0) != INS(TranslateMessage) ){
        D("[SUCCESS:TranslateMessage]");
    }else{
        H("[FAILURE:TranslateMessage]");
    };;
    if( ((void*)0) != INS(DispatchMessageW) ){
        D("[SUCCESS:DispatchMessageW]");
    }else{
        H("[FAILURE:DispatchMessageW]");
    };;

    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://
    //[SC[MSA_FPU_CXX](BELOW)////////////////////////////////]//
    //:make_sure_all_function_pointers_unique:      //|  --  |//
    #define       L_E_N (         18+1)  //://///////////////://
    TYP(FUN) arr[ L_E_N ]={     0x00                //|  --  |//
    ,INS(CreateWindowExW   ) /**  01  **/           //|  01  |//
    ,INS(GetDesktopWindow  ) /**  02  **/           //|  02  |//
    ,INS(RegisterClassExW  ) /**  03  **/           //|  03  |//
    ,INS(LoadIconA         ) /**  04  **/           //|  04  |//
    ,INS(LoadCursorA       ) /**  05  **/           //|  05  |//
    ,INS(GetModuleHandleW  ) /**  06  **/           //|  06  |//
    ,INS(DefWindowProcW    ) /**  07  **/           //|  07  |//
    ,INS(DestroyWindow     ) /**  08  **/           //|  08  |//
    ,INS(PostQuitMessage   ) /**  09  **/           //|  09  |//
    ,INS(GetWindowDC       ) /**  10  **/           //|  10  |//
    ,INS(ChoosePixelFormat ) /**  11  **/           //|  11  |//
    ,INS(SetPixelFormat    ) /**  12  **/           //|  12  |//
    ,INS(ShowWindow        ) /**  13  **/           //|  13  |//
    ,INS(UpdateWindow      ) /**  14  **/           //|  14  |//
    ,INS(SetFocus          ) /**  15  **/           //|  15  |//
    ,INS(PeekMessageW      ) /**  16  **/           //|  16  |//
    ,INS(TranslateMessage  ) /**  17  **/           //|  17  |//
    ,INS(DispatchMessageW  ) /**  18  **/           //|  18  |//
    #define  L_E_N_DOUBLECHECK   (18+1) //:///////////:  --  ://
//: ,INS(function_pointer_name_here)                //|  19  |//
//: ,INS(function_pointer_name_here)                //|  20  |//
//: ,INS(function_pointer_name_here)                //|  31  |//
//: ,INS(function_pointer_name_here)                //|  32  |//
//: ,INS(function_pointer_name_here)                //|  33  |//
//: ,INS(function_pointer_name_here)                //|  34  |//
//: ,INS(function_pointer_name_here)                //|  35  |//
//: ,INS(function_pointer_name_here)                //|  36  |//
//: ,INS(function_pointer_name_here)                //|  37  |//
//: ,INS(function_pointer_name_here)                //|  38  |//
//: ,INS(function_pointer_name_here)                //|  39  |//
//: ,INS(function_pointer_name_here)                //|  40  |//
//: ,INS(function_pointer_name_here)                //|  41  |//
//: ,INS(function_pointer_name_here)                //|  42  |//
//: ,INS(function_pointer_name_here)                //|  43  |//
//: ,INS(function_pointer_name_here)                //|  44  |//
//: ,INS(function_pointer_name_here)                //|  45  |//
//: ,INS(function_pointer_name_here)                //|  46  |//
//: ,INS(function_pointer_name_here)                //|  47  |//
//: ,INS(function_pointer_name_here)                //|  48  |//
//: ,INS(function_pointer_name_here)                //|  49  |//
//: ,INS(function_pointer_name_here)                //|  50  |//
    };;//:////////////////////////////////////////////:  --  ://
    if( L_E_N != L_E_N_DOUBLECHECK ){
        H("[FAIL:MACRO_SETUP_FAIL:L_E_N_DOUBLECHECK]");
    };;
    for( int a = 0; a < L_E_N; a++ ){  //:- - - - - - - - - -://
    for( int b = 0; b < L_E_N; b++ ){  //:- - - - - - - - - -://
        if( a==b ){ continue; };
        if( arr[a]==arr[b] ){ H("[FAIL:NOTASET:2020_04_25]");};
    };;};;                    D("[PASS:YESASET:2020_04_25]");
    #undef  L_E_N //:////////////////////////////////////////://
    //[SC[MSA_FPU_CXX](ABOVE)////////////////////////////////]//
    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://

    INS(han_exe)=((TYP(F_01))INS(GetModuleHandleW))( NIL );
    INS(dek_win)=((TYP(F_00))INS(GetDesktopWindow))(     );

    if( NIL== INS(han_exe) ){ H("[NIL:han_exe]"); };
    if( NIL== INS(dek_win) ){ H("[NIL:dek_win]"); };
    
    //:eiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieiieii://

    //: LATER_IN_FUNCTION: 
    //: INS(fod_pix)==temp_pixel_format_descriptor_for_easy_init
    struct TYP(PIXELFORMATDESCRIPTOR)               
    temp_pixel_format_descriptor_for_easy_init={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct TYP(PIXELFORMATDESCRIPTOR) ),       //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;    
    //:eieieieieieieieieieieieieieieieieieieieieieieieieieiei://
    #define PIX INS(fod_pix) ///////////////////////////////////
    //: COPY_OVER + SMOKE_TEST : BELOW --------------------- ://

        //:Copy over temp to file scope variable:
        //:fod_pix==temp_pixel_format_descriptor_for_easy_init
                PIX=temp_pixel_format_descriptor_for_easy_init;

        //:Smoke_Test:
        ////////////////////////////////////////////////////////
        if(      32!=PIX.cColorBits   ){
            H( "[32!=PIX.cColorBits]" );
        };;
        if( 24 != PIX.cDepthBits  ){
            printf( 
                  "[PIX.cDepthBits]:%d\n"
            ,       PIX.cDepthBits  
            );;
            H("[24!=PIX.cDepthBits]");
        };;
        if(      8!=PIX.cStencilBits ){
           H( "[08!=PIX.cStencilBits]");
        };;     
    
        #define COLT_40 40 /////////////////////////////////////
 
        if( COLT_40 != 
            sizeof( struct TYP(PIXELFORMATDESCRIPTOR) )
        ){
            H("[COLT_40:1]");
        }else
        if( 
            COLT_40 != 
            sizeof( temp_pixel_format_descriptor_for_easy_init)
        ){
            H("[COLT_40:2]");
        }else
        if( COLT_40 != sizeof( PIX ) ){
            H("[COLT_40:3]");
        }else
        if( COLT_40 != sizeof( INS( fod_pix ) ) ){
            H("[COLT_40:4]");
        }else
        if( COLT_40 != INS( fod_pix ).nSize ){
            H("[COLT_40:5]");
        }else{
            D("[PIXELFORMATDESCRIPTOR:It_Checks_Out]");
        };;

        #undef  COLT_40  ///////////////////////////////////////

        ////////////////////////////////////////////////////////
             
    //: COPY_OVER + SMOKE_TEST : ABOVE --------------------- ://
    #undef  PIX ////////////////////////////////////////////////
    //:EIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEIIEII://
    //:EII:Existance_Is_Initialization:(ABOVE):______________://


    //:R:Register:(BELOW):-----------------------------------://
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    //:Before creating window, must register window class:
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    
    
    //:SmokeTest:
    size_t struct_size =( sizeof( struct TYP(WNDCLASSEXW) ) );
    if( struct_size != 80 ){ H("[BadStructSize]"); };
    
    
    ////////////////////////////////////////////////////////////
    
    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////
    
    INS(WNDCLASSEXW).cbSize=sizeof( struct TYP(WNDCLASSEXW) );
    INS(WNDCLASSEXW).style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                    //| ...ClassWin32         |//
    0);;
    INS(WNDCLASSEXW).lpfnWndProc=fun(WinMsgHanWndPoc);
    INS(WNDCLASSEXW).cbClsExtra=0;
    INS(WNDCLASSEXW).cbWndExtra=0;
    INS(WNDCLASSEXW).hInstance =( INS( han_exe ) );
    
    char* idi_application = fun(MakeIntResourceA)( 32512 );
    char* idc_arrow       = fun(MakeIntResourceA)( 32512 );
    
    #define F2 TYP(F_02) ///////////////////////////////////////
    
        INS(WNDCLASSEXW).hIcon  =((F2)INS(LoadIconA))(  
            NULL
        ,   idi_application
        );;
        INS(WNDCLASSEXW).hCursor=((F2)INS(LoadCursorA))(  
            NULL
        ,   idc_arrow
        );;
    
    #undef  F2 /////////////////////////////////////////////////
    #define XX /////////////////////////////////////////////////
    
    //:SEE[ HBR_BACKGROUND_CAN_BE_NULL_FOR_VULKAN_WINDOW ]
    //:AKA[ HBC_BNF_VW ]
    INS(WNDCLASSEXW).hbrBackground=NULL;
    INS(WNDCLASSEXW).lpszMenuName=NULL;
    INS(WNDCLASSEXW).lpszClassName=INS(win_nam);
    
    #undef  XX /////////////////////////////////////////////////
    #define F2 TYP(F_02) ///////////////////////////////////////
    
    INS(WNDCLASSEXW).hIconSm=(
        ((F2)INS(LoadIconA))(
            NULL
        ,   idi_application
        )
    );;
    
    #undef  F2 /////////////////////////////////////////////////
    #define F3 TYP(F_03) ///////////////////////////////////////
    
    //:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
    //|If you forget to register your window class,the       |//
    //|observable effect is the window never opening,and the |//
    //|wait loop exiting immediately.                        |//
    //|
    //|RegisterClassExW:(MSDN_DOCS):
    //|Registers a window class for subsequent use in calls  |//
    //|to the CreateWindow or CreateWindowEx function.       |//
    //:______________________________________________________://
    int VAR( bool )=(
        (int)(unsigned long long)
        (  (TYP(F_01))  INS(RegisterClassExW)  )(  
            &( INS(WNDCLASSEXW) )
        )
    );;
    if( VAR( bool ) <= 0 ){
        H("[REGWINCLASS:FAIL]");
    }else{
        D("[REGWINCLASS:PASS]");
    };;
    
    #undef  F3 /////////////////////////////////////////////////
    //:RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR://
    //:R:Register:(ABOVE):-----------------------------------://
    //:CREATE_WINDOW:::CWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCW://
    #define NIHILISM NIL //://///////////|///////////////////://
    #define V void       //://///////////|///////////////////://
    #define U64 unsigned long long int //:///////////////////://
    ins(han_win)=
    ((TYP(F_12))INS(CreateWindowExW))//:---------------------://
    (
    ////
        /**/(V*)0x00000008L  /** ws_ex_topmost **/
        ,   (V*)INS(win_nam) /** Window___Name **/
        ,   (V*)INS(tib_tex) /** Titlebar_Text **/
    ////
        , 
        (V*)(U64)
        (0
        |  0x00CF0000 /** ws_overlappedwindow **/ 
        |      0x0020 /** CS_OWNDC (2B/32b)  **/
        |
        0)
    ////    X_Y_WID_HIG
        ,   (V*)(U64) 22    //: _X_  -----------://
        ,   (V*)(U64) 22    //: _Y_  -----------://
        ,   (V*)(U64) 1024  //: WID  -----------://
        ,   (V*)(U64) 512   //: HIG  -----------://
    ////
        ,   INS(dek_win)    //:-- hWndParent ---://
        ,   ( NIHILISM )    //:-- hMenu      ---://
        ,   INS(han_exe)    //:-- hInstance  ---://        
        ,   ( NIHILISM )    //:-- lpParam    ---://  
    ////
    ); //:---------------------------------------------------://
    
    if(NIL==ins(han_win)){
        H("[FAIL:VKG04_WindowCreateFail]");
        return 0;
    }else{
        D("[PASS:VKG04_CreatedWindow:TODO:SetupWindowLoop]");
    };;
    #undef  U64      //://///////////////////////////////////://
    #undef  V        //://///////////////////////////////////://
    #undef  NIHILISM //://///////////////////////////////////://
    //:CWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCW:::CREATE_WINDOW://
    //:DEVICE_CONTEXT: DCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC://

    ins(con_win)=((TYP(F_01))INS(GetWindowDC))( ins(han_win) );
    if( NIL==ins(con_win) ){
        H("[FailedToGet:window_device_context/con_win]");
    }else{
        D("[PASS:con_win(window_device_context)]");
    };;

    //:DCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC :DEVICE_CONTEXT://

    //:PFN:Pixel_Format_Number: GET: ins(fmt_num):
    //::PFN:PFN:PFN:PFN:PFN:PFN::::::PFN:PFN:PFN:PFN:PFN:PFN:://
    ins(fmt_num)=( //:pixel_format_number
        //:CAST_RESULTS:
        (int)(unsigned long long)

        //:FUNCTION_CALL:
        (  (TYP(F_02))INS(ChoosePixelFormat /**GDI32.DLL**/ ))

        //:FUNCTION_PARAMETERS:
        (  
             ins(con_win)    /**window_device_context**/
        , &( INS(fod_pix) )  /**PIXELFORMATDESCRIPTOR**/
        )
    );;

    if( 0 == ins(fmt_num) ){
        H("[FAIL:DEFINITELY_FAILED:ChoosePixelFormat]");
    }else
    if( 0  > ins(fmt_num) ){ //:NEGATIVE
        //:Look more into documentation if this happens.
        //:but pretty sure it should be a positive number.
        //:Also watch out for errors due to sign extension.
        H("[fail?PROBABLY_FAILED:::ChoosePixelFormat]");
    }else
    if( 0  < ins(fmt_num) ){ //:POSITIVE
        D("[PASS:ALL_IS_GOOD_IN_THE_PIXELFORMAT_NEIGHBORHOOD]");
    }else{ //:WHAT_THE_FUCK
        H("[FAIL:WHAT_THE_FUCK:2020_04_25:0148PM]");
    };;
    //::PFN:PFN:PFN:PFN:PFN:PFN::::::PFN:PFN:PFN:PFN:PFN:PFN:://

    //:VC:Vulkan_Compatible:
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://
    //:VKG03.ALL:f09_MakeWindowCompatibleWith_GL
    //:Make the window compatible with openGL & Vulkan:
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((TYP(F_03))INS(SetPixelFormat))(
        /**/
        /**/        ins(con_win)  /** window_device_context **/
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        ins(fmt_num)  /** pixel_format_number   **/
        /**/    ,
        /**/     &( INS(fod_pix) )/** PIXELFORMATDESCRIPTOR **/
        )
    );;
    if( setting_pixel_format_worked ){
        D("[PASS:SET_PIXEL_FORMAT]");
    }else{
        H("[FAIL:SET_PIXEL_FORMAT]");
    };;
    //:VCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVCVC://

    //:SEE:VG03.ALL:f09_WindowLoop

    //:LG:Loosey_Goosey:
    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    //: Because we are playing loosy-goosy without including
    //: any header files, we better check runtime size of
    //: the structs we re-created against observed sizes
    //: when compiling small project using <windows.h> header.
    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    if( 8 == sizeof( ins(win32point) ) ){
        D("[PASS:SIZECHECK:win32point]");
    }else{
        H("[FAIL:SIZECHECK:win32point]");
    };;
    if(48 == sizeof( ins(winmsg)     ) ){
        D("[PASS:SIZECHECK:winmsg]");
    }else{
        H("[FAIL:SIZECHECK:winmsg]");
    };;

    if( 8 == sizeof( struct TYP(WIN32POINT) ) ){
        D("[PASS:SIZECHECK:WIN32POINT]");
    }else{
        H("[FAIL:SIZECHECK:WIN32POINT]");
    };;
    if(48 == sizeof( struct TYP(WINMSG)     ) ){
        D("[PASS:SIZECHECK:WINMSG]");
    }else{
        H("[FAIL:SIZECHECK:WINMSG]");
    };;


    //:LGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLGLG://
    //:TP:TickPrep: Prepwork before doing a WindowTick(...):
    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://
    //:                                                      ://
    //:ALL_FUNCTIONS_FROM: "User32.dll"                      ://
    //:                                                      ://
    //: ShowWindow   :Set Visibility State Of Window:        ://
    //: UpdateWindow :Force WM_PAINT to top of message queue.://
    //: SetFocus     :Set keyboard focus to window:          ://
    //:                                                      ://
    //: han_win:-----: handle_to_a_window_instance           ://
    //:                ( handle_to_window )                  ://
    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://
    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;

    ( (TYP(F_02)) INS(ShowWindow)   )(  ins(han_win), show  );
    ( (TYP(F_01)) INS(UpdateWindow) )(  ins(han_win)        ); 
    ( (TYP(F_01)) INS(SetFocus)     )(  ins(han_win)        );

    //:TPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTPTP://

    //:We are not going to enter a window loop here.
    //:That would wreck the chain structure of our project
    //:setup. Instead we will register WindowTick function
    //:with the main game loop, and the game loop will 
    //:call it for us.
    INS(looptable).MEM(nat_win)=&( fun(WindowTick) );


    return( 0 );
}


int fun(TakeOrLookMessage)( //://////////////////////////////://

    //:ins(winmsg) / LPMSG
    struct TYP(WINMSG)* dont_prefix_message_with_and_symbol 
    ,
    int                 take_the_message
){ //:///////////////////////////////////////////////////////://

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        H("[FAIL:EXPECTED:Pos|Or|Zero]");
    };;

    int ret =(
        //:CAST_RETURN_DATA:
        (int)(unsigned long long)

        //:FUNCTION_TO_CALL:
        (  (TYP(F_05)) INS(PeekMessageW)  )

        //:ARGUMENTS_TO_FUNCTION:
        (
        /** -- **/    (void*)
        /** 01 **/    dont_prefix_message_with_and_symbol
        /** -- **/    ,
        /** 02 **/    NULL //:hWnd:NullToProcessThreadMessages
        /** -- **/    ,
        /** 03 **/    0    //:wMsgFilterMin
        /** -- **/    ,
        /** 04 **/    0    //:wMsgFilterMax
        /** -- **/    ,
        /** -- **/    (void*)(unsigned long long)
        /** 05 **/    look_or_take  //:wRemoveMsg
        )
    );;
    return( ret );

} //://////////////////////////////////////:TakeOrLookMessage://
int /** BOOL **/ fun(LookMessage)( //:///////////////////////://
    struct TYP(WINMSG)* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=fun(TakeOrLookMessage)(msg,look);
    return( ret );
} //:////////////////////////////////////////////:LookMessage://
int /** BOOL **/ fun(TakeMessage)( //:///////////////////////://
    struct TYP(WINMSG)* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=fun(TakeOrLookMessage)(msg,take);
    return( ret );
} //:////////////////////////////////////////////:TakeMessage://

//:I thought this needed to be public. But then I realized
//:it is this file's responsibility to register itself
//:with the main game loop.
void fun( WindowTick )( void )
{
    //:One tick of our window loop goes here.

    //:######################################################://
    #define M ins(winmsg) //:################################://

    fun(LookMessage)( &M );
    if( /** WHILE_CONVERTED_TO_AN_IF **/ //://///////////////://

        M.message != 0x12 /** UINT:wm_quit **/

    ){  //://////////////////////////////////////////////////://

        if( fun(TakeMessage)(    &M )){

            ( (TYP(F_01))INS(TranslateMessage) )( &M );

            ( (TYP(F_01))INS(DispatchMessageW) )( &M );

        };;

        ins(frames_without_window) = 0;

    }else{ //:///////////////////////////////////////////////://

        //:Notify console if the window is closed and the
        //:program is still executing.
        #define MSG_MAX_INDEX ( 5 ) //://////////////////////://
            ins(frames_without_window)++;
            char* no_more_window_message=(
                "[SRC/NATIVE/WINDOW/creation._:NOMOREWINDOW]\n"
            );;
            if( ins(frames_without_window) < MSG_MAX_INDEX ){
                //:TODO: Variables to let rendering system know
                //:      that the window is closed. For now 
                //:      a simple printf will do.
                printf(no_more_window_message);
                fflush(stdout);
            }else
            if( ins(frames_without_window) == MSG_MAX_INDEX ){
                printf("[StillNoWindowButBeingQuietNow...]\n");
                printf("[USE[CTRL+C]HERE_TO_EXIT_PROGRAM!]\n");
                fflush(stdout);
            };;
        #undef MSG_MAX_INDEX //://///////////////////////////://

    };; //://////////////////////////////////////////////////://

    #undef M //:#############################################://
    //:######################################################://

}
 






//:MakeIntResourceA /////////////////////////////////////////://
char*
fun(MakeIntResourceA)( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
} //:////////////////////////////////////// MakeIntResourceA ://
//:WinMsgHanWndPoc //////////////////////////////////////////://
__stdcall
__int64 //:LRESULT
fun(WinMsgHanWndPoc)(
/**/           void*    han_win   //:HWND
,   unsigned   int      Msg       //:...?...
,   unsigned __int64    wParam    //:WPARAM
,            __int64    lParam    //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[SRC/NATIVE/WINDOW/creation._:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 (( TYP(F_01) )(INS(DestroyWindow)))(han_win);

            if(0==ok){ H("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            (( TYP(F_01) )(INS(DestroyWindow)))(han_win);

        if(0==ok){ H("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((TYP(F_01))INS(PostQuitMessage))(0);

    case 0x000F /**wm_paint**/:
        
        //:SEE[ WM_PAINT_COMMENTS_SECTION ]

    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            (   (TYP(F_04))   (INS(DefWindowProcW))   )(
            /**/(void*)                han_win  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //://////////////////////////////////////// WinMsgHanWndPoc://

#undef  lib ////////////////////////////////////////////: 01 ://
#undef  LIB ////////////////////////////////////////////: 02 ://
#undef  GM1 ////////////////////////////////////////////: 03 ://
#undef  GM2 ////////////////////////////////////////////: 04 ://
#undef  K_1 ////////////////////////////////////////////: 05 ://
#undef  K_2 ////////////////////////////////////////////: 06 ://                                   
#undef  MAK ////////////////////////////////////////////: 07 ://   
#undef  TYP ////////////////////////////////////////////: 08 ://   
#undef  INS ////////////////////////////////////////////: 09 ://   
#undef  FUN ////////////////////////////////////////////: 10 ://
#undef  EXA ////////////////////////////////////////////: 11 ://
#undef  VAR ////////////////////////////////////////////: 12 ://
#undef  fun ////////////////////////////////////////////: 13 ://
#undef   H  ////////////////////////////////////////////: 14 ://
#undef   D  ////////////////////////////////////////////: 15 ://
#undef  NIL ////////////////////////////////////////////: 16 ://
#undef  ins ////////////////////////////////////////////: 17 ://
#undef  MEM ////////////////////////////////////////////: 18 ://


//:Comments Section:                                         ://
//:HBR_BACKGROUND_CAN_BE_NULL_FOR_VULKAN_WINDOW              ://
//                                                            //
//      //| Looking at:                            |//        //
//      //| https://github.com/glfw/glfw/blob/     |//        //
//      //| master/src/win32_window.c              |//        //
//      //| does not look like background          |//        //
//      //| brush color eneds to be set.           |//        //
//      //|                                        |//        //
//      //| Code here specifically says:           |//        //
//      //| "No Background Required For GL"        |//        //
//      //| http://nehe.gamedev.net/tutorial       |//        //
//      //| /creating_an_opengl_window_(win32)     |//        //
//      //| /13001/                                |//        //
//      //- W.hbrBackground=(                      -//        //
//      //-     /**/(HBRUSH)                       -//        //
//      //-     /**/ FP->GDI32.GetStockObject(     -//        //
//      //-     /**/     FP->GDI32.DATA.BRUSH.BLACK-//        //
//      //-     /**/)                              -//        //
//      //- );;                                    -//        //
//                                                            //
//      Comment originally taken from:                        //
//      V:\VG\03\VG03.ALL                                     //
//                                                            //
//      And I ran it and got a window that vulkan liked,      //
//      so I know this to be true.                            //
//                                                            //
//      DATE[ 2020_04_22 ]                                    //


//:WM:WM_PAINT_COMMENTS_SECTION:
//:WMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWM://
////    //:[TODO]:Something to pace the updating            ////
////    //:of graphics.                                     ////
////                                                        ////
////                                                        ////
////    //+ DELETE THIS BLOCK +//                           ////
////    //- //:I dont think this is needed:         -//     ////
////    //- //: You may use the same HDC in both    -//     ////
////    //- //: threads, but not at the same time.  -//     ////
////    //- //: SEE[ gl-hdc-thread-quote ]          -//     ////
////    //- if(GLEB_SWIN.render_tick_function_has){ -//     ////
////    //-    GLEB_SWIN.render_tick_function();    -//     ////
////    //- };;                                     -//     ////
////                                                        ////
////    //: This might be better done setting a flag        ////
////    //: than using a callback. In order to prevent      ////
////    //: drawing code from being invoked on the          ////
////    //: wrong thread.                                   ////
////                                                        ////
////    //: With that said, setting a flag:                 ////
////    //- ENGETHER.THREADING.InterlockedIncrement64( -//  ////
////    //-     &( GLEB_SWIN.THREAD_SAFE_FLAGS.        -//  ////
////    //-        redraw_message_count )              -//  ////
////    //- );;                                        -//  ////
////                                                        ////
////                                                        ////
////    //+ This call needs to be made from    +//          ////
////    //+ the same thread as your OpenGL     +//          ////
////    //+ calls.                             +//          ////
////    //# DONT_HERE:GLEB_SWIN_SwapBuffers(); #//          ////
//:WMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWM://


//:Stupid needless optimization. You can spare 64bits
//:to hold onto the function pointer for the duration
//:of the program.
///// int fun( DestroyWindow )( void* han_win ){
///// 
/////     //:Grab function pointer to: "DestroyWindow":
/////     ////////////////////////////////////////////////////////////
/////     TYP(FUN) VAR(DestroyWindow)=
/////     FUN(GetProcAddress)("dll_u32","DestroyWindow");
///// 
/////     if( ((void*)0) != VAR(DestroyWindow) ){
/////         D("[SUCCESS:GOT_FUNC_PTR:DestroyWindow]");
/////     }else{
/////         H("[FAILURE:GOT_FUNC_PTR:DestroyWindow]");
/////     };;
/////     ////////////////////////////////////////////////////////////
///// 
/////     int RET( DestroyWindow )=((int)
/////     ((TYP(F_01))VAR(DestroyWindow))(
/////         han_win
/////     ));;
///// 
/////     return( RET( DestroyWindow ) );
///// };;

    ////////////////////////////////////////////////////////////
    //- DONT DO THIS:                                        -//
    //- 1: Synonymous ways of referring to the same thing    -//
    //-    in code is BAD. (harder to find all references)   -//
    //-                                                      -//
    //- 2: The original reason you were about to do this     -//
    //-    was you saw TYP(LoadIconA) when it should have    -//
    //-    been:       INS(LoadIconA).                       -//
    //-                                                      -//
    //-    Adding synonym would make bug harder to spot.     -//
    //-                                                      -//
    //:In case you want to refer to function pointer's
    //:type as the name of the function pointer:
    //: typedef     TYP(CreateWindowExW  ) TYP(FUN);
    //: typedef     TYP(GetDesktopWindow ) TYP(FUN);
    //: typedef     TYP(RegisterClassExW ) TYP(FUN);
    //: typedef     TYP(LoadIconA        ) TYP(FUN);
    //: typedef     TYP(LoadCursorA      ) TYP(FUN);
    //: typedef     TYP(GetModuleHandleW ) TYP(FUN);
    //: typedef     TYP(DefWindowProcW   ) TYP(FUN);
    //: typedef     TYP(DestroyWindow    ) TYP(FUN);
    //: typedef     TYP(PostQuitMessage  ) TYP(FUN);    
    ////////////////////////////////////////////////////////////

    //:Problem with PFN(SomeFunction)
    //:
    //:1: Is it a TYPE or the actual pointer?
    //:2: Since you do: FunctionsThisWay
    //:   and variables_this_way
    //:   Is there really any benifit since you can tell:
    //:
    //:  INS( SomeThing  )   <-- function pointer instance
    //:  INS( some_thing )   <-- data instance
    //:  TYP( FUN )          <-- A TYPE that is "function" (PFN)
    //:  FUN( SomeThing  )   <-- A function name

//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER|//
#define lib MACRO_project_prefix_HIDDEN  //~Private~  //| 01 |//
#define LIB MACRO_project_prefix_VISIBLE //~Public~~  //| 02 |//
#define GM1( a , b )      a## _ ##b          // GLUE  //| 03 |//
#define GM2( a , b ) GM1( a   ,   b )        // GLUE  //| 04 |//
#define K_1( a,b,c )      a## _ ##b## _ ##c  // GLUE  //| 05 |//
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )// GLUE  //| 06 |// 
#define VAR(  nam  ) GM2( VAR   ,   nam )// Local_Var //| 07 |//
#define EII(  nam  ) K_2( LIB, EII, nam )// SEE[EII]  //| 08 |//     
#define MEM(  nam  ) K_2( LIB ,MEM, nam )// Member    //| 09 |//
#define INS(  nam  ) K_2( LIB ,INS, nam )// INS:INST  //| 10 |// 
#define FUN(  nam  ) K_2( LIB ,FUN, nam )// FUN:FUNC  //| 11 |//                       
#define TYP(  nam  ) K_2( LIB ,TYP, nam )// TYP:TYPE  //| 12 |//   
#define ARG(  nam  ) GM2(      ARG, nam )// Argument  //| 13 |//
#define RET(  nam  ) GM2(      RET, nam )// RET___Var //| 14 |//      
#define BRA(  nam  ) K_2( lib, bra, nam )// BranchTyp //| 15 |//      
#define SUB(  nam  ) K_2( lib, sub, nam )// SubInstan //| 16 |//          
#define var(  nam  ) GM2( v_2020_04_25_1007PM , nam ) //| 19 |//
#define eii(  nam  ) GM2( e_2020_04_25_1007PM , nam ) //| 20 |//     
#define mem(  nam  ) GM2( m_2020_04_25_1007PM , nam ) //| 21 |//       
#define ins(  nam  ) GM2( i_2020_04_25_1007PM , nam ) //| 22 |//                  
#define fun(  nam  ) GM2( f_2020_04_25_1007PM , nam ) //| 23 |// 
#define typ(  nam  ) GM2( t_2020_04_25_1007PM , nam ) //| 24 |//
#define arg(  nam  ) GM2( a_2020_04_25_1007PM , nam ) //| 25 |//
#define ret(  nam  ) GM2( r_2020_04_25_1007PM , nam ) //| 26 |//  
#define bra(  nam  ) GM2( b_2020_04_25_1007PM , nam ) //| 27 |//  
#define sub(  nam  ) GM2( s_2020_04_25_1007PM , nam ) //| 28 |// 
#define obj(  nam  ) GM2( o_2020_04_25_1007PM , nam ) //| 29 |// 
#define poi(  nam  ) GM2( p_2020_04_25_1007PM , nam ) //| 30 |// 
#define siz(   N   ) GM2( S_2020_04_25_1007PM ,  N  ) //| 31 |//
#define num(   N   ) GM2( N_2020_04_25_1007PM ,  N  ) //| 32 |//
#define arr(   N   ) GM2( A_2020_04_25_1007PM ,  N  ) //| 33 |//
#define dex(   N   ) GM2( D_2020_04_24_1007PM ,  N  )
#define  H    fun( Halt )                             //| 37 |//
#define  D    fun( Dmsg ) // DebugPrint/DebugMessage  //| 38 |//
#define NIL ((void*)0)                                //| 39 |//
#define E_S(  end  )   ;  // END_STRUCT               //| 40 |//
#define E_F(  end  )      // END_FUNCTION             //| 41 |//
#define G_1(G,a    ) G ##_## a
#define G_2(G,a,b  ) G ##_## a ##_## b
#define G_3(G,a,b,c) G ##_## a ##_## b ##_## c
#define g_1(a      ) G_1( lib, a      ) //:FILE_SCOPE
#define g_2(a,b    ) G_2( lib, a,b    ) //:FILE_SCOPE 
#define g_3(a,b,c  ) G_3( lib, a,b,c  ) //:FILE_SCOPE 
#define U32 unsigned           int
#define I32 signed             int
#define U64 unsigned long long int
#define I64 signed   long long int
//:USE: Getters or make it an INS(file_scope_var)     //| -- |//
//:     If you want some type of public access.       //| -- |//
//:NO:  SIZ(   N   ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//
//:NO:  NUM(   N   ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//
//:NO:  ARR(   N   ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//
//:NO:  OBJ(  nam  ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//      
//:NO:  POI(  nam  ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//  
//:NO:  g_4: SEE[ NESTING_RULE_NO_DEEPER_THAN_3 ]     //| -- |//
//:NO:  v_#: Confused as local var.     USE: g_#      //| -- |//
//:NO:  f_#: Confused with: F_## types. USE: g_#      //| -- |//
#define termin //:termin:TERMINAL member/variable     //| -- |//
#define s ;    //:END_OF_STATEMENT_OR_DEFINE_LINE     //| -- |//
#define S ;    //:END_OF_STATEMENT_OR_DEFINE_LINE     //| -- |//
#define _      //:END_OF_STATEMENT_OR_DEFINE_LINE     //| -- |//
//|____________________________________________|V4_MEGAHEADER|//
//:CHAINFILE_MACRO:  CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM://

    //[[////////////////////////////////////////////////////]]//
    //[]////#   Experiment:                            #////[]//
    //[]////#   Instead of trying to make something    #////[]//
    //[]////#   pronouncable, abbreviation rules will  #////[]//
    //[]////#   be the first three letters of word.    #////[]//
    //[]////#   All variables 2 words long.            #////[]//
    //[[////////////////////////////////////////////////////]]//

    //:PATH_TO_THIS_FILE_AS_ALL_CAPITAL_MACRO:
    #define  SRC_VULKAN_SETUP_MAIN ( 7623 )

//:CMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCM  :CHAINFILE_MACRO://
//[1111111111111111111111111111111111111111111111111111111111]//

    //:Things I'd like you to notice first:
    #define E extern TYP(FUN) //:////////////////////////////://
            E INS(vkCreateInstance);
            E INS(vkEnumerateInstanceExtensionProperties);
    #undef  E //:////////////////////////////////////////////://

//[1111111111111111111111111111111111111111111111111111111111]//
//:HALT_and_DEBUG: HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD://                                      
    static void fun(Halt)( const char* msg ){printf( //:- - -://                       
    "[SRC_VULKAN_SETUP_MAIN:Halt]:%s\n"
    , msg);;fflush(stdout);exit(0xF0);}//:- - - - - - - - - -://   
    static void fun(Dmsg)( const char* msg ){printf(
    "[SRC_VULKAN_SETUP_MAIN:Dmsg]:%s\n"
    ,msg);;fflush(stdout);}//:- - - - - - - - - - - - - - - -://
//:HDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHDHD :HALT_and_DEBUG://
//:VULKAN_DLL_FUNCTION_POINTERS:////:////////////////////////://

    #define F TYP(FUN) //:///////////////////////////////////://
    #define N =( NIL );//:///////////////////////////////////://
            F INS(vkCreateInstance)                            N
            F INS(vkEnumerateInstanceExtensionProperties)      N
    #undef  N //:////////////////////////////////////////////://
    #undef  F //:////////////////////////////////////////////://

//:////////////////////////:////:VULKAN_DLL_FUNCTION_POINTERS://
//:TYPEDEFS_NODEPS: :T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0://

    //:Typedefs that do not rely on struct definitions.
    typedef void* typ(        vuk_ins) ;//:VkInstance
 
    struct typ(app_inf) {          //:VkApplicationInfo
        unsigned int      sType;   //:VkStructureType
        const void*       pNext;
        const char*       pApplicationName;
        unsigned int      applicationVersion; //:uint32_t
        const char*       pEngineName;
        unsigned int      engineVersion;      //:unsigned int
        unsigned int      apiVersion;         //:unsigned int
    }E_S(app_inf)

    //:VkExtensionProperties 
    struct TYP(ext_pro){
        //:ext_nam: extensionName
        char MEM(ext_nam)[ 256 /*VK_MAX_EXTENSION_NAME_SIZE*/ ];

        //:spe_ver: specVersion
        U32 MEM(spe_ver); /** uint32_t **/  

    }E_S(ext_pro)

//:T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0T0: :TYPEDEFS_NODEPS://
//:TYPEDEFS_01_DEP:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1://
    //:-------:cre_inf.vuk_ins:------------------------------://
    struct typ(cre_inf_vuk_ins) {   //:VkInstanceCreateInfo
        unsigned int         sType; //:VkStructureType
        const   void*        pNext;
        unsigned int         flags;

                             //:AKA:pApplicationInfo 
        const struct         //:AKA:VkApplicationInfo*
                             typ(app_inf)* 
                             poi(app_inf);
                             
        unsigned      int    enabledLayerCount;
        const char* const*   ppEnabledLayerNames;

        //:Is "const char**" same as "const char* const*" ?
        //:In fact.. Both are "char**" with extra constraints.

        unsigned     int     enabledExtensionCount;
        const char* const*   ppEnabledExtensionNames;
    }E_S(cre_inf_vuk_ins)
//:T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1T1:TYPEDEFS_01_DEP://
//:FILESCOPE_GLOBALS::GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG://

    //:Global variables used to setup our main Vulkan_Struct.
    //:( Vulkan_Struct == struct typ(vuk_mai) == vulkan_main )
    //:There should only be ONE reference to these used to
    //:populate the struct, and then always use the struct
    //:reference. Failure to do so will result in
    //:spaghetti code.

    //:wanted_instance_extensions
    int   g_2(ext_ins,wan_num)=( 2 );  
    char* g_2(ext_ins,wan_arr)[  2 ]={
        "VK_KHR_surface"
    ,   "VK_KHR_win32_surface"
    };

    //:WHAT_INSTANCE_EXTENSIONS_ARE_AVALIABLE:                 _
    //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 49 ]                       _
    //:NO_SUCH_TYPE:VkInstanceExtensionProperties:             _
    //:THE_TYPE_IS :VkExtensionProperties                      _
    #define E_P  struct TYP(ext_pro)                           _
    #define CAP ( 4 ) /** Maximum_Capacity_Of_Array **/        _
    #define NUM (0-1) /** Number_Of_Valid_Entries:  **/        _
            int  g_2(ext_ins,pro_cap)=(CAP)                    S
            int  g_2(ext_ins,pro_num)=(NUM)                    S
            E_P  g_2(ext_ins,pro_arr)[ CAP ]={0}               S
    #undef  E_P  ///                                           _
    #undef  CAP  ///                                           _
    #undef  NUM  ///                                           _

//:GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG::FILESCOPE_GLOBALS://
//:VULKAN_STRUCT:VSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVS://
    struct typ(vuk_mai){ //:vulkan_main.
 
        struct
        typ(app_inf)   //:VkApplicationInfo
        mem(app_inf);  //:VkApplicationInfo

        termin
        typ(vuk_ins)   //:VkInstance/VulkanInstance
        mem(vuk_ins);  //:VkInstance/VulkanInstance

        struct bra(ext_ins){//:extensions:INSTANCE
            int    mem(wan_num);//:wanted_instance_extensions
            char** mem(wan_arr);//:wanted_instance_extensions
    
            //:InstanceExtensionProperties  //~//////////////://
            #define E_P struct TYP(ext_pro) //://////////////://
                //:typ(vuk_mai).sub(ext_ins).mem(pro_cap);
                //:typ(vuk_mai).sub(ext_ins).mem(pro_num);
                //:typ(vuk_mai).sub(ext_ins).mem(pro_arr);
                int    mem(pro_cap); //: properties_capacity
                int    mem(pro_num); //: properties_numberof
                E_P*   mem(pro_arr); //: properties_array
            #undef E_P //:///////////////////////////////////://

        }sub(ext_ins);
        
        struct bra(cre_inf){ //:cre_(ate)_inf_(o)
 
            struct //:ins(vuk_mai).sub(cre_inf).mem(vuk_ins);
            typ(cre_inf_vuk_ins)   //:VkInstanceCreateInfo
            mem(        vuk_ins);  //:VkInstanceCreateInfo

        }sub(cre_inf); //:///////////////////////////////////:// 


    }ins(vuk_mai)={
        0
    }E_S(vuk_mai)
//:VSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVSVS:VULKAN_STRUCT://

    //://////////////////////////////////////////////////////://
    static unsigned int fun(MakVer)( //:VK_MAKE_VERSION://///://
        unsigned int major
    ,   unsigned int minor
    ,   unsigned int patch
    ){
        unsigned int ret(mak_ver);
        ret(mak_ver) =(
            (((major) << 22) | ((minor) << 12) | (patch))
        );;
        return( ret(mak_ver) );
    }//://///////////////////////////////////////////////////://

//[MAIN:(BELOW):---------------------------------------------]//
//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
    
    void EII(SRC_VULKAN_SETUP_main)( void )  //://///////////://
    {                     

    //:Before doing any vulkan setup, front load any needed
    //:function pointers from vulkan-1.dll:

    //:Use: "GetProcAddress" code for this.
    //:     Modify it to recognize "vuk_dll" as shorthand
    //:     code for "vulkan-1.dll"

    INS(vkCreateInstance)=FUN(GetProcAddress)(
    /**/    "dll_vuk" //:vulkan-1.dll
    ,       "vkCreateInstance" );;

    //:vkEnumerateInstanceExtensionProperties
    
    INS(vkEnumerateInstanceExtensionProperties)=
    FUN(GetProcAddress)(
    /**/ "dll_vuk"
    ,    "vkEnumerateInstanceExtensionProperties"
    );;

                   
    #define vkm ins(vuk_mai) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    //:------------------------------------------------------://

        //:W:WantedInstanceExtensions:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://

        //: Loading: wanted_instance_extensions from
        //:          private file-scope variable into
        //:          our private struct.

        //:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
        #define NUM vkm.sub(ext_ins).mem(wan_num)  _ _ _ _ _ _ _
        #define ARR vkm.sub(ext_ins).mem(wan_arr)  _ _ _ _ _ _ _
                NUM  =  g_2(ext_ins     ,wan_num)              s
                ARR  =  g_2(ext_ins     ,wan_arr)              s
        #undef  ARR  /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  NUM  /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        //:WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW://
        //:V:WantedInstanceExtensions:_______________________://
        //:VkApplicationInfo:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:AIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAI://
        #define MV fun(MakVer)         _ _ _ _ _ _ _ _ _ _ _ _ _
        #define AI vkm.mem(app_inf)    _ _ _ _ _ _ _ _ _ _ _ _ _
                AI.sType /**app_inf**/ =(0 /**app_inf**/ )     s
                AI.pApplicationName    = "HELLO_TRIANGLE"      s
                AI.applicationVersion  = MV(1,0,0)             s
                AI.pEngineName         = "No_Engine"           s
                AI.engineVersion       = MV(1,0,0)             s
                AI.apiVersion          = MV(1,0,0)             s
        #undef  AI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  MV /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        //:AIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAI://
        //:VkApplicationInfo:________________________________://
        //:VkInstanceCreateInfo:¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯://
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 48 ](BottomOfPage)   ://
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        #define AI vkm.mem(app_inf)              _ _ _ _ _ _ _ _
        #define VI vkm.mem(vuk_ins)              _ _ _ _ _ _ _ _
        #define CI vkm.sub(cre_inf).mem(vuk_ins) _ _ _ _ _ _ _ _
                                                               _
                CI.sType = 1 /**1==INSTANCE_CREATE_INFO**/     s
                CI.poi(app_inf) = &( AI )                      s
                                                               _
            //:NUM:wanted_instance_extensions_count            _
            //:ARR:wanted_instance_extensions                  _
            #define NUM vkm.sub(ext_ins).mem(wan_num)  _ _ _ _ _
            #define ARR vkm.sub(ext_ins).mem(wan_arr)  _ _ _ _ _
            #define READONLY (const char* const*)      _ _ _ _ _
                                                               _
                CI.enabledExtensionCount  =  (           NUM ) s
                CI.ppEnabledExtensionNames=  ( READONLY  ARR ) s
                                                               _
                //:not going to use the "use_validation_layers"_
                //:switch like in VG03.ALL. Look how crazy     _
                //:this code is. You've obviously decided      _
                //:to play with the safteys off.               _
                CI.enabledLayerCount  = 0                      s
                CI.ppEnabledLayerNames=NIL                     s
                                                               _
            #undef  READONLY /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
            #undef  ARR      /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
            #undef  NUM      /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

            if( NIL == INS(vkCreateInstance) ){
                D("[NIL_FUNCTION_PTR:vkCreateInstance!]");
                H("[DID_YOU_FORGET_TO_LOAD_VULKAN_PTR?]");
            };;
            
            unsigned int res=(
                //:CAST:
                (unsigned int)(unsigned long long)

                //:FUNC:
                ( (TYP(F_03)) INS(vkCreateInstance)  )

                //:ARGS:
                (
                    &(CI) //:VkInstanceCreateInfo
                ,  ( NIL )
                ,   &(VI) //:VkInstance
                )
            );;
            if( 0 != res ){
                H( "[FAIL:vkCreateInstance]");
            }else{
                D( "[PASS:vkCreateInstance]");
            };;

        #undef  CI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  VI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        #undef  AI /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 48 ](BottomOfPage)   ://
        //:CICICICICICICICICICICICICICICICICICICICICICICICICI://
        //:CI:VkInstanceCreateInfo:__________________________://

        //:SizeChecks:
        ;;;if( sizeof(U32) != 4 ){ 
            H("[FAIL:SIZECHECK:U32]"); 
        };;if( sizeof( struct TYP(ext_pro)  ) != 260 ){
            H("[FAIL:SIZECHECK:VkExtensionProperties]");
        };;

        //:EP:InstanceExtensionProperties:(BELOW):¯¯¯¯¯¯¯¯¯¯¯://
        //:EPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEP://
        #define VUK_FUN vkEnumerateInstanceExtensionProperties
        { //:SCOPE
            int res=(0-1);//:VkResult

            //:SizeChecks:
            if( sizeof(I32)!= 4 ){ H("[2020_04_27_0429AM-A]");}
            if( sizeof(U64)!= 8 ){ H("[2020_04_27_0429AM-B]");}

            int ava_num=(0-1); //:Available_Number(Amount)
            res=( (I32)(U64)
            (
                ((TYP(F_03))INS( VUK_FUN ))
                (
                    NIL //:<--Optional:FilterByValidationLayer
                ,   &( g_2(ext_ins,pro_num) ) //:extensionCount
                ,   NIL
                )
            ));
            if( res != 0 /**VK_SUCCESS**/ ){ 
                H("[2020_04_27:0419AM]");
            };;
    
            //:Do we have enough capacity to get everything?
            //://////////////////////////////////////////////://
            //:Keep it simple. We are not going to deal with
            //:malloc unless absolutely necessary. We can
            //:afford a bit of wasted space.
            if( ava_num > g_2(ext_ins,pro_cap) ){
                D("[WARN:CapacityNotLargeEnoughToGetAll]");
                D("[EXPECT:VK_INCOMPLETE]");
                g_2(ext_ins,pro_num) = g_2(ext_ins,pro_cap);
            }else{
                D("[OKAY:CapacityLargeEnoughToGetAll]");
                D("[EXPECT:VK_SUCCESS]");
                g_2(ext_ins,pro_num) = ava_num;
            };;
            //://////////////////////////////////////////////://

            res=( (I32)(U64)
            (
                ((TYP(F_03))INS( VUK_FUN ))
                (
                    //:SEE[ VK_TUT_2018 ]BOOK_PAGE[ 49 ]
                    //:"It takes an optional first parameter"
                    //:"that allows us to filter extensions "
                    //:"by a specific validation layer.     "
                    NIL //:<--Optional:FilterByValidationLayer
                ,   &( g_2(ext_ins,pro_num) ) //:extensionCount
                ,   &( g_2(ext_ins,pro_arr) ) //:pProperties
                )
            ));

            //:Did we get the expected success status?
            if( ava_num > g_2(ext_ins,pro_cap) ){
                if( res != 5 /**VK_INCOMPLETE**/ ){
                    H("[2020_04_27:0421AM-A]");
                };;
            }else{
                if( res != 0 /**VK_SUCCESS**/ ){
                    H("[2020_04_27:0421AM-A]");
                };;
            };;

            //:Copy over values to our main vulkan struct:
            vkm.sub(ext_ins).mem(pro_cap)=g_2(ext_ins,pro_cap);
            vkm.sub(ext_ins).mem(pro_num)=g_2(ext_ins,pro_num);
            vkm.sub(ext_ins).mem(pro_arr)=g_2(ext_ins,pro_arr);
            
            //:Loop over instance extensions as sanity check:
            #define E_P struct TYP(ext_pro) //://////////////://
                
                printf("\n[VkExtensionProperties:(BELOW)]\n");
                int  num(ext) = vkm.sub(ext_ins).mem(pro_num);
                E_P* arr(ext) = vkm.sub(ext_ins).mem(pro_arr);

                int     dex(ext) = 0;
                for(    
                /**/    dex(ext)= 0 
                ;       dex(ext) < num(ext) 
                ;       dex(ext)++
                ){
                    //:VkExtensionProperties 
                    printf("[extensionName]:%s\n"
                    , ( arr(ext)[ dex(ext) ] ).MEM(ext_nam) 
                    );;
                };;
                fflush(stdout);

            #undef E_P //:///////////////////////////////////://

        } //:SCOPE
        #undef  VUK_FUN  //://///////////////////////////////://
        //:EPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEPEP://
        //:EP:InstanceExtensionProperties:(ABOVE):___________://

        //:WHEN DONE WITH SETUP:
        //:Do a check of entire struct to make sure every
        //:member is valid
    
    //:------------------------------------------------------://
    #undef  vkm  /// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    }E_F(SRC_VULKAN_SETUP_main)//:///////////////////////////://
    //://////////////////////////////////////////////////////://

//[MAIN:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM]//
//[MAIN:(ABOVE):---------------------------------------------]//


//|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|V4_MEGAHEADER|//
#undef  lib  //:-----------------------------------:////| 01 |//
#undef  LIB  //:-----------------------------------:////| 02 |//
#undef  GM1  //:-----------------------------------:////| 03 |//
#undef  GM2  //:-----------------------------------:////| 04 |//
#undef  K_1  //:-----------------------------------:////| 05 |//
#undef  K_2  //:-----------------------------------:////| 06 |// 
#undef  VAR  //:-----------------------------------:////| 07 |//
#undef  EII  //:-----------------------------------:////| 08 |//     
#undef  MEM  //:-----------------------------------:////| 09 |//
#undef  INS  //:-----------------------------------:////| 10 |// 
#undef  FUN  //:-----------------------------------:////| 11 |//                       
#undef  TYP  //:-----------------------------------:////| 12 |//   
#undef  ARG  //:-----------------------------------:////| 13 |//
#undef  RET  //:-----------------------------------:////| 14 |//      
#undef  BRA  //:-----------------------------------:////| 15 |//      
#undef  SUB  //:-----------------------------------:////| 16 |//          
#undef  var  //:-----------------------------------:////| 19 |//
#undef  eii  //:-----------------------------------:////| 20 |//     
#undef  mem  //:-----------------------------------:////| 21 |//       
#undef  ins  //:-----------------------------------:////| 22 |//                  
#undef  fun  //:-----------------------------------:////| 23 |// 
#undef  typ  //:-----------------------------------:////| 24 |//
#undef  arg  //:-----------------------------------:////| 25 |//
#undef  ret  //:-----------------------------------:////| 26 |//  
#undef  bra  //:-----------------------------------:////| 27 |//  
#undef  sub  //:-----------------------------------:////| 28 |// 
#undef  obj  //:-----------------------------------:////| 29 |// 
#undef  poi  //:-----------------------------------:////| 30 |// 
#undef  siz  //:-----------------------------------:////| 31 |//
#undef  num  //:-----------------------------------:////| 32 |//
#undef  arr  //:-----------------------------------:////| 33 |//
#undef  dex
#undef   H   //:-----------------------------------:////| 37 |//
#undef   D   //:-----------------------------------:////| 38 |//
#undef  NIL  //:-----------------------------------:////| 39 |//
#undef  E_S  //:-----------------------------------:////| 40 |//
#undef  E_F  //:-----------------------------------:////| 41 |//
#undef  G_1  //:-----------------------------------://
#undef  G_2  //:-----------------------------------://
#undef  G_3  //:-----------------------------------://
#undef  g_1  //:-----------------------------------://
#undef  g_2  //:-----------------------------------://
#undef  g_3  //:-----------------------------------://
#undef  U32
//:USE: Getters or make it an INS(file_scope_var)     //| -- |//
//:     If you want some type of public access.       //| -- |//
//:NO:  SIZ(   N   ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//
//:NO:  NUM(   N   ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//
//:NO:  ARR(   N   ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//
//:NO:  OBJ(  nam  ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//      
//:NO:  POI(  nam  ) <<<<<<<<<<< USED_AS_LOCAL_MACROS //| -- |//  
//:NO:  g_4: SEE[ NESTING_RULE_NO_DEEPER_THAN_3 ]     //| -- |//
//:NO:  v_#: Confused as local var.     USE: g_#      //| -- |//
//:NO:  f_#: Confused with: F_## types. USE: g_#      //| -- |//
#undef  termin //:termin:TERMINAL member/variable     //| -- |//
#undef  s      //:END_OF_STATEMENT_OR_DEFINE_LINE     //| -- |//
#undef  S      //:END_OF_STATEMENT_OR_DEFINE_LINE     //| -- |//
#undef  _      //:END_OF_STATEMENT_OR_DEFINE_LINE     //| -- |//
//|____________________________________________|V4_MEGAHEADER|//


//:BATSIN: 
//:     bat: Branching_Type:
//:     sin: Sub___Instance:

//: ACTUAL: ARR_SIZ_NUM_RULES:
//:   TYPO: ARR_SIZ_NAM_RULES:
//:     "siz,num,arr" may also be built into the
//:     name of the variable instead of added as
//:     a "kind". Use whatever combination allows
//:     you to keep the base-name of the variable
//:     as xxx_xxx. 
//:         EX: siz(tik_tok)  arr(tik_tok)
//:         OR:     siz_tok       arr_tok
//:
//:     siz,num,arr are all local.
//:     They are not qualified with the library name
//:     or obfuscated because they are local variables.
//: 
//:     Do NOT make them file scope.

//: NESTING:
//| The answer to that is that if you need more than 3       |//
//| levels of indentation,you’re screwed anyway,and should   |//
//| fix your program.                                        |//
//| www.kernel.org/doc/html/v4.10/process/coding-style.html  |//


//:VK_TUT_2018:
//:     A PDF version of "vulkan-tutorial.com/"
//:     VK_TUT_2018 is my shortcut name that opens the
//:     tutorial on my computer.

#define lib MACRO_project_prefix_HIDDEN  //: Private  //: 01 ://
#define LIB MACRO_project_prefix_VISIBLE //: Public   //: 02 ://
#define GM1( a , b )      a## _ ##b      //: GLUEMAC  //: 03 ://
#define GM2( a , b ) GM1( a   ,   b )    //: GLUEMAC  //: 04 ://
#define K_1( a,b,c )      a## _ ##b## _ ##c  //:KIND  //: 05 ://
#define K_2( a,b,c ) K_1( a   ,   b   ,   c )//:KIND  //: 06 ://                                   
#define MAK(  nam  ) K_2( LIB ,MAK, nam )//:MAK:MACRO //: 07 ://   
#define TYP(  nam  ) K_2( LIB ,TYP, nam )//:TYP:TYPE  //: 08 ://   
#define INS(  nam  ) K_2( LIB ,INS, nam )//:INS:INST  //: 09 ://   
#define FUN(  nam  ) K_2( LIB ,FUN, nam )//:FUN:FUNC  //: 10 :// 
#define EXA(  nam  ) K_2( LIB ,EXA, nam )//:EXAMPLE   //: 11 :// 
#define EII(  nam  ) K_2( LIB ,EII, nam )//:INIT_FUNC //: 12 :// 
#define ASS   assert 

////////////////////////////////////////////////////////////////
int  INS(        AT_END_OF_CHAIN ) = ( 0 );
////////////////////////////////////////////////////////////////

int main( void ){

    printf("[HELLO_WORLD]\n");

    ////////////////////////////////////////////////////////////

    #if( SRC_MAINLOOP_LOOPTABLE >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        EII(SRC_MAINLOOP_looptable)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    ////////////////////////////////////////////////////////////

    #if( SRC_NATIVE_CALLWRAP_LOADLIBRARY >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        //:No code for this, just a stub. All logic
        //:is inside "GetProcAddress._"
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    ////////////////////////////////////////////////////////////

    #if( SRC_NATIVE_CALLWRAP_GETPROCADDRESS >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        EII(SRC_NATIVE_CALLWRAP_getprocaddress)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif

    ////////////////////////////////////////////////////////////
    
    #if(    SRC_NATIVE_PING  >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        FUN(SRC_NATIVE_ping)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif
    
    ////////////////////////////////////////////////////////////
    
    #if(    SRC_NATIVE_WINDOW_CREATION  >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        FUN(SRC_NATIVE_WINDOW_creation)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif
    
    ////////////////////////////////////////////////////////////
    
    #if(    SRC_VULKAN_SETUP_MAIN  >= 1 )
        ASS( INS( AT_END_OF_CHAIN ) <= 0 );
        EII(SRC_VULKAN_SETUP_main)();
    #else
        INS(AT_END_OF_CHAIN)++;
    #endif
    
    ////////////////////////////////////////////////////////////






    //:ML:Main_Loop: (AKA: LOOPTABLE):
    //:MLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLML://
    #if( SRC_MAINLOOP_LOOPTABLE >= 1 )
        
        printf("\n\n\n");
        printf("[Entering:MainLoop:USE[CTRL+V]TO[EXIT_EXE]]\n");
        printf("\n\n\n");
        fflush(stdout);
        
        //: Loop_Forever_Because_This_Is_The_Main_Game_Loop
        //: SRC/MAINLOOP/looptable._ :: FUN(Loop):
        FUN(Loop)(/**void**/);

    #endif
    //:MLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLMLML://



}


#undef  lib ////////////////////////////////////////////: 01 ://
#undef  LIB ////////////////////////////////////////////: 02 ://
#undef  GM1 ////////////////////////////////////////////: 03 ://
#undef  GM2 ////////////////////////////////////////////: 04 ://
#undef  K_1 ////////////////////////////////////////////: 05 ://
#undef  K_2 ////////////////////////////////////////////: 06 ://                                   
#undef  MAK ////////////////////////////////////////////: 07 ://   
#undef  TYP ////////////////////////////////////////////: 08 ://   
#undef  INS ////////////////////////////////////////////: 09 ://   
#undef  FUN ////////////////////////////////////////////: 10 ://
#undef  EXA ////////////////////////////////////////////: 11 ://
#undef  EII ////////////////////////////////////////////: 12 ://
#undef  ASS



    //:Undefine Chain Files:
    //:There is no "CHAIN_FILE.DEFINE._"
    //:File because those macros are added when
    //:different files are concatted together in the
    //:building bash script.

    //:looptable._
    #undef SRC_MAINLOOP_LOOPTABLE              

   

    //:LoadLibrary._
    #undef SRC_NATIVE_CALLWRAP_LOADLIBRARY  

    //:GetProcAddress._
    #undef SRC_NATIVE_CALLWRAP_GETPROCADDRESS 

    //:ping:
    #undef SRC_NATIVE_PING

    //:creation._
    #undef SRC_NATIVE_WINDOW_CREATION
    


   

#undef  MACRO_project_prefix_HIDDEN   
#undef  MACRO_project_prefix_VISIBLE  


