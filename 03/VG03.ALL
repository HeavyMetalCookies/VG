
//#FILE_REGION[ W32/DLLL/DLLL.COMSET ]BEG#####################//


//| Only choose one to set to 1 |//
#define COMPILE_FOR_windows_10_64bit 1


//#FILE_REGION[ W32/DLLL/DLLL.COMSET ]END#####################//
//#FILE_REGION[ W32/DLLL/TARG/W10.X64 ]BEG####################//

#if( COMPILE_FOR_windows_10_64bit >= 1 ) //:VGAURD
//////////////////////////////////////////////////

//:PS2_3: Pebwalk_Substitution
//: "_3": More Widdling Away.
//:       Moved from _2 to _3 in order to remove
//:       large chunks of code that are never
//:       executed. (And thus I cannot test the)
//:       (validity of.)


//| 0x00: IMAGE_DATA_DIRECTORY    . VirtualAddress        |//
//| 0x70: IMAGE_OPTIONAL_HEADER   . DataDirectory         |//
//| 0x1C: IMAGE_EXPORT_DIRECTORY  . AddressOfFunctions    |//
//| 0x20: IMAGE_EXPORT_DIRECTORY  . AddressOfNames        |//
//| 0x24: IMAGE_EXPORT_DIRECTORY  . AddressOfNameOrdinals |//
//| 0x18: IMAGE_EXPORT_DIRECTORY  . NumberOfNames         |//
//| 0x18: IMAGE_NT_HEADERS        . OptionalHeader        |//
//| 0x3C: IMAGE_DOS_HEADER        . e_lfanew              |//
//| 0x00: LIST_ENTRY              . Flink                 |//
//| 0x20: LDR_DATA_TABLE_ENTRY    .Reserved2[0]           |//
//|                                                       |//
//| 0x48: LDR_DATA_TABLE_ENTRY    .FullDllName            |//
//| 0x08:                          FullDllName.Buffer     |//
//|                                                       |//
//| 0x18: PEB.Ldr                                         |//
//| 0x20:     Ldr.InMemoryOrderModuleList                 |//
//| 0x00:         InMemoryOrderModuleList.Flink           |//

// #define WIN32_LEAN_AND_MEAN
// #include <Windows.h>
// #include <winternl.h>
// #include <malloc.h>
// 
// #ifdef _M_AMD64
// #include <intrin.h>
// #elif defined(_M_ARM)
// #include <armintr.h>
// #endif



#include <string.h> //: strcmp


//|M:Macros: (Non-Local Macros)________________|//
//|MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM|//
//:See MSDN documentation on:
//:"ImageDirectoryEntryToDataEx"
#define MACRO_x_IMAGE_DIRECTORY_ENTRY_EXPORT 0

//:IMAGE_DATA_DIRECTORY struct is 128 bytes.
//:When doing address indexing math, multiply
//:by this value.
#define MACRO_sizeof_IMAGE_DATA_DIRECTORY 128

#define MACRO_WINAPI __stdcall
#define MACRO_WINDOWS_xxx_MB_OK 0x00000000L
//|MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM|//



typedef
    const char* //:<--ImmutableStringPointer
    TYPEDEF_LPCSTR;

typedef
    unsigned long //:32 bits, unsigned
    TYPEDEF_ULONG;

typedef
    unsigned long long //:64 bits, unsigned.
    TYPEDEF_DWORD_PTR;

typedef 
    const unsigned short *  TYPEDEF_LPCWSTR;

//:Though "HMODULE" is a void*, you cannot mix
//:"void*" with window's HMODULE because HMODULE
//:is declared using DECLARE_HANDLE hack. Which
//:creates a pointer to a dummy struct.
typedef 
    void* TYPEDEF_HMODULE;


//|FT:Function_Typedefs________________________|//
//|FTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFT|//

typedef 
    TYPEDEF_HMODULE                  //:RETURNS
    (MACRO_WINAPI *LoadLibraryAF)  //:CC+NAME
    (TYPEDEF_LPCSTR lpFileName    ); //:PARAM_L

typedef
    unsigned long long               //:RETURNS
    ( __stdcall  *TYPEDEF_FARPROC )  //:NAME
    ( /**NOT_SPECIFIED != void**/ ); //:PARAMS

typedef 
    TYPEDEF_FARPROC
    (MACRO_WINAPI *GetProcAddressF)
    (
        TYPEDEF_HMODULE hModule
    ,   TYPEDEF_LPCSTR lpProcName
    );

//|FTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFT|//

//////////////////////////////////////////////////

LoadLibraryAF
dll_LoadLibraryA   =NULL;

GetProcAddressF
dll_GetProcAddress =NULL;
//////////////////////////////////////////////////



#include <stdlib.h> //: exit()
#include <stdio.h> //:printf(...)

//:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX://  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    //:PERMA:SHORTCUT[ PASTE_COM_WID_STR_INS ]      //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//:CWSI: Compare_Wide_Strings_Insensitive           //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
#include <stdio.h> //:for: printf(...)              //[CWSI:2019_11_28]//
#include <assert.h>                                 //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
int                                                 //[CWSI:2019_11_28]//
JMIM_lstrcmpiW( //[lstrcmpiW]//                     //[CWSI:2019_11_28]//
    const unsigned short* str_1                     //[CWSI:2019_11_28]//
,   const unsigned short* str_2                     //[CWSI:2019_11_28]//
){                                                  //[CWSI:2019_11_28]//
    void JMIM_lstrcmpiW_LAZYTEST();                 //[CWSI:2019_11_28]//
         JMIM_lstrcmpiW_LAZYTEST();                 //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    #define U unsigned short /////////////////////  //[CWSI:2019_11_28]//
    #define S   signed short /////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    int dex =(0-1);                                 //[CWSI:2019_11_28]//
    U r_e_s_u_l_t ;                                 //[CWSI:2019_11_28]//
    U chr_1       ;                                 //[CWSI:2019_11_28]//
    U chr_2       ;            //: 97 - 65          //[CWSI:2019_11_28]//
    U       sub_to_get_uppercase = 'a'-'A';         //[CWSI:2019_11_28]//
    assert( sub_to_get_uppercase > 0 );             //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    #undef  U ////////////////////////////////////  //[CWSI:2019_11_28]//
    #undef  S ////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    while( 1 ){                                     //[CWSI:2019_11_28]//
        dex++;                                      //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        chr_1=str_1[ dex ];                         //[CWSI:2019_11_28]//
        chr_2=str_2[ dex ];                         //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        //:Convert both characters to uppercase:    //[CWSI:2019_11_28]//
        //////////////////////////////////////////  //[CWSI:2019_11_28]//
        if( chr_1 >= 'a' && chr_1 <= 'z' ){         //[CWSI:2019_11_28]//
            chr_1 = chr_1 - sub_to_get_uppercase;   //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
        if( chr_2 >= 'a' && chr_2 <= 'z' ){         //[CWSI:2019_11_28]//
            chr_2 = chr_2 - sub_to_get_uppercase;   //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
        //////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
                 r_e_s_u_l_t = (chr_1 - chr_2);     //[CWSI:2019_11_28]//
        if( 0 != r_e_s_u_l_t ){ break; };           //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        //:Null terminator found. Exit.             //[CWSI:2019_11_28]//
        if(0==chr_1 || 0==chr_2){                   //[CWSI:2019_11_28]//
            break;                                  //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
    };;                                             //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    return( (int)r_e_s_u_l_t );                     //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//////////////////////////////////////////////////  //[CWSI:2019_11_28]//
static char JMIM_lstrcmpiW_TESTED = 0;              //[CWSI:2019_11_28]//
static char JMIM_lstrcmpiW_TESTIN = 0;              //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
void                                                //[CWSI:2019_11_28]//
JMIM_lstrcmpiW_TESTIT(){                            //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTED=0;                        //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTIN=1;                        //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    int res;                                        //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    const unsigned short* A1=L"WIDE";               //[CWSI:2019_11_28]//
    const unsigned short* B1=L"wide";               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    res = JMIM_lstrcmpiW(A1,B1);                    //[CWSI:2019_11_28]//
    assert( 0==res );                               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    // ---------------------------------------- //  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    const unsigned short* A2=L"JEFF";               //[CWSI:2019_11_28]//
    const unsigned short* B2=L"PAUL";               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    res = JMIM_lstrcmpiW(A2,B2);                    //[CWSI:2019_11_28]//
    assert( 0!=res );                               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTIN=0;                        //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTED=1;                        //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
void                                                //[CWSI:2019_11_28]//
JMIM_lstrcmpiW_LAZYTEST(){                          //[CWSI:2019_11_28]//
    if( 0 == 0                                      //[CWSI:2019_11_28]//
    &&  0 >= JMIM_lstrcmpiW_TESTED //:NOT_TESTED    //[CWSI:2019_11_28]//
    &&  0 >= JMIM_lstrcmpiW_TESTIN //:NOT_TESTING   //[CWSI:2019_11_28]//
    ){       JMIM_lstrcmpiW_TESTIT(); };            //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//////////////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX://  //[CWSI:2019_11_28]//





void*
VOID_T16B( //:TruncatePointerTo16Bits (2bytes)

    void* addr

){

    #define U unsigned long long /////////////////

    /////////0xR_G_B_AA==4bytes,  32bits
    U mask = 0x0000FFFF ;     //: 16bits
    U addr_u = (U)addr;       //: Unsigned Long
    U addr_t = addr_u & mask; //: Truncated
    
    return( (void*)addr_t );

    #undef  U ////////////////////////////////////

}//[;]//

void*
VOID_T32B( //:TruncatePointerTo32Bits (4bytes)
    void* addr
){
    #define U unsigned long long /////////////////

    /////////0xR_G_B_AA==4bytes,32bits
    U mask = 0xFFFFFFFF ;
    U addr_u = (U)addr;       //:Unsigned Long
    U addr_t = addr_u & mask; //:Truncated
    
    return( (void*)addr_t );

    #undef  U ////////////////////////////////////
}//[;]//

//:Add two addresses together.
void*
VOID_Plus(
/**/    void* addr_01
,       void* addr_02
){

    #define U unsigned char //////////////////////
    #define L unsigned long long /////////////////

        //:addr_01 is casted to a byte pointer
        //:so that offsets from adding addr_02
        //:will be multiplied by 1 (sizeof byte)
        //:rather than 4 or 8.

        U* A_1=(U*)addr_01;
        L  A_2=(L )addr_02;
        U* A_3=( A_1 + A_2 );
        return( (void*)A_3 );

    #undef  U ////////////////////////////////////
    #undef  L ////////////////////////////////////

}//[;]//

//:Perform: (addr_01 - addr_02 )
void*
VOID_Minu(
/**/    void* addr_01
,       void* addr_02
){

    #define U unsigned char //////////////////////
    #define L unsigned long long /////////////////

    U* A_1=(U*)addr_01;
    L  A_2=(L )addr_02;
    U* A_3=( A_1 - A_2 );
    return( (void*)A_3 );

    #undef  U ////////////////////////////////////
    #undef  L ////////////////////////////////////

}//[;]//


//|Example Usage:                              |//
//|Find the relative offset in bytes from      |//
//|the base address "pOptionalHeader"          |//
//|to the member "DataDirectory"               |//
//|ANSWER: (0x70)                              |//
//|--------------------------------------------|//
//|  VOID_PROS(                                |//
//|      pOptionalHeader                       |//
//|  , &(pOptionalHeader->DataDirectory)       |//
//|  ,  "pOptionalHeader .DataDirectory"       |//
//|  );;                                       |//
void
VOID_PROS( //:PROS:Print_Relative_OffSet
/**/    void* base_address
,       void* seek_address
,       const char*    msg
){
    if( base_address > seek_address ){
        printf("[Bad_Ordering]\n");
        fflush(stdout);
        exit(666);
    };;

    //:   os:offset/delta:
    void* os = VOID_Minu(
        seek_address //:<----LARGER_VALUE
    ,   //  -     //
        base_address //:<----SMALLER_VALUE
    );;

    printf(
        "[PROS:msg]:%s\n[PROS:os]:%p\n"
    ,    msg,os
    );;

}//[;]//

void* 
VOID_Seek( 

/**/    void* data
,       int byte_offset 

){

    //:In order to have the correct byte offset
    //:applied to the pointers, you have to make
    //:sure they are casted to byte pointers
    //:first. Casting to void* seems to work
    //:as well. But I wouldn't trust that. Since
    //:the size of a pointer is either 4 or
    //:8 bytes, so offsets being multiplied by
    //:4 or 8 with void* would not suprise me
    //:depending on the C compiler.

    #define U unsigned char //////////////////////

        //:A_0: Start_Address
        //:A_1: End___Address

        U* A_0=(U*)data;  
        U* A_1=( A_0 + byte_offset );

        return( (void*)A_1 );

    #undef  U ////////////////////////////////////

}//[;]//

void* 
VOID_Load( 

/**/    void* data 

){

    //:Assumming the data is a pointer,
    //:it holds the address to some object
    //:somewhere else. We want to load that
    //:address.

    void** ptr = (void**)data; //:POINTER
    void*  aod = *(ptr);       //:ADDRESS_OR_DATA

    return( aod );
}//[;]//


//:Perform a series of memory offsets on an
//:address until you get to whatever destination
//:you are looking for.
//:
//:NOTE: Add 'A' and Seek 'S' instructions
//:      have the same result. But Add('A') was
//:      originally written for adding an address
//:      and Seek('S') was originally for a
//:      hexadecimal relative offset from the
//:      base address of a struct.
void*
VOID_Inst(
/**/    void*          initial_address  
,       unsigned long long* instruction_arr
){
    //:Instructions come in pairs:
    //:1: Instruction Type (Op-code)
    //:2: Instruction Data

    //: 0x00:     :  Terminate_Instruction_Stream
    //: 0x53: 'S' :  SEEK (takes an offset)
    //: 0x4C: 'L' :  LOAD
    //:              DATA==0: Load Full Address
    //:              DATA==4: Truncate to 4 bytes.
    //: 0x41: 'A' :  ADD  (Add addresses  )
    //: 0x54: 'T' :  Truncate to n bytes.(data==n)


    int code_index = (0-1);
    int data_index = (0-1);
    int pair_index = (0-1);

    unsigned long long  code;
    unsigned long long  data;

    void*  p = initial_address;
    void** pp= NULL;

    while(1){
        pair_index++;

        code_index = pair_index*2;
        data_index = code_index+1;
        
        code = instruction_arr[ code_index ];
        data = instruction_arr[ data_index ];

        if( 'S' == code ){ //:SEEK

            #define U unsigned long long /////////
            void* base_address = p;
            U     byte_offset  =(U)data;
            #undef  U ////////////////////////////

            #define U unsigned char //////////////

                //:A_0: Start_Address
                //:A_1: End___Address

                U* A_0=(U*)    base_address ;  
                U* A_1=( A_0 + byte_offset );

                p=(void*)A_1;

            #undef  U ////////////////////////////
            

        }else
        if( 'L' == code ){ //:LOAD
            if(data==0x00){
                //:LEA(Load Affective Address)
                //:by de-referencing the pointer.
                pp=(void**)p;
                p=(*pp);
            }else{

                //:LEA(Load Affective Address)
                //:by de-referencing the pointer.
                pp=(void**)p;
                p=(*pp);


                //:TRUNCATE address AFTER loading:


                #define U unsigned long long ///////////|------------|//
                                                      //| 2019_11_28 |//
                void* addr = p;                       //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                //:addr_f: Address_Full               //| 2019_11_28 |//
                //:addr_t: Address_Truncated          //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                ///////////0x1234567812345678         //| 2019_11_28 |//
                U mask_8 = 0xFFFFFFFFFFFFFFFF;//64bits//| 2019_11_28 |//
                ///////////0xR_G_B_AA == 4bytes,32bits//| 2019_11_28 |//
                U mask_4 = 0xFFFFFFFF;//:4bytes,32bits//| 2019_11_28 |//
                U mask_2 = 0xFFFF    ;//:2bytes,16bits//| 2019_11_28 |//
                U mask   = 0;                         //| 2019_11_28 |//
                if( 2 == data ){ mask = mask_2; };    //| 2019_11_28 |//
                if( 4 == data ){ mask = mask_4; };    //| 2019_11_28 |//
                if( 8 == data ){ mask = mask_8; };    //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                U addr_f = (U)addr;       //:All_Bits //| 2019_11_28 |//
                U addr_t = addr_f & mask; //:32__Bits //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                p=( (void*)addr_t );                  //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                #undef  U //////////////////////////////|____________|//

            };;

        }else
        if( 'T'  == code ){ //:TRUNCATE_4:
        //:Truncate address to first T bytes,
        //:The rest will be zeros.

            #define U unsigned long long ///////////|------------|//
                                                  //| 2019_11_28 |//
            void* addr = p;                       //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            //:addr_f: Address_Full               //| 2019_11_28 |//
            //:addr_t: Address_Truncated          //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            ///////////0x1234567812345678         //| 2019_11_28 |//
            U mask_8 = 0xFFFFFFFFFFFFFFFF;//64bits//| 2019_11_28 |//
            ///////////0xR_G_B_AA == 4bytes,32bits//| 2019_11_28 |//
            U mask_4 = 0xFFFFFFFF;//:4bytes,32bits//| 2019_11_28 |//
            U mask_2 = 0xFFFF    ;//:2bytes,16bits//| 2019_11_28 |//
            U mask   = 0;                         //| 2019_11_28 |//
            if( 2 == data ){ mask = mask_2; };    //| 2019_11_28 |//
            if( 4 == data ){ mask = mask_4; };    //| 2019_11_28 |//
            if( 8 == data ){ mask = mask_8; };    //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            U addr_f = (U)addr;       //:All_Bits //| 2019_11_28 |//
            U addr_t = addr_f & mask; //:32__Bits //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            p=( (void*)addr_t );                  //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            #undef  U //////////////////////////////|____________|//

        }else
        if( 'A' == code ){  //:ADD address

            #define U unsigned char ////////////// 
            #define L unsigned long long ///////// 
            
                //|addr_01 is casted to a byte |//
                //|pointer so that offsets from|//
                //|adding addr_02 will be      |//
                //|multiplied by 1 (sizeof     |//
                //|byte) rather than 4 or 8.   |//
            
                void* addr_01 = p;
                void* addr_02 = (void*)data;
            
                U* A_1=(U*)addr_01;
                L  A_2=(L )addr_02;
                U* A_3=( A_1 + A_2 );
            
                p = ( (void*)A_3 );
            
            #undef  U //////////////////////////// 
            #undef  L //////////////////////////// 

        }else
        if( 0x00 == code ){ //:END_OF_STREAM

            break;
        
        }else{
            printf("[INVALID_OP_CODE]\n");
            fflush(stdout);
            exit(666);
        };;

    };;
    
    //:Return the resulting address from all
    //:of the operations:
    return( p );

}//[;]//


//:Like VOID_Inst, but the instruction stream
//:first instruction is always an intitial('I')
//:start address to load. Thus only one argument
//:is needed instead of two.
void*
VOID_Oper(
    unsigned long long* instruction_arr
){
    if( 'I' != instruction_arr[0] ){
        printf("[I:ShouldBeFirstInstruction]\n");
        fflush(stdout);
        exit(666);
    };;

    //:Change first instruction to "add"
    instruction_arr[0]='A';
   
    //:Starting at address 0 essentially
    //:will load initial start address.
    void* p = VOID_Inst( 0x00, instruction_arr );

    //:Change the first instruction back to
    //:'I' so calling code is unaware of our
    //:hacky ways.
    instruction_arr[0]='I';

    return( p );

}//[;]//


//|_M_IX86 Defined as the integer literal value|//
//|600 for compilations that target x86        |//
//|processors. This macro isn't defined for x64|//
//|or ARM compilation targets.                 |//
//|SOURCE[ M_IX86-url ]                        |//
#ifdef _M_IX86 ///////////////////////////////////

    #error NOT_SUPPORTING_X86

#endif ///////////////////////////////////////////


static void* 
JMIM_ASM_GetBaseAddr_PEB_x64()
{
    void* base_address = 0;
    unsigned long long var_out = 0;

    __asm__(
        " movq %%gs:0x60, %[sym_out]  ; \n\t"
        :[sym_out] "=r"  (var_out) //:OUTPUTS
    );

    //: printf("[var_out]:%d\n", (int)var_out);

    base_address=(void*)var_out;
    return( base_address );
}

TYPEDEF_HMODULE MACRO_WINAPI 
JMIM_GetModuleBaseAddress(
    TYPEDEF_LPCWSTR moduleName
){

    //:Void pointers:
    //:void* p;
    void* p1;
    void* p2;
    //:void* p3; 

    //:Using void* instead of the actual types,
    //:so that we don't need to include the
    //:headers for these window's structs.
    //:SOURCES:
    //: https://www.codemachine.com/downloads/win80/winnt.h
    //: https://msdn.microsoft.com/en-us/windows/desktop/aa813706
    //: https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data
    //////////////////////////////////////////////
	void* //:PEB*        
    pPeb = NULL;

	void* //:LIST_ENTRY* 
    pListEntry = NULL;

	void* //:LDR_DATA_TABLE_ENTRY* 
    pLdrDataTableEntry = NULL;
    //////////////////////////////////////////////

    //:pPeb = (PPEB)JMIM_ASM_GetBaseAddr_PEB_x64();
    pPeb = JMIM_ASM_GetBaseAddr_PEB_x64();

	if (pPeb == NULL){
		return NULL;
    };;


    //:pPeb->Ldr->InMemoryOrderModuleList.Flink
    //////////////////////////////////////////////
    unsigned long long 
    instructions_to_Flink[] ={ 

        //:____________ Ldr ___________________://
        'S' , 0x18  //: PTR
    ,   'L' ,  0    //: OBJ

        //:____________ InMemoryOrderModuleList://
    ,   'S' , 0x20  //: PTR
    ,   'L' ,  0    //: OBJ

        //:____________ Flink
    ,   'S' , 0x00  //: PTR
    ,   0x00, 0x00  

    };;
    void* 
    first_link_in_list=(
        VOID_Inst( pPeb, instructions_to_Flink )
    );;
    //////////////////////////////////////////////
        


    
    
    pLdrDataTableEntry=( first_link_in_list );
    pListEntry        =( first_link_in_list );

    int we_wrapped_around_stop_looping = 0;
    
	do
	{

        //:pLdrDataTableEntry->FullDllName.Buffer
        //////////////////////////////////////////
        unsigned long long 
        instructions_to_Buffer[]={
            'S', 0x48  //:FullDllName:PTR
        ,   'S', 0x08  //:Buffer     :PTR
        ,   'L',  0    //:Buffer     :OBJ
        ,   0x00,0x00
        };;
        unsigned short* 
        full_dll_name_buffer=VOID_Inst( 
            pLdrDataTableEntry
            ,
            instructions_to_Buffer
        );;
        //////////////////////////////////////////
        
         
		if(0 ==
            JMIM_lstrcmpiW(

                //:"unsigned short"=="wide char"
                full_dll_name_buffer
            , 
                moduleName
            )
        ){
    
            //:No clue why, but the base address
            //:of the DLL seems to be at:
            //:"pLdrDataTableEntry->Reserved2[0]"
            //:which is the member right before
            //:"pLdrDataTableEntry->DllBase"

            //: pLdrDataTableEntry -> Reserved2[0]
            //////////////////////////////////////

            unsigned long long
            instructions_to_dll_module[]={
                'S', 0x20 //:Reserved2[0]:PTR
            ,   'L',  0   //:Reserved2[0]:OBJ
            ,   0x00,0x00
            };;

            void* 
            dll_module=VOID_Inst(
                pLdrDataTableEntry
            ,   instructions_to_dll_module
            );;

            return( dll_module );

            //////////////////////////////////////
        };;



        //: pListEntry = pListEntry -> Flink
        p1 = (void*)pListEntry;
        p1 = VOID_Seek( p1, 0x00 ); //:Flink:PTR
        p1 = VOID_Load( p1       ); //:Flink:OBJ
        pListEntry =    p1;



        //:pLdrDataTableEntry=pListEntry->Flink
        p2 = p1;
        p2 = VOID_Seek( p2, 0x00 ); //:Flink:PTR
        p2 = VOID_Load( p2       ); //:Flink:OBJ
        pLdrDataTableEntry = p2;



        if( pListEntry == first_link_in_list ){
            we_wrapped_around_stop_looping = 1;
        }else{
            we_wrapped_around_stop_looping = 0;
        };;



	}while( 0 == we_wrapped_around_stop_looping );

	return NULL;
}

TYPEDEF_FARPROC __stdcall 
JMIM_GetExportAddress(
    TYPEDEF_HMODULE hMod
,   const char *lpProcName
){

    void* p;

    //: printf("[helllooooo]");

	char *pBaseAddress = (char *)hMod;

    //|  Can be found in winnt.h header file.  |//
    //|----------------------------------------|//



    //////////////////////////////////////////////
	//| IMAGE_DOS_HEADER                       |//
    //| *pDosHeader =(                         |//
    //|         (IMAGE_DOS_HEADER *)           |//
    //|          pBaseAddress                  |//
    //| );;                                    |//
                                            //||//
    void*                                   //||//
    pDosHeader = pBaseAddress;              //||//
                                            //||//
    //////////////////////////////////////////////


    #define U unsigned long long /////////////////

    //| IMAGE_NT_HEADERS                       |//
    //| *pNtHeaders == pBaseAddress            |//
    //|                +                       |//
    //|                pDosHeader -> e_lfanew  |//

    unsigned long long oper_pNtHeaders[]={
        'I' , (U)pDosHeader   //:Initial_Address
    ,   'S' , 0x3C            //:e_lfanew:PTR
    ,   'L' ,  4              //:e_lfanew:OBJ
    ,   'A' , (U)pBaseAddress //:IMAGE_NT_HEADERS
    ,   0x00,0x00
    };;
    void* pNtHeaders=VOID_Oper(
        oper_pNtHeaders
    );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////
    
    U oper_OptionalHeader[]={
        'I' , (U)pNtHeaders
    ,   'S' , 0x18 //:OptionalHeader:PTR
    ,   0x00, 0x00
    };;
    void* //:IMAGE_OPTIONAL_HEADER
    pOptionalHeader =VOID_Oper( 
        oper_OptionalHeader
    );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////

    //| IMAGE_DATA_DIRECTORY                   |//
    //|*pDataDirectory=(                       |//
    //|    &(pOptionalHeader -> DataDirectory[ |//
    //|         IMAGE_DIRECTORY_ENTRY_EXPORT   |//
    //|     ])                                 |//
    //| );;                                    |//

    U oper_pDataDirectory[]={
        'I', (U)pOptionalHeader
    ,   'S', 0x70 //:DataDirectory[ 0 ]

        //: I_D_E_E:IMAGE_DIRECTORY_ENTRY_EXPORT
        //: DataDirectory[ I_D_E_E ]
    ,   'S', MACRO_x_IMAGE_DIRECTORY_ENTRY_EXPORT
             *
             MACRO_sizeof_IMAGE_DATA_DIRECTORY

        //:Dont load address. Keep as pointer.
       
    ,   0x00,0x00
    };;
    void*
    pDataDirectory=VOID_Oper( 
        oper_pDataDirectory 
    );;

    #undef  U ////////////////////////////////////
    

    //:pDataDirectory -> VirtualAddress
    p = pDataDirectory;
    p = VOID_Seek( p, 0x00 );//:VirtualAddress:PTR
    p = VOID_Load( p       );//:VirtualAddress:OBJ
    void* virtual_address = p;



        #define U unsigned long long /////////////
        
        U base = (U)pBaseAddress;
        
        U inst_to_image_export_directory[]={
            'T',  4   //:truncate to 4 bytes
        ,   'A', base //:Add base addr
        ,  0x00, 0x00 //:END
        };;
        void* 
        added_addresses=VOID_Inst(
            virtual_address
        ,   inst_to_image_export_directory
        );;
        
        #undef  U ////////////////////////////////

        void* //:IMAGE_EXPORT_DIRECTORY*
        pExportDirectory = added_addresses;


      // VOID_PROS(
      //     pExportDirectory
      // , &(pExportDirectory->NumberOfFunctions)
      // ,  "pExportDirectory .NumberOfFunctions"
      // );;

    //: data_directory_size==
    //: pDataDirectory -> Size
    p = pDataDirectory;
    p = VOID_Seek( p, 0x04 ); //:Size:PTR
    p = VOID_Load( p       ); //:Size:OBJ
    size_t data_directory_size=(size_t)( p );
    


    //|----------------------------------------|//



    #define U unsigned long long /////////////////

    //| ppFunctions=(                          |//
    //|    pBaseAddress                        |//
    //|    +                                   |//
    //|    pExportDirectory->AddressOfFunctions|//
    //| );;                                    |//
    
//x   U inst_to_ppFunctions[]={
//x       'S' , 0x1C      //:AddressOfFunctions:PTR
//x   ,   'L' ,  0        //:AddressOfFunctions:OBJ
//x   ,   'T' ,  4        //:Truncate to 4 bytes
//x   ,   'A' ,  (U)pBaseAddress //:Add base address
//x   ,   0x00,0x00
//x   };;
//x   void**
//x   ppFunctions=VOID_Inst(
//x       pExportDirectory
//x   ,   inst_to_ppFunctions
//x   );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////
    
    //|                                        |//
    //|         pOrdinals                      |//
    //|         ===                            |//
    //|         pBaseAddress                   |//
    //|         +                              |//
    //|         pExportDirectory               |//
    //|         ->AddressOfNameOrdinals        |//
    
    unsigned long long oper_pOrdinals[]={
    /**/'I' , (U)pExportDirectory
    ,   'S' , 0x24 //:AddressOfNameOrdinals:PTR
    ,   'L' ,  4   //:AddressOfNameOrdinals:OBJ  
    ,   'A' , (U)pBaseAddress //:pOrdinals
    ,   0x00,0x00  //:END_OF_INSTRUCTIONS
    };;
    unsigned short //:WORD* 
    *pOrdinals=VOID_Oper( oper_pOrdinals );
    
    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////

    U oper_pNames[]={
    /**/'I' , (U)pExportDirectory
    ,   'S' , 0x20 //:AddressOfNames:PTR
    ,   'L' ,  4   //:AddressOfNames:OBJ  
    ,   'A' , (U)pBaseAddress //:pNames
    ,   0x00,0x00  //:END_OF_INSTRUCTIONS
    };;
    TYPEDEF_ULONG*
    pNames=VOID_Oper( oper_pNames );


    #undef  U ////////////////////////////////////


	void *pAddress = NULL;



	unsigned long i; //:DWORD

	if (((TYPEDEF_DWORD_PTR)lpProcName >> 16) == 0)
	{
        //:The pointer only contains 16 bits.
        //:Why does this require different code?
        //:Don't know. SEE: PS2_2.C11 for
        //:reference.
        
        printf("[ERROR:2019_11_28:09_32AM]\n");
        fflush(stdout); 
        exit(666);
	}
	else
	{
        //: printf("[BOT:SELECTED]");

        #define U unsigned long long /////////////

        //| pExportDirectory -> NumberOfNames  |//

        U oper_NumberOfNames[]={
            'I' , (U)pExportDirectory
        ,   'S' , 0x18 //:NumberOfNames:PTR
        ,   'L' ,  4   //:NumberOfNames:OBJ
        ,   0x00,0x00
        };; 
        unsigned long
        number_of_names=(
            (unsigned long)
            (unsigned long long)
            VOID_Oper( oper_NumberOfNames )
        );;

        // ------------------------------------ //

        //| pExportDirectory                   |//
        //| -> AddressOfFunctions              |//

        U oper_AddressOfFunctions[]={
            'I' , (U)pExportDirectory
        ,   'S' , 0x1C //:AddressOfFunctions:PTR
        ,   'L' ,  4   //:AddressOfFunctions:OBJ
        ,   0x00,0x00 
        };; 
        unsigned long
        address_of_functions=(
            (unsigned long)
            (unsigned long long)
            VOID_Oper( oper_AddressOfFunctions )
        );;

        #undef  U ////////////////////////////////


        unsigned long
        *absolute_address_of_functions=(
            (unsigned long *)
            (
                pBaseAddress
                +
                address_of_functions
            )
        );;

		for(
            i = 0
            ; 
            i < number_of_names
            ; 
            i++
        ){
			char *szName =(
                (  char*  )pBaseAddress 
              + (TYPEDEF_DWORD_PTR)pNames[i]
            );;

			if (strcmp(lpProcName, szName) == 0)
			{
				pAddress =(
                    (void*)( //:(TYPEDEF_FARPROC)
                        pBaseAddress
                        +
                        absolute_address_of_functions
                        [pOrdinals[i]]
                    )
                );;

				break;
			};;
		}
	}

	if(
        (char *)pAddress
        >= 
        (char *)pExportDirectory 

        && 

        (char *)pAddress 
        < 
        (char *)pExportDirectory 
              + data_directory_size
    ){
        //:Not going to re-write dead
        //:code path until error is hit.
       
        printf("[ERROR:2019_11_28:09_37AM]\n");
        fflush(stdout); 
        exit(666);

	}

    //:https://stackoverflow.com/questions/14134245/
    //:iso-c-void-and-function-pointers
	//:return pAddress;
    TYPEDEF_FARPROC ret;
    *(void **)(&ret) = pAddress;
    return( ret );
}




//|////////////////////////////////////////////|//
//|     -///-                        -///-     |//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __  __  __  __      __  _|//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |//
//|      \  /                        \  /      |//
//|       \/                          \/       |//
//+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +//
//|           /\                  /\           |//
//|          /  \                /  \          |//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|//
//|                                            |//
//|       ______________________________       |//
//|______/                              \______|//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) /////////////
/** ****************************************** |||
                                                   
    typedef struct _UNICODE_STRING {
      USHORT Length;
      USHORT MaximumLength;
      PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;



    typedef struct _LIST_ENTRY {
       struct _LIST_ENTRY *Flink;
       struct _LIST_ENTRY *Blink;
    } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;



    typedef struct _LDR_DATA_TABLE_ENTRY {
        PVOID Reserved1[2];
        LIST_ENTRY InMemoryOrderLinks;
        PVOID Reserved2[2];
        PVOID DllBase;
        PVOID EntryPoint;
        PVOID Reserved3;
        UNICODE_STRING FullDllName;
        BYTE Reserved4[8];
        PVOID Reserved5[3];
        union {
            ULONG CheckSum;
            PVOID Reserved6;
        };
        ULONG TimeDateStamp;
    } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;



    typedef struct _PEB {
        BYTE                          Reserved1[2];
        BYTE                          BeingDebugged;
        BYTE                          Reserved2[1];
        PVOID                         Reserved3[2];
        PPEB_LDR_DATA                 Ldr;
        PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
        BYTE                          Reserved4[104];
        PVOID                         Reserved5[52];
        PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
        BYTE                          Reserved6[128];
        PVOID                         Reserved7[1];
        ULONG                         SessionId;
    } PEB, *PPEB;


IMAGE_DATA_DIRECTORY

    typedef struct _IMAGE_DATA_DIRECTORY {
      DWORD VirtualAddress;
      DWORD Size;
    } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
                                                
||| ****************************************** **/ 
#endif ///////////////////////////////////////////
//|______                                ______|//
//|||||||\______________________________/|||||||//
//|                                            |//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __  __  __  __      __  _|//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |//
//|      \  /                        \  /      |//
//|       \/                          \/       |//
//+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +//
//|           /\                  /\           |//
//|          /  \                /  \          |//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|//
//|                                            |//
//|____________________________________________|//


//////////////////////////////////////////////////
#endif  //:VGAURD

//#FILE_REGION[ W32/DLLL/TARG/W10.X64 ]END####################//
//#FILE_REGION[ W32/DLLL/DLLL.H ]BEG##########################//

//[ DLLL: DLLL_Loader                          ]//
//+--------------------------------------------+//
//| PUBLIC:                                    |//
//| DLLL_FUNC                                  |//
//| DLLL_DLIB                                  |//
//| DLLL_WRAP_LoadLibraryA                     |//
//| DLLL_WRAP_GetProcAddress                   |//
//+--------------------------------------------+//





//: typedef 
//:     void (*DLLL_GENERIC_FUNCTION_POINTER)
//:     ( void ); //:<<"void" may need to be omitted.




#if( COMPILE_FOR_windows_10_64bit >= 1 )

    //: #include "./TARG/WIN10_x64._"

    //: #include "V:/VG/03/W32/DLLL/TARG/W10.X64"

    typedef
        TYPEDEF_HMODULE
        DLLL_DLIB;

    typedef 
        TYPEDEF_FARPROC 
        DLLL_FUNC;

#endif


static unsigned char
dll_init_already_called =((( 0 )));
void
DLLL_Init(){

    if( dll_init_already_called>0){ return; };

    TYPEDEF_HMODULE 
    hKernel32 =(
    /**/    JMIM_GetModuleBaseAddress(
    /**/        L"KERNEL32.DLL"
    /**/    )
    );;

    LoadLibraryAF 
    pLoadLibraryA =(
    /**/    (LoadLibraryAF)
    /**/    JMIM_GetExportAddress(
    /**/        hKernel32
    /**/    ,  "LoadLibraryA"
    /**/    )
    );;

    GetProcAddressF 
    pGetProcAddress =(
    /**/    (GetProcAddressF)
    /**/    JMIM_GetExportAddress(
    /**/        hKernel32
    /**/    ,   "GetProcAddress"
    /**/    )
    );;

    //:Assign the private function pointers
    //:defined in the specific operating system
    //:implementation files:
    dll_LoadLibraryA   =pLoadLibraryA  ;
    dll_GetProcAddress =pGetProcAddress;

    dll_init_already_called=( 1 );
    
}//[;]//

DLLL_DLIB
DLLL_WRAP_LoadLibraryA(
    const char* name
){
    if(NULL==dll_LoadLibraryA){
        printf("[FORGOT:DLLL_Init()?](LLA)\n");
        assert(NULL!=dll_LoadLibraryA);
    };;

    //:Implementation_Specific:
    return( dll_LoadLibraryA( name ) );
}//[;]//

DLLL_FUNC
DLLL_WRAP_GetProcAddress(
    DLLL_DLIB   dlib
,   const char* name
){
    if(NULL==dll_GetProcAddress){
        printf("[FORGOT:DLLL_Init()?](GPA)\n");
        assert(NULL!=dll_GetProcAddress);
    };;

    //:Implementation_Specific:
    DLLL_FUNC ret;
    ret = (DLLL_FUNC)
           dll_GetProcAddress(dlib, name);
    return(  ret  );
}//[;]//

//////////////////////////////////////////////////
//|  Let's be real... You are not going to     |//
//|  remember "DLLL_WRAP_*" Better just stick  |//
//|  with habits that are less complex.        |//
//+--------------------------------------------+//               
//|  Also,prioritize ease of use! Not speed    |//
//|  here.                                     |//
//////////////////////////////////////////////////

DLLL_DLIB
DLLL_LoadLibraryA(
    const char* name
){
    DLLL_Init(); //:LazyInit

    DLLL_DLIB ret=(
    /**/    DLLL_WRAP_LoadLibraryA(
    /**/        name
    /**/    )
    );;

    if(NULL==ret){
        printf(
            "[DLLL_LoadLibraryA:FAIL]:%s\n"
        ,   name
        );;
    };;

    return( ret );

}//[;]//

DLLL_FUNC
DLLL_GetProcAddress(
    DLLL_DLIB   dlib
,   const char* name
){
    DLLL_Init(); //:LazyInit

    DLLL_FUNC ret=(
    /**/    DLLL_WRAP_GetProcAddress(
    /**/        dlib
    /**/    ,   name
    /**/    )
    );;

    if(NULL==ret){
        printf(
            "[DLLL_GetProcAddress:FAIL]:%s\n"
        ,   name
        );;
    };;


    return( ret );

}//[;]//

//#FILE_REGION[ W32/DLLL/DLLL.H ]END##########################//

#define F01_BASH_CONCATTED


//#FILE_REGION[ F.01 ]BEG#####################################//

//# DOTADIW:DLL_FUNC_LIST -----------------------------------]//

//[ The function you want, and the DLL file it comes from. --]//

//# NOTE: Using different cases like "User32 & usEr32" ------#//
//# Will screw up your DLL caching code!               ------#//
//! NODOC: Missing MSDN documentation. --------------------- !//

#ifndef F01_BASH_CONCATTED

F02_F01_MACRO( RegisterClassExW , user32  )  //[ 01 ]//
F02_F01_MACRO( CreateWindowExW  , user32  )  //[ 02 ]//
F02_F01_MACRO( DestroyWindow    , user32  )  //[ 03 ]//
F02_F01_MACRO( PostQuitMessage  , user32  )  //[ 04 ]//
F02_F01_MACRO( DefWindowProcW   , user32  )  //[ 05 ]//
F02_F01_MACRO( LoadIconA        , user32  )  //[ 06 ]//
F02_F01_MACRO( LoadCursorA      , user32  )  //[ 07 ]//
F02_F01_MACRO( GetWindowDC      , user32  )  //[ 08 ]//
F02_F01_MACRO( ChoosePixelFormat, gdi32   )  //[ 09 ]//
F02_F01_MACRO( SetPixelFormat   , gdi32   )  //[ 10 ]//
F02_F01_MACRO( GetModuleHandleW , kernel32)  //[ 11 ]//
F02_F01_MACRO( GetDesktopWindow , user32  )  //[ 12 ]//
F02_F01_MACRO( TranslateMessage , user32  )  //[ 13 ]//
F02_F01_MACRO( DispatchMessageW , user32  )  //[ 14 ]//
F02_F01_MACRO( PeekMessageW     , user32  )  //[ 15 ]//
F02_F01_MACRO( ShowWindow       , user32  )  //[ 16 ]//
F02_F01_MACRO( UpdateWindow     , user32  )  //[ 17 ]//
F02_F01_MACRO( SetFocus         , user32  )  //[ 18 ]//
F02_F01_MACRO( Sleep            , kernel32)  //[ 19 ]//
F02_F01_MACRO( GetProcessHeap   , kernel32)  //[ 20 ]//
F02_F01_MACRO( CreateThread     , kernel32)  //[ 21 ]//
F02_F01_MACRO( HeapAlloc        , kernel32)  //[ 22 ]//

//:Vulkan_Functions:
////////////////////////////////////////////////////////////////

//:MAKES: F02_vkEnumerateInstanceExtensionProperties
F02_F01_MACRO(  
    vkEnumerateInstanceExtensionProperties 
,   vulkan-1 
)

//:MAKES: F02_vkCreateInstance
F02_F01_MACRO( 
    vkCreateInstance 
,   vulkan-1 
)

//:MAKES: F02_vkEnumerateInstanceLayerProperties
F02_F01_MACRO(
    vkEnumerateInstanceLayerProperties
,   vulkan-1
)

////////////////////////////////////////////////////////////////


//!( RegisterWindow   , user32  )  YOU_MADE_THIS_ONE_UP      !//

//[¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯]//
//[__________________________________________________________]//

#else //: F01_BASH_CONCATTED

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F01_Init(){
        printf("[BEG:F01:Init]\n");

        printf("[F01:Doing_Nothing:(DOTADIW:DLL_FUNC_LIST)]\n");

        printf("[END:F03:Init]\n");
        return( 0 );
    }//[;]//
    int F01_Main(){
        F01_Init();

        //:Nothing to do here.

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

#endif //: F01_BASH_CONCATTED

//#FILE_REGION[ F.01 ]END#####################################//


#undef  F01_BASH_CONCATTED


//#FILE_REGION[ F.02 ]BEG#####################################//

//[ DOTADIW: DLL_FUNC_LOAD ----------------------------------]//
//[          Load Function Pointers From DLL FIles.          ]//
//[         (DLL files or linux equivalent)                  ]//
//[                                                          ]//
//[ Example Function Pointer Created By This File:           ]//
//[                                                          ]//
//[         F02_VOF F02_DestroyWindow =<SomeDLLAddress>      ]//

#include <string.h> //: strcmp

//:Generic_Function_Pointer
typedef void (*F02_VOF)(void);


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

void F02_Halt( const char* msg ){ 
    printf( "[F02_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//

int F02_Same( const char* str_01, const char* str_02 ){
    return( 0 == strcmp( str_01, str_02 ) );
}//[;]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

    

    //[ Declare void pointers for every single DLL function  ]//
    //[ you want to call. They will be wrapped by functions  ]//
    //[ in a later file. Or called by casting to correct     ]//
    //[ signature on the fly.                                ]//
    #define F02_F01_MACRO(f,d) F02_VOF  F02_  ##  f ;
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    //:Create dummy F01_ functions to let you know
    //:you are wrong and should be calling F02_ functions.
    #define F02_F01_MACRO(f,d) F02_VOF  F01_  ##  f ;
        #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

////////////////////////////////////////////////////////////////
//:Positive: The index of the loaded dll address in array.
//:Negative: The index to insert/cache next dll.
//:DO NOT USE TO PEEK! When returning negative, expects you
//:to add to the cache array.
#define MACRO_STR const char * /////////////////////////////////
static DLLL_DLIB F02_Cache_ADDR[1+10]={0}; //:DLL_CACHE.address
static MACRO_STR F02_Cache_NAME[1+10]={0}; //:DLL_CACHE.name
int F02_GetCacheIndex( const char* dlib_name ){

    int i = 0;while(1){ i++;
        
        assert( 0 != i ); //:Invalid_Cache_Index
        assert( i <= 10); //:Out_Of_Pre_Allocated_Slots

        if( NULL ==    F02_Cache_ADDR[i]){ return(  0-i  ); }
        if( F02_Same(  F02_Cache_NAME[i], dlib_name  )   ){
            return( i );
        };;

    };;

    assert( 0 ); //:CRASH! Should have returned already!
    return( 0 ); //:Return invalid index.

}//[;]//
#undef MACRO_STR ///////////////////////////////////////////////

int F02_GF_total_number_of_functions_fetched=0;
static F02_VOF F02_GF( //:GF:Get_Function(Pointer)
/**/    const char* func_name //:EX:"ShowWindow"
/**/,   const char* dlib_name //:EX:"user32.dll" | "user32"
){
    DLLL_DLIB  dlib_addr; //:DLL Module   Address
    DLLL_FUNC  func_addr; //:DLL Function Address
    ////////////////////////////////////////////////////////////
    //:GET DLL Module:
    ////////////////////////////////////////////////////////////
    int cac_dex = F02_GetCacheIndex( dlib_name );
    if( cac_dex > 0 ){

        dlib_addr = F02_Cache_ADDR[ cac_dex ];

    }else
    if( cac_dex < 0 ){

        dlib_addr = DLLL_LoadLibraryA(
        dlib_name );;

        F02_Cache_ADDR[ 0-cac_dex ] = dlib_addr;
        F02_Cache_NAME[ 0-cac_dex ] = dlib_name;

    }else{
        F02_Halt( "[EUBOC:ZERO_IS_INVALID_CACHE_INDEX]" );
    };;
    ////////////////////////////////////////////////////////////
    //:PULL Function From DLL:
    ////////////////////////////////////////////////////////////

        func_addr = DLLL_GetProcAddress( dlib_addr, func_name );

    ////////////////////////////////////////////////////////////

    F02_GF_total_number_of_functions_fetched++;
    return( (F02_VOF)func_addr );

}//[;]//

void F02_WRONGNAME(void){

    printf("[Raw_Function_Pointers_Are_Named]\n");
    printf("[After_The_File_They_Are_Created]\n");
    printf("[in.(F.02)not_the_file_the_func_]\n");
    printf("[name_list_lives_in(F.01).------]\n");
    printf("[TL;DR::::::::::::::::::::::::::]\n");
    printf("[   YES: F02_SomeRawDLLFunction ]\n");
    printf("[    NO: F01_SomeRawDLLFunction ]\n");

    fflush(stdout);
    exit(666);

}//[;]//

//:Load Function Pointers: EX: F02_ShowWindow
int F02_Init(){
    printf("[BEG:F02:Init]\n");

    //:Call previous "init" before doing your work:
    F01_Init();

    #define F02_F01_MACRO(f,d) F02_ ## f = F02_GF(#f,#d);
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    //:In case you think the functions start with "F01_"
    #define F02_F01_MACRO(f,d) F01_ ## f = &(F02_WRONGNAME);
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

   // if( F02_GF_total_number_of_functions_fetched != 23 ){
   //     F02_Halt("[Expected_This_Many_Fetched_Funcs]");
   // };;

    printf("[F02:NUM_FUNCS_FETCHED]:%d\n",
        F02_GF_total_number_of_functions_fetched );;
    fflush(stdout);



    printf("[END:F02:Init]\n");
    return( 0 );

}//[;]//
int F02_Main(){

    printf("[F02_Init:Will_Fetch_Function_Pointers]\n");
    int ret = F02_Init();

    return( ret );
}//[;]//



//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//|////////////////////////////////////////////|////[ --64-- ]//
//|     -///-                        -///-     |////[ --64-- ]//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ --64-- ]//
//|_  __      __  __  __  __  __  __      __  _|////[ --64-- ]//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ --64-- ]//
//|      \  /                        \  /      |////[ --64-- ]//
//|       \/                          \/       |////[ --64-- ]//
//+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ --64-- ]//
//|           /\                  /\           |////[ --64-- ]//
//|          /  \                /  \          |////[ --64-- ]//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ --64-- ]//
//|                                            |////[ --64-- ]//
//|       ______________________________       |////[ --64-- ]//
//|______/                              \______|////[ --64-- ]//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) /////////////
/** ****************************************** |||
                                                   
//+----------------------------------------------------------+//
//[ Because macros generate these functions, I thought it    ]//
//[ a good idea to write them down here in a comment.        ]//
//[ If I don't, "CTRL+F" will not save the poor soul         ]//
//[ looking for the declaration of these functions.          ]//
//[ (They are declared in this file (F.02) with macros)      ]//
//[                                                          ]//
//|     void*( *F02_RegisterClassExW )( void );              |//
//|     void*( *F02_CreateWindowExW  )( void );              |//
//|     void*( *F02_DestroyWindow    )( void );              |//
//|     void*( *F02_PostQuitMessage  )( void );              |//
//|     void*( *F02_DefWindowProcW   )( void );              |//
//|     void*( *F02_LoadIconA        )( void );              |//
//|     void*( *F02_LoadCursorA      )( void );              |//
//|     void*( *F02_GetWindowDC      )( void );              |//
//|     void*( *F02_ChoosePixelFormat)( void );              |//
//|     void*( *F02_SetPixelFormat   )( void );              |//
//|     void*( *F02_GetModuleHandleW )( void );              |//
//|     void*( *F02_GetDesktopWindow )( void );              |//
//|     void*( *F02_TranslateMessage )( void );              |//
//|     void*( *F02_DispatchMessageW )( void );              |//
//|     void*( *F02_PeekMessageW     )( void );              |//
//|     void*( *F02_ShowWindow       )( void );              |//
//|     void*( *F02_UpdateWindow     )( void );              |//
//|     void*( *F02_SetFocus         )( void );              |//
//|     void*( *F02_Sleep            )( void );              |//
//|     void*( *F02_GetProcessHeap   )( void );              |//
//|     void*( *F02_CreateThread     )( void );              |//
//|     void*( *F02_HeapAlloc        )( void );              |//
//+----------------------------------------------------------+//
                                                   
||| ****************************************** **/ 
#endif ///////////////////////////////////////////
//|______                                ______|////[ --64-- ]//
//|||||||\______________________________/|||||||////[ --64-- ]//
//|                                            |////[ --64-- ]//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ --64-- ]//
//|_  __      __  __  __  __  __  __      __  _|////[ --64-- ]//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ --64-- ]//
//|      \  /                        \  /      |////[ --64-- ]//
//|       \/                          \/       |////[ --64-- ]//
//+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ --64-- ]//
//|           /\                  /\           |////[ --64-- ]//
//|          /  \                /  \          |////[ --64-- ]//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ --64-- ]//
//|                                            |////[ --64-- ]//
//|____________________________________________|////[ --64-- ]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//



//#FILE_REGION[ F.02 ]END#####################################//
//#FILE_REGION[ F.03 ]BEG#####################################//

//[F02: DOTADIW: DLL_CALL_CAST (HACK) -----------------------]//
//[ Quick_Hack_For_Calling_DLL_Func_Pointers  ---------------]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[ Making typedefs and wrappers for function signatures can ]//
//[ get a bit verbose and annoying. When you feel like       ]//
//[ skipping that effort, you can use these hacks depending  ]//
//[ on the number of parameters the function has.            ]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

#define  V void* ///////////////////////////////////////////////
#define  a void* ///////////////////////////////////////////////
#define  b void* ///////////////////////////////////////////////
#define  c void* ///////////////////////////////////////////////
#define  d void* ///////////////////////////////////////////////
#define  e void* ///////////////////////////////////////////////

typedef  V (* F03_00)( void );
typedef  V (* F03_01)( a                                      );
typedef  V (* F03_02)( a,a                                    );
typedef  V (* F03_03)( a,a,a                                  );
typedef  V (* F03_04)( a,a,a,a                                );
typedef  V (* F03_05)( a,a,a,a,b                              );
typedef  V (* F03_06)( a,a,a,a,b,b                            );
typedef  V (* F03_07)( a,a,a,a,b,b,b                          );
typedef  V (* F03_08)( a,a,a,a,b,b,b,b                        );
typedef  V (* F03_09)( a,a,a,a,b,b,b,b,c                      );
typedef  V (* F03_10)( a,a,a,a,b,b,b,b,c,c                    );
typedef  V (* F03_11)( a,a,a,a,b,b,b,b,c,c,c                  );
typedef  V (* F03_12)( a,a,a,a,b,b,b,b,c,c,c,c                );
typedef  V (* F03_13)( a,a,a,a,b,b,b,b,c,c,c,c,d              );
typedef  V (* F03_14)( a,a,a,a,b,b,b,b,c,c,c,c,d,d            );
typedef  V (* F03_15)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d          );
typedef  V (* F03_16)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d        );
typedef  V (* F03_17)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e      );
typedef  V (* F03_18)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e    );
typedef  V (* F03_19)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e  );
typedef  V (* F03_20)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e,e);

#undef   V /////////////////////////////////////////////////////
#undef   a /////////////////////////////////////////////////////
#undef   b /////////////////////////////////////////////////////
#undef   c /////////////////////////////////////////////////////
#undef   d /////////////////////////////////////////////////////
#undef   e /////////////////////////////////////////////////////

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F03_Init(){
        printf("[BEG:F03:Init]\n");

        //:No action besides calling down the chain.

        int ret = F02_Init();

        printf("[END:F03:Init]\n");
        return( ret );
    }//[;]//
    int F03_Main(){
        F03_Init();

        printf("[F03:DLL_CALL_CAST. Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.03 ]END#####################################//
//#FILE_REGION[ F.04 ]BEG#####################################//

//: F.04: DLL_STRUCTS.
//:       STRUCTS needed to create wrappers for DLL funcs.

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F04_Init(){
        printf("[BEG:F04:Init]\n");

        //:No action besides calling down the chain.

        int ret = F03_Init();

        printf("[END:F04:Init]\n");
        return( ret );
    }//[;]//
    int F04_Main(){
        F04_Init();

        printf("[F04:DLL_STRUCTS. Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.04 ]END#####################################//
//#FILE_REGION[ F.05 ]BEG#####################################//

//: F.05: DLL_TYPEDEFS (Should all be function pointer typedefs)
//:       TYPDEFS to create proper wrappers for DLL FUNCS:


//:LSR:LPTHREAD_START_ROUTINE:
typedef 
    unsigned long (__stdcall *F05_LSR ) (  
        void* lpThreadParameter  
    );
//[typedef]//
 





//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F05_Init(){    
        printf("[BEG:F05:Init]\n");

        int ret = F04_Init();

        printf("[END:F05:Init]\n");
        return( ret );
    }//[;]//
    int F05_Main(){
        F05_Init();

        printf("[F05:DLL_TYPEDEFS. Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.05 ]END#####################################//

#define F06_BASH_CONCATTED


//#FILE_REGION[ F.06 ]BEG#####################################//

//[ DOTADIW : DLL_PARG_LIST  --------------------------------]//
//[           PARG: PARAMETER/ARGUMENT                       ]//
//[           Param Lists Of Funcs Fetched From DLL(s)       ]//
//[          (Or linux equivalent of DLL files)              ]//

#ifndef F06_BASH_CONCATTED

#if( F08_F06_MACRO_CreateWindowExW > 0 ) ///////////////////////

    #if( F07_F06_MACRO_actual_argument_list > 0 )

        #define MACRO_L     
        #define MACRO_S_PTR 
        #define MACRO_I     
        #define MACRO_V_PTR 

    #elif( F07_F06_MACRO_formal_param_list > 0 )

        #define MACRO_L       unsigned long
        #define MACRO_S_PTR   const unsigned short *
        #define MACRO_I       int
        #define MACRO_V_PTR   void *

    #else

        #error ARE_ARGUMENTS_ACTUAL_OR_FORMAL

    #endif
/**/            MACRO_L      dwExStyle    /**DWORD     01 **/
,               MACRO_S_PTR  lpClassName  /**LPCWSTR   02 **/
,               MACRO_S_PTR  pWindowName  /**LPCWSTR   03 **/
,               MACRO_L      dwStyle      /**DWORD     04 **/
,               MACRO_I      X            /**          05 **/
,               MACRO_I      Y            /**          06 **/
,               MACRO_I      nWidth       /**          07 **/
,               MACRO_I      nHeight      /**          08 **/
,               MACRO_V_PTR  hWndParent   /**HWND      09 **/
,               MACRO_V_PTR  hMenu        /**HMENU     10 **/
,               MACRO_V_PTR  hInstance    /**HINSTANCE 11 **/
,               MACRO_V_PTR  lpParam      /**HINSTANCE 12 **/

        #undef  MACRO_L     
        #undef  MACRO_S_PTR 
        #undef  MACRO_I     
        #undef  MACRO_V_PTR 

#elif( F08_F06_MACRO_CreateThread > 0 ) ////////////////////////

    #if( F07_F06_MACRO_actual_argument_list > 0 )

        #define macro_LPSECURITY_ATTRIBUTES
        #define macro_SIZE_T
        #define macro_LPTHREAD_START_ROUTINE
        #define macro_HINSTANCE
        #define macro_DWORD
        #define macro_LPDWORD

    #elif( F07_F06_MACRO_formal_param_list > 0 )

        #define macro_LPSECURITY_ATTRIBUTES    void*
        #define macro_SIZE_T     unsigned long long  //:64bits                 
        #define macro_LPTHREAD_START_ROUTINE   F05_LSR
        #define macro_HINSTANCE                void*
        #define macro_DWORD           unsigned long
        #define macro_LPDWORD         unsigned long*         

    #else

        #error ARE_ARGUMENTS_ACTUAL_OR_FORMAL ? CREATE_THREAD

    #endif

    /**/macro_LPSECURITY_ATTRIBUTES       //[DT]//
        lpThreadAttributes                //[DT]//
                                          //[DT]//
    ,   macro_SIZE_T                      //[DT]//
        dwStackSize                       //[DT]//
                                          //[DT]//
    ,   macro_LPTHREAD_START_ROUTINE      //[DT]//
        lpStartAddress                    //[DT]//
                                          //[DT]//
    ,   macro_HINSTANCE                   //[DT]//
        lpParameter                       //[DT]//
                                          //[DT]//
    ,   macro_DWORD                       //[DT]//
        dwCreationFlags                   //[DT]//
                                          //[DT]//
    ,   macro_LPDWORD                     //[DT]//
        lpThreadId                        //[DT]//

        #undef  macro_LPSECURITY_ATTRIBUTES
        #undef  macro_SIZE_T
        #undef  macro_LPTHREAD_START_ROUTINE
        #undef  macro_HINSTANCE
        #undef  macro_DWORD
        #undef  macro_LPDWORD

#else  ////////////////////////////////////////////////////////

    #error NO_SELECTION_MADE_USING_MACRO_DECLARATION

#endif

#else  //: F06_BASH_CONCATTED 

    //:Non Macro Stuff:
    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

    int F06_Init(){
        printf("[BEG:F06:Init]\n");

        //:No action besides calling down the chain.

        int ret = F05_Init();

        printf("[END:F06:Init]\n");
        return( ret );
    }//[;]//
    int F06_Main(){
        F06_Init();

        printf("[F06:Is_A_Macro_File.Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

#endif //: F06_BASH_CONCATTED 


//#FILE_REGION[ F.06 ]END#####################################//


#undef  F06_BASH_CONCATTED



#define F07_BASH_CONCATTED


//#FILE_REGION[ F.07 ]BEG#####################################//

//[ DOTADIW : DLL_WRAP_BOIL ---------------------------------]//
//[           DLL function call WRAPper                      ]//
//[           BOILerplate template.                          ]//
//[                                                          ]//
//[                                                          ]//
//[ Further abstracts use of parameter lists file so that    ]//
//[ we don't have to write function wrapper boilerplate      ]//
//[ every time we wrap a function.                           ]//
//[ All we have done here is replaced lines that have the    ]//
//[ comment #Example# with a macro for the function names.   ]//

//|F08_F07_MACRO_wrapper: Wrapping function with type safety.|//
//|F08_F07_MACRO_wrapped: Uncasted func ptr pulled from dll. |//

#ifndef F07_BASH_CONCATTED 

    //:Can we abstract this further?
    F08_F07_MACRO_RETURNTYPE
    
    //:
    F08_F07_MACRO_wrapper //:<--#Example#: F07_CreateWindowExW
    (

                ////////////////////////////////////////////////
                #define F07_F06_MACRO_formal_param_list 1
                
                #include "./F.06" //:DOTADIW:DLL_PARG_LIST
                
                #undef  F07_F06_MACRO_formal_param_list
                ////////////////////////////////////////////////

    ){

        typedef  
            F08_F07_MACRO_RETURNTYPE
            (*pfn )(            
                 
                ////////////////////////////////////////////////
                #define F07_F06_MACRO_formal_param_list 1

                #include "./F.06"  //:DOTADIW:DLL_PARG_LIST

                #undef  F07_F06_MACRO_formal_param_list
                ////////////////////////////////////////////////
     
            );

        pfn fun =(pfn) 
        F08_F07_MACRO_wrapped; //:<--#EX#:F01_CreateWindowExW

        F08_F07_MACRO_RETURNTYPE 
        ret=( fun(

                ////////////////////////////////////////////////
                #define F07_F06_MACRO_actual_argument_list 1
                
                #include "./F.06" //:DOTADIW:DLL_PARG_LIST
                
                #undef  F07_F06_MACRO_actual_argument_list
                ////////////////////////////////////////////////

        ));

        return(  ret  );

    }//[F08_F07_MACRO_wrapper]//

#else

    //:Non Macro Stuff:
    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

    int F07_Init(){
        
        //:No action besides calling down the chain.

        int ret = F06_Init();

        return( ret );
    }//[;]//
    int F07_Main(){
        F07_Init();

        printf("[F07:Is_A_Macro_File.Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

#endif

//#FILE_REGION[ F.07 ]END#####################################//


#undef  F07_BASH_CONCATTED


//#FILE_REGION[ F.08 ]BEG#####################################//

//[ DOTADIW: DLL_WRAP_MAKE ----------------------- --------- ]//
//[ Make wrapper functions for DLL func pointers.  --------- ]//

//:We could abstract this further, by creating a list
//:of function names that have had typedefs created for them.

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

#define F08_F07_MACRO_RETURNTYPE void*  ////////////////////////
#define F08_F06_MACRO_CreateWindowExW 1  ///////////////////////

    #define F08_F07_MACRO_wrapper   F08_CreateWindowExW
    #define F08_F07_MACRO_wrapped   F02_CreateWindowExW

        #include "./F.07" //:<<--#DOTADIW:DLL_WRAP_BOIL  
                                 //(wrapper_func_template)
    #undef  F08_F07_MACRO_wrapper
    #undef  F08_F07_MACRO_wrapped

#undef  F08_F07_MACRO_RETURNTYPE  //////////////////////////////
#undef  F08_F06_MACRO_CreateWindowExW ////////////////////////// 

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

#define F08_F07_MACRO_RETURNTYPE void*  ////////////////////////
#define F08_F06_MACRO_CreateThread   1  ////////////////////////

    #define F08_F07_MACRO_wrapper   F08_CreateThread
    #define F08_F07_MACRO_wrapped   F02_CreateThread

        #include "./F.07" //:<<--#DOTADIW:DLL_WRAP_BOIL 
                                 //(wrapper_func_template)
    #undef  F08_F07_MACRO_wrapper
    #undef  F08_F07_MACRO_wrapped

#undef  F08_F07_MACRO_RETURNTYPE        ////////////////////////
#undef  F08_F06_MACRO_CreateThread      //////////////////////// 

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


//:Non Macro Stuff:
//:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

int F08_Init(){
    
    //:No action besides calling down the chain.

    int ret = F07_Init();

    return( ret );
}//[;]//
int F08_Main(){
    F08_Init();

    printf("[F08:Is_A_Macro_File.Nothing_To_Do_Here]\n");

    return( 0 );
}//[;]//

//:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

//#FILE_REGION[ F.08 ]END#####################################//
//#FILE_REGION[ F.09 ]BEG#####################################//

//[ DOTADIW: MAKE_A_WINDOW                                   ]//

//[V:Variables. #VARS_TOP_OF_FILE_BIG_PICTURE#               ]//
//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//:Initial_Window_Size_And_Position:
////////////////////////////////////////////
int f09_X    = 22  ; /**  GLEB_SWIN.X    **/
int f09_Y    = 22  ; /**  GLEB_SWIN.Y    **/
int f09_WID  = 1024; /**  GLEB_SWIN.WID  **/
int f09_HIG  = 512 ; /**  GLEB_SWIN.HIG  **/
////////////////////////////////////////////

    signed char f09_window_created     = 0;
    signed char f09_window_just_closed = 0;
      
    void* f09_handle_to_window      = NULL; //:HWND
    void* f09_window_device_context = NULL; //:HDC
    
    //:Forward declare so we can keep variables
    //:at top of file.
    struct F09_STRUCT_PIXELFORMATDESCRIPTOR;
    struct F09_STRUCT_PIXELFORMATDESCRIPTOR
                f09_pixel_format_descriptor;
    signed char f09_InitPixelFormatDescriptor_DONE=0;

//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//[H:Halt Always first function in file._____________________]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
void F09_Halt( const char*     msg ){ 
    printf( "[F09_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

//[SI:Structs_And_Initializers (Initializers For The Structs)]//
//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//

typedef void (*F09_GENERIC_FUNC)(void);


typedef 
    __int64
    (__stdcall *F09_WNDPROC)(
        void*             //: HWND
    ,   unsigned   int    //: UINT
    ,   unsigned __int64  //: WPARAM
    ,            __int64  //: LPARAM
    );

// ---------------------------------------------------------- //

struct F09_STRUCT_WNDCLASSEXW {
                unsigned int   cbSize       ;
                unsigned int   style        ;
                 F09_WNDPROC   lpfnWndProc  ;
                         int   cbClsExtra   ;
                         int   cbWndExtra   ;
                        void*  hInstance    ;
                        void*  hIcon        ;
                        void*  hCursor      ;
                        void*  hbrBackground;
        const unsigned short*  lpszMenuName ;
        const unsigned short*  lpszClassName;
                        void*  hIconSm      ;
};

// ---------------------------------------------------------- //

struct F09_STRUCT_POINT{

    long x;
    long y;

};//[struct]//

//:winuser.h
struct F09_STRUCT_MSG {

    void*                    hwnd    ;  //: HWND    ://
    unsigned   int           message ;  //: UINT    ://
    unsigned __int64         wParam  ;  //: WPARAM  ://

             __int64         lParam  ;  //: LPARAM  ://
    unsigned    long         time    ;  //: DWORD   ://

    struct F09_STRUCT_POINT  pt      ;  //: POINT   ://
    unsigned    long         lPrivate;  //: DWORD   ://

};//[struct]//



//[  docs.microsoft.com/en-us/windows/win32/api/wingdi       ]//
//[  /ns-wingdi-pixelformatdescriptor                        ]//
#define W unsigned short /** WORD **/  /////////////////////////
#define D unsigned long  /**DWORD **/  /////////////////////////
#define B unsigned char  /** BYTE **/  /////////////////////////
struct F09_STRUCT_PIXELFORMATDESCRIPTOR {
    W  nSize;   
    W  nVersion;

    D dwFlags;

    B  iPixelType;
    B  cColorBits;
    B  cRedBits;
    B  cRedShift;
    B  cGreenBits;
    B  cGreenShift;
    B  cBlueBits;
    B  cBlueShift;
    B  cAlphaBits;
    B  cAlphaShift;
    B  cAccumBits;
    B  cAccumRedBits;
    B  cAccumGreenBits;
    B  cAccumBlueBits;
    B  cAccumAlphaBits;
    B  cDepthBits;
    B  cStencilBits;
    B  cAuxBuffers;
    B  iLayerType;
    B  bReserved;

    D dwLayerMask;
    D dwVisibleMask;
    D dwDamageMask;

};//[struct]//
#undef  W ////////////// /** WORD **/  /////////////////////////
#undef  D ////////////// /**DWORD **/  /////////////////////////
#undef  B ////////////// /** BYTE **/  /////////////////////////
void                                       
f09_InitPixelFormatDescriptor(       
    void                                   
){          
    if( f09_InitPixelFormatDescriptor_DONE != 0 ){
        F09_Halt("[AlreadyInited:PFD]");
    };;
                                                                           
    struct F09_STRUCT_PIXELFORMATDESCRIPTOR                  
    p ={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct F09_STRUCT_PIXELFORMATDESCRIPTOR ), //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;     

    //:Quick smoke test in case I missed a param
    //:and my data is mis-aligned.
    if( 32 != p.cColorBits   ){
        F09_Halt( "[32!=p.cColorBits]" );
    };;
    if( 24 != p.cDepthBits  ){
        printf("[p.cDepthBits]:%d\n" , p.cDepthBits );
        F09_Halt( "[24!=p.cDepthBits]");
    };;
    if(  8 != p.cStencilBits ){
       F09_Halt( "[08!=p.cStencilBits]");
    };;
                                           
    //[ Copy Over To Global Variable ]// 
    f09_pixel_format_descriptor =( p );
    f09_InitPixelFormatDescriptor_DONE = 1;
                                           
} //[InitPixelFormatDescriptor]//          

//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//


// ---------------------------------------------------------- //

////////////////////////////////////////////////////////////////             

typedef const unsigned short *  TYPEDEF_LPCWSTR;


char*
F09_MakeIntResourceA( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
}//[;]//

////////////////////////////////////////////////////////////////

//:WinMsgHanWndPoc:WINDOW_MESSAGE_HANDLER_WNDPROC
__stdcall
__int64 //:LRESULT
F09_WinMsgHanWndPoc(
/**/           void*    Hw     //:HWND
,   unsigned   int      Msg    //:...?...
,   unsigned __int64    wParam //:WPARAM
,            __int64    lParam //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[GLEB_SWIN:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 ((F03_01)(F02_DestroyWindow))(Hw);

            if(0==ok){F09_Halt("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            ((F03_01)(F02_DestroyWindow))(Hw);

        if(0==ok){F09_Halt("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((F03_01)F02_PostQuitMessage)(0);

    case 0x000F /**wm_paint**/:
        //:[TODO]:Something to pace the updating
        //:of graphics.


        //+ DELETE THIS BLOCK +//
        //- //:I dont think this is needed:         -//
        //- //: You may use the same HDC in both    -//
        //- //: threads, but not at the same time.  -//
        //- //: SEE[ gl-hdc-thread-quote ]          -//
        //- if(GLEB_SWIN.render_tick_function_has){ -//
        //-    GLEB_SWIN.render_tick_function();    -//
        //- };;                                     -//

        //: This might be better done setting a flag
        //: than using a callback. In order to prevent
        //: drawing code from being invoked on the
        //: wrong thread.

        //: With that said, setting a flag:
        //- ENGETHER.THREADING.InterlockedIncrement64( -//
        //-     &( GLEB_SWIN.THREAD_SAFE_FLAGS.        -//
        //-        redraw_message_count )              -//
        //- );;                                        -//

        
        //+ This call needs to be made from    +//
        //+ the same thread as your OpenGL     +//
        //+ calls.                             +//
        //# DONT_HERE:GLEB_SWIN_SwapBuffers(); #//





    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            ((F03_04)(F02_DefWindowProcW))(
            /**/(void*)                     Hw  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //[F09_WinMsgHanWndPoc]//

////////////////////////////////////////////////////////////////


int //:BOOL
F09_RegisterWindow(
/**/                    void*  hInstance                
/**/,   const unsigned short*  unique_window_name    
){

    //|Smoke_Test:-----------------------|//
    size_t struct_size =(
        sizeof( struct F09_STRUCT_WNDCLASSEXW )
    );;
    if( struct_size != 80 ){
        F09_Halt("[BadStructSize]");
    };;//|-------------------------------|//
    
    //: WNDCLASSEXW W;
    struct F09_STRUCT_WNDCLASSEXW 
    W = {0};

    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////

    W.cbSize=sizeof( struct F09_STRUCT_WNDCLASSEXW );
    W.style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                     //| ...ClassWin32         |//
    0);;
    W.lpfnWndProc=F09_WinMsgHanWndPoc;
    W.cbClsExtra=0;
    W.cbWndExtra=0;
    W.hInstance=hInstance;

    char* idi_application = F09_MakeIntResourceA( 32512 );
    char* idc_arrow       = F09_MakeIntResourceA( 32512 );

    W.hIcon  =((F03_02)F02_LoadIconA)(  
        NULL
    ,   idi_application
    );;
    W.hCursor=((F03_02)F02_LoadCursorA)(  
        NULL
    ,   idc_arrow
    );;

    //| Looking at:                            |//
    //| https://github.com/glfw/glfw/blob/     |//
    //| master/src/win32_window.c              |//
    //| does not look like background          |//
    //| brush color eneds to be set.           |//
    //|                                        |//
    //| Code here specifically says:           |//
    //| "No Background Required For GL"        |//
    //| http://nehe.gamedev.net/tutorial       |//
    //| /creating_an_opengl_window_(win32)     |//
    //| /13001/                                |//
    //- W.hbrBackground=(                      -//
    //-     /**/(HBRUSH)                       -// 
    //-     /**/ FP->GDI32.GetStockObject(     -// 
    //-     /**/     FP->GDI32.DATA.BRUSH.BLACK-// 
    //-     /**/)                              -// 
    //- );;                                    -//
    W.hbrBackground=NULL;

    W.lpszMenuName=NULL;
    W.lpszClassName=unique_window_name;
    W.hIconSm=(
        ((F03_02)F02_LoadIconA)(
            NULL
        ,   idi_application
        )
    );;

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //! If you forget to register your         !//
    //! window class, the observable effect    !//
    //! is the window never opening, and the   !//
    //! wait loop exiting immediately.         !//
    //|________________________________________|//
    return(
        (int)(unsigned long long)
        ((F03_01)F02_RegisterClassExW)(
            &( W )
        )
    );;
} //[Register]//


void //:gleb_swin_MakeWindowCompatibleWith_GL
f09_MakeWindowCompatibleWith_GL(
    void*  Hw /**HWND**/
){
    
    f09_InitPixelFormatDescriptor();

    void* /** HDC **/ 
    window_device_context =(
        ((F03_01)F02_GetWindowDC)( Hw ) /**user32**/
    );;
    int
    pixel_format_number=(
        (int)(unsigned long long)
        ((F03_02)F02_ChoosePixelFormat)( /**gdi32**/
            window_device_context
        , &( f09_pixel_format_descriptor )
        )
    );;
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((F03_03)F02_SetPixelFormat)(
        /**/
        /**/        window_device_context
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        pixel_format_number
        /**/    ,
        /**/        &( f09_pixel_format_descriptor )
        )
    );;
    if( setting_pixel_format_worked ){
        //: printf("[SPF:OK]\n");
    }else{
        F09_Halt("[SPF:FAIL]\n");
    };;

    f09_window_device_context=(
        window_device_context
    );;

} //[MakeWindowCompatibleWith_GL]//


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

int //:BOOL
f09_TakeOrLookMessage( 
/**/
    struct F09_STRUCT_MSG*
    dont_prefix_message_with_and_symbol /**LPMSG**/
    ,
    int    
    take_the_message
){

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        F09_Halt("[Exp:Pos|Or|Zero]");
    };;

    int ret =(
    (int)(unsigned long long)
    ((F03_05)F02_PeekMessageW)(
        (void*)
        dont_prefix_message_with_and_symbol
        ,
        NULL
        ,
        0
        ,
        0
        ,
        (void*)(unsigned long long)
        look_or_take

    ));;

    return( ret );

} //[TakeOrLookMessage]//



int //:BOOL
f09_LookMessage(
    struct F09_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=f09_TakeOrLookMessage(msg,look);
    return( ret );
} //[LookMessage]//



int //:BOOL
f09_TakeMessage(
    struct F09_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=f09_TakeOrLookMessage(msg,take);
    return( ret );
} //[TakeMessage]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


struct F09_STRUCT_MSG //:MSG struct
f09_WindowLoop(
    void*  Hw //:HWND
){

    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;
    ((F03_02)F02_ShowWindow  )(  Hw, show  ); 
    ((F03_01)F02_UpdateWindow)(  Hw        ); 
    ((F03_01)F02_SetFocus    )(  Hw        );

    unsigned int  wm_quit =  0x12;          

    struct F09_STRUCT_MSG  
    M; //:MSG struct

    f09_LookMessage( &M );
    while(
        M.message
        !=
        wm_quit
    ){
        if( f09_TakeMessage(    &M )){

            ((F03_01)F02_TranslateMessage)( &M );

            ((F03_01)F02_DispatchMessageW)( &M );

        };;

    };;

    f09_window_just_closed = ('t'|'r'|'u'|'e');

   //: //# [HACK]:Sleep a bit so other threads    #//
   //: //#        see "window_just_closed" update.#//
   //: //# You really should use a proper mutex.  #//
    ((F03_01)F02_Sleep)( (void*)64 );

    return( M );

} //[WindowLoop]//


//: Call this function on a separate thread!
//: Refactor_Of:gleb_swin_OPEN_WINDOW_LOOP_FOREVER
unsigned __int64 //:WPARAM
F09_OpenWindowAndLoopForever(
    //:UNICODE_STRING
    const unsigned short *  //:LPCWSTR (Technically_LPCTSTR)
    unique_window_name      
    ,
    const unsigned short *  //:LPCWSTR (Technically_LPCTSTR)
    window_titlebar_text

    //:#Technically_LPCTSTR#://
    //: Technically LPCTSTR, not LPCWSTR,
    //: But using extended (ex) function and unicode/wide
    //: characters where I can. Thus resolved type is LPCWSTR.
){
     
    void* /**HMODULE**/ hin=(
        ((F03_01)F02_GetModuleHandleW)(
            NULL
        )
    );;//[a]//

    if(NULL==hin){
        F09_Halt(
            "[FailedToGetModuleHandle]"
        );;
    };;//[b]//

    /////////////////////////////////////
    void*                              //
    Hw = NULL;  //:HWND                //
                                       //
    struct F09_STRUCT_MSG              //
    Msg       ;   //:tagMSG (Struct)   //
    /////////////////////////////////////

    if(0 >=
        F09_RegisterWindow(
            hin
        ,   unique_window_name
        )
    ){ 

        F09_Halt( /** Originally: gleb_swin_Alert **/
            "[FailedToRegisterWindow]"
        );;
        return 0; 

    };;//[c]//

    int X   = f09_X   ; //:Initial_X_Position
    int Y   = f09_Y   ; //:Initial_Y_Position
    int WID = f09_WID ; //:Initial_WIDTH
    int HIG = f09_HIG ; //:Initial_HEIGHT

    unsigned long ws_overlappedwindow=( 0
    |   0x00000000L  /** WS_OVERLAPPED  **/
    |   0x00C00000L  /** WS_CAPTION     **/
    |   0x00080000L  /** WS_SYSMENU     **/
    |   0x00040000L  /** WS_THICKFRAME  **/
    |   0x00020000L  /** WS_MINIMIZEBOX **/
    |   0x00010000L  /** WS_MAXIMIZEBOX **/
    );;//[d]//

    unsigned long cs_owndc = 0x0020;

    //:NOOP's so I can comment out call to CreateWindowExW:
    if( cs_owndc            ){ /** NOOP **/ };
    if( ws_overlappedwindow ){ /** NOOP **/ };
    if( X|Y|WID|HIG         ){ /** NOOP **/ };
    if( hin                 ){ /** NOOP **/ };

    void*
    the_desktop_window=((F03_00)F02_GetDesktopWindow)();

    Hw=F08_CreateWindowExW
    (

    /**/0x00000008L           /** ws_ex_topmost **/
    ,   unique_window_name    /** lpClassName   **/
    ,   window_titlebar_text  /** lpWindowName  **/      
  
    , 
        (0
        |  ws_overlappedwindow /** STYLE **/   
        |  cs_owndc            /** STYLE **/
        |
        0)

    ,   X,Y,WID,HIG

    ,   the_desktop_window //:-- hWndParent ---://
    ,   NULL   //:-------------- hMenu      ---://
    ,   hin    //:-------------- hInstance  ---://        
    ,   NULL   //:-------------- lpParam    ---://  
    );//[e]//

    if(Hw==NULL){
        F09_Halt("[F09:WindowCreateFail]");
        return 0;
    };;//[f]//

    //:Store the handle to window in global state:
    f09_handle_to_window=Hw;

    //:Modifications to make window opengl
    //:compatible:
    //////////////////////////////////////////////
    f09_MakeWindowCompatibleWith_GL(
        Hw
    );;//[g]//

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯MC|//
    //!PUT AFTER device context has been     MC!//
    //!set, or your device context fetching  MC!//
    //!function waiting on this flag to be   MC!//
    //!set in this thread will end up        MC!//
    //!with a NULL device context.           MC!//
    //!Speaking Of:                          MC!//
    //!GLEB_SWIN_GetWindowDeviceContext();   MC!//
    f09_window_created=1;                 //|MC|//
    //|______________________________________MC|//

    //////////////////////////////////////////////

    Msg = f09_WindowLoop( Hw );

    return Msg.wParam;
} //[OPEN_WINDOW_LOOP_FOREVER]//

int F09_Init(){
    
    //:No action besides calling down the chain.

    int ret = F08_Init();

    return( ret );
}//[;]//
int F09_Main(){
    F09_Init();

    //:NOT called int "Init" function, because we want
    //:to create the window in different thread higher
    //:up the chain.
    F09_OpenWindowAndLoopForever(
        L"MOTHER_FUCKING_UNIQUE_WINDOW_CLASS_ID"
    ,   L"[SEE_FILE[ F.07 ]][伍零s丁]"
    );;

    return( 0 );
}//[;]//

int F09_Demo_SingleThreaded(){
    F09_Main();
    return( 0 );
}//[;]//


//[ ]////|////////////////////////////////////////////|////[ ]//
//[ ]////|     -///-                        -///-     |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|       ______________________________       |////[ ]//
//[ ]////|______/                              \______|////[ ]//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) ///////////////////////////
/** ******************************************************** |||
                                                   
#VARS_TOP_OF_FILE_BIG_PICTURE#
    Variables are at the top of the file because they are
    what is most likely to be re-looked at when looking
    over the code months later.
                                                 
  
||| ******************************************************** **/ 
#endif /////////////////////////////////////////////////////////
//[ ]////|______                                ______|////[ ]//
//[ ]////|||||||\______________________________/|||||||////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|____________________________________________|////[ ]//

//#FILE_REGION[ F.09 ]END#####################################//
//#FILE_REGION[ F.10 ]BEG#####################################//

//:DOTADIW: WIN_IN_THREAD
//:  ( launch_window_in_new_thread )



//||Thread is closed using the HANDLE.                      ||//
//||So not sure what the point of the thread_id is.         ||//
//||                                                        ||//
//||StackOverflow:                                          ||//
//||    Under Windows,the thread handle is different from   ||//
//||    the thread ID, in the same way that a file handle   ||//                               
//||    is different from a file name.                      ||//
    //[ The fact that these threads are for the "window"     ]//
    //[ are implied by the DOTADIW of [F.10/F10_] namespace. ]//
    void*               F10_thread_handle ;         
    long unsigned int   F10_thread_id     ;  

    struct F10_STRUCT_MYDATA{
        int val1;
        int val2;
    };//[struct:MYDATA]//

    struct F10_STRUCT_MYDATA* 
    F10_custom_data_ptr=NULL;


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//[H:Halt Always first function in file._____________________]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
void F10_Halt( const char*     msg ){ 
    printf( "[F10_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//             
                                           
                                          
void                                      
F10_PrintCustomThreadData(          
                                          
    void* custom_data                     
                                          
){            
    #define MYDATA  struct F10_STRUCT_MYDATA   /////////////////
                                                 
        //[-----------------------------------]////[ xxxxxxx ]//
        //[ Both will print the same thing:---]////[ xxxxxxx ]//
        //[-----------------------------------]////[ xxxxxxx ]//
        //[PRINT:File_Member_Variable: -------]////[ xxxxxxx ]//
        printf( "[PARAMS]:( %d, %d )\n"          //[ xxxxxxx ]//
        ,   ((MYDATA*)F10_custom_data_ptr)->val1 //[ xxxxxxx ]//                           
        ,   ((MYDATA*)F10_custom_data_ptr)->val2 //[ xxxxxxx ]//
        );;                                      //[ xxxxxxx ]//
        //[PRINT:Input_Argument: -------------]////[ xxxxxxx ]//
        printf( "[PARAMS]:( %d, %d )\n"          //[ xxxxxxx ]//
        ,   ((MYDATA*)    custom_data)->val1     //[ xxxxxxx ]//       
        ,   ((MYDATA*)    custom_data)->val2     //[ xxxxxxx ]//
        );;                                      //[ xxxxxxx ]//
        //[___________________________________]////[ xxxxxxx ]//

    #undef  MYDATA /////////////////////////////////////////////
                                          
} //[PrintCustomThreadData]//   


unsigned long __stdcall           
F10_StartRoutine_CreatesWindow_CalledInNewThread(               
                                          
    void*  custom_data              
                                          
){                                        
    F10_PrintCustomThreadData( custom_data );                                  
                                                    
    #define T const unsigned short*                     
    T unique_window_name=(                  
        L"F10_UNIQUE_WINDOW_NAME"   
    );;     
    T window_titlebar_text=(
        L"[SEE_FILE[ F.08 ]]((╯°□°）╯︵ ┻━┻))"
    );;
                              
    F09_OpenWindowAndLoopForever(   
        unique_window_name   //:<---PlayItSafeStickToAsciiChars
    ,   window_titlebar_text //:<---WhateverYouWant
    );;                                   
                                          
    return 0;                             
} //[gleb_swin_THREAD_FUNCTION / F10_StartRoutine ]//      




void                                       
F10_CreateThread_Launches_StartRoutine(){                  
                                                                     
    void* process_heap=((F03_00)F02_GetProcessHeap)();
    if(NULL==process_heap){ F10_Halt("process_heap"); };                                   
                                          
    //[ Allocate memory for thread data. ]//
    F10_custom_data_ptr =((struct F10_STRUCT_MYDATA *)

        ((F03_03)F02_HeapAlloc)(                                       
            process_heap                  
        ,   
            (void*)(unsigned long long)
            0x00000008 /** HEAP_ZERO_MEMORY **/ 
                                       
        ,   
            (void*)(unsigned long long)
            sizeof(struct F10_STRUCT_MYDATA)                                  
        ) 
                                
    );;                                    
                                          
    //[¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯]//
    //[ System if out of memory, you will ]//
    //[ be unable to print error message. ]//
    //[ But what about error code?        ]//
    //[___________________________________]//
    if( F10_custom_data_ptr == NULL ){ 
        exit( 9873 );                     
    };;                                   
                                          
    //! Set Some Custom Data           !//
    F10_custom_data_ptr -> val1 = 333;   
    F10_custom_data_ptr -> val2 = 777;   
                                          
    //: typedef              //[ <<< LPTHREAD_START_ROUTINE -----]//
    //:     unsigned long    //[ <<< LPTHREAD_START_ROUTINE -----]//
    //:     (__stdcall *pfn) //[ <<< LPTHREAD_START_ROUTINE -----]//
    //:     (void*);         //[ <<< LPTHREAD_START_ROUTINE -----]//


    ////////////////////////////////////////////////////////////
    #define   P_F_N   F05_LSR //:PFN:LPTHREAD_START_ROUTINE
              P_F_N 
    pfn_start_routine=(
        F10_StartRoutine_CreatesWindow_CalledInNewThread
    );;
    #undef    P_F_N
    ////////////////////////////////////////////////////////////

    ////////// //:Not really the way I want to solve this:
    //////////  F02_VOF vof_start_routine=(     
    ////////// (F02_VOF)pfn_start_routine  );; 
                                          
    //[ Create the thread to begin execution on its own. --- ]//
    F10_thread_handle=( ////////////////////////////////////////
    /**/F08_CreateThread(   ///////////////////////////////////
    /**/   
    /**/       NULL               /** default_security   [01]**/               
    /**/   ,   0                  /** default_stack_size [02]**/                    
    /**/   ,   pfn_start_routine  /** lpStartAddress     [03]**/  
    /**/                                                 
    /**/   ,   F10_custom_data_ptr/** thread_func_arg    [04]**/    
    /**/   ,   0       /** Use_Default_Creation_Flags    [05]**/              
    /**/   ,   &( F10_thread_id ) /** Output_Param       [06]**/ 
    /**/
    /**/)    ///////////////////////////////////////////////////
    );;/////////////////////////////////////////////////////////
                                          
} //[CreateThread]//            

int F10_Init(){
    //:No action needed besides calling further down chain:

    int ret = F09_Init(); //: .SUPER_CHAIN

    //:F10 specific init logic:
    F10_CreateThread_Launches_StartRoutine();

    return( ret );

}//[;]//
    
int F10_Main(){
    F10_Init();

    printf(
        "***************** [CTRL+C:ToExit] *****************\n"
    );;

    fflush(stdout);

    while(1){

        //:Inifinite loop to keep program from
        //:exiting while window is running in
        //:that other thread.
        
        //:This is where you would launch other threads,
        //:or do a (game|render) loop.

    };;

}//[;]//

//#FILE_REGION[ F.10 ]END#####################################//
//#FILE_REGION[ F.20 ]BEG#####################################//

//: DOTADIW: VULKAN_STRUCT
//: (Declarations, no instantiation!)

struct F20_VkApplicationInfo {
    unsigned int       sType; //:VkStructureType
    const void*        pNext;
    const char*        pApplicationName;
    unsigned int       applicationVersion; //:uint32_t
    const char*        pEngineName;
    unsigned int       engineVersion;      //:unsigned int
    unsigned int       apiVersion;         //:unsigned int
};//[struct]//

struct F20_VkInstanceCreateInfo {
    unsigned int                sType; //:VkStructureType
    const void*                 pNext;
    unsigned int                flags;

    const struct F20_VkApplicationInfo*    
                      pApplicationInfo;

    unsigned int                enabledLayerCount;
    const char* const*          ppEnabledLayerNames;

    //:Is "const char**" same as "const char* const*" ?
    //:In fact.. Both are "char**" with extra constraints.

    unsigned int                enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;

};//[struct]//

struct F20_VkExtensionProperties {

    char        
    extensionName[ 

        256 /**VK_MAX_EXTENSION_NAME_SIZE**/ 

    ];

    unsigned int /** uint32_t **/    
    specVersion;

};//[struct]//

struct F20_VkLayerProperties {
    
    #define MACRO_A 256 //:VK_MAX_EXTENSION_NAME_SIZE
    #define MACRO_B 256 //:VK_MAX_DESCRIPTION_SIZE

    char            layerName[   MACRO_A ];//:MAX_EXT
    unsigned int    specVersion;
    unsigned int    implementationVersion;
    char            description[ MACRO_B ];//:MAX_DSC

    #undef MACRO_A
    #undef MACRO_B

};//[struct]//

struct 
F20_VkDebugUtilsLabelEXT {
    unsigned int       sType; /** VkStructureType **/
    const void*        pNext;
    const char*        pLabelName;
    float              color[4];
};//[struct]//

struct 
F20_VkDebugUtilsObjectNameInfoEXT {
    unsigned int         sType;        /** VkStructureType **/
    const   void*        pNext;
    unsigned int         objectType;   /** VkObjectType    **/
    unsigned long long   objectHandle; /** uint64_t        **/
    const char*          pObjectName;
};

struct 
F20_VkDebugUtilsMessengerCallbackDataEXT {

    unsigned int /** VkStructureType **/
    sType;

    const void*                                  
    pNext;

    /** VkDebugUtilsMessengerCallbackDataFlagsEXT **/ 
    unsigned int    
    flags;

    const char*                                  
    pMessageIdName;

    signed int /** int32_t **/                                      
    messageIdNumber;

    const char*                                  
    pMessage;

    unsigned int /** uint32_t **/                                     
    queueLabelCount;

    const struct F20_VkDebugUtilsLabelEXT*                  
    pQueueLabels;

    unsigned int /** uint32_t **/                                     
    cmdBufLabelCount;

    const struct F20_VkDebugUtilsLabelEXT*                  
    pCmdBufLabels;

    unsigned int /** uint32_t **/                                     
    objectCount;

    const struct F20_VkDebugUtilsObjectNameInfoEXT*         
    pObjects;

};

//[ F20_VkDebugUtilsMessengerEXT ==== void*  ]//




//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F20_Init(){
        printf("[BEG:F20:Init]\n");

        int ret = F10_Init();

        printf("[END:F20:Init]\n");
        return( ret );
    }//[;]//
    int F20_Main(){
        F20_Init();


        
        printf("[F20:TO_EXIT:CTRL+C]\n");
        while( 1 ){ /** Keep threaded window open. **/ };



        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.20 ]END#####################################//


//:DOTADIW: VULKAN_PFN_TD
//:         Vulkan Function Typedefs
//:         (do not typedef structs)

typedef 
    unsigned int /** VkBool32 **/ 
    (
        __stdcall /** VKAPI_PTR **/ 
        *F30_PFN_vkDebugUtilsMessengerCallbackEXT
    )
    (
        /** VkDebugUtilsMessageSeverityFlagBitsEXT **/
        unsigned int
        messageSeverity 
        ,
        /** VkDebugUtilsMessageTypeFlagsEXT  **/
        unsigned int
        messageTypes 
        ,
        const struct F20_VkDebugUtilsMessengerCallbackDataEXT*      
        pCallbackData 
        ,
        void*                                            
        pUserData
    );


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F30_Init(){
        printf("[BEG:F30:Init]\n");

        int ret = F20_Init();

        printf("[END:F30:Init]\n");
        return( ret );
    }//[;]//
    int F30_Main(){
        F30_Init();

        

        printf("[F30:TO_EXIT:CTRL+C]\n");
        while( 1 ){ /** Keep threaded window open. **/ };



        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
//#FILE_REGION[ F.35 ]BEG#####################################//

//:DOTADIW: STRUCTS_W_PFN
//:        ( structs_with_pfn_members )
//:F.35: 
//:      Vulkan Structs that take function pointers as
//:      defined in F.30

struct 
F35_VkDebugUtilsMessengerCreateInfoEXT {

    unsigned int  /** VkStructureType **/   
    sType;

    const void*                             
    pNext;

    unsigned int  /** VkDebugUtilsMessengerCreateFlagsEXT **/
    flags;

    unsigned int  /** VkDebugUtilsMessageSeverityFlagsEXT **/
    messageSeverity;

    unsigned int  /** VkDebugUtilsMessageTypeFlagsEXT     **/         
    messageType;

    F30_PFN_vkDebugUtilsMessengerCallbackEXT      
    pfnUserCallback;

    void*                                   
    pUserData;
};//[struct]//


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F35_Init(){
        printf("[BEG:F35:Init]\n");

            //:Call previous initialiers on chain:
            int ret = F30_Init(); //: ".SUPER_CHAIN()"

        printf("[END:F35:Init]\n");
        return( ret );
    }//[;]//
    int F35_Main(){
        F35_Init();

            printf("[F35:TO_EXIT:CTRL+C]\n");
            while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.35 ]END#####################################//
//#FILE_REGION[ F.40 ]BEG#####################################//

//:DOTADIW: VK_INIT_PART1
//:         Vulkan Tutorial Code Begins

static void 
f40_Halt( const char* msg ){ 
    printf( "[F40_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//

          /** f40_use_validation_layers **/
#define f40_MACRO_use_validation_layers 1

//:For use outside this file, so we can undefine the
//:macro before we leave.
int f40_use_validation_layers=(

    f40_MACRO_use_validation_layers

);//[ON_SCOOBY_DOO_SHAGGYS_REAL_NAME_IS:Norville Rogers]//
//:https://en.wikipedia.org/wiki/Shaggy_Rogers

static struct 
F20_VkApplicationInfo 
f40_appInfo = { 0 };

static void* 
f40_instance = NULL; //: VkInstance

static struct 
F20_VkInstanceCreateInfo
f40_createInfo = { 0 };

static struct 
F20_VkExtensionProperties* 
f40_extensions = NULL;

static struct
F20_VkLayerProperties*
f40_layers=NULL; //:f40_instance_validation_layers

//: static void* /** VkDebugUtilsMessengerEXT **/
//: f40_callback=NULL;

//: static int //:NOOP: No-operation.
//: f40_NOOP1( void* arg1 ){ 
//:     if( arg1 ){ /** NOOP **/ };
//:     return( 0 );
//: }//[;]//

////////////////////////////////////////////////////////////////

                 /** f40_use_validation_layers **/
    #if(       f40_MACRO_use_validation_layers <= 0 ) //:OFF

        #define f40_wanted_extensions_count_MACRO 2

        static const char* 
        f40_wanted_extensions[ 

            f40_wanted_extensions_count_MACRO 

        ]={ 
                "VK_KHR_surface"
            ,   "VK_KHR_win32_surface"
        };

                 /** f40_use_validation_layers **/
    #elif(     f40_MACRO_use_validation_layers >  0 ) //:ENABLE
    
        #define f40_wanted_extensions_count_MACRO 3

        static const char* 
        f40_wanted_extensions[ 

            f40_wanted_extensions_count_MACRO 

        ]={ 
                "VK_KHR_surface"
            ,   "VK_KHR_win32_surface"
            ,   "VK_EXT_debug_utils" //:PG[55]SC[VKT2018]
        };

                 /** f40_use_validation_layers **/
    #endif //: f40_MACRO_use_validation_layers

#undef  UNDEF_THAT_MACRO_AT_BOTTOM_OF_FILE /////////////////////
#define f40_wanted_validation_layers_count_MACRO 1 /////////////

    static const char*
    f40_wanted_validation_layers[
        f40_wanted_validation_layers_count_MACRO
    ]={

        "VK_LAYER_LUNARG_standard_validation"

    };

#undef  UNDEF_THAT_MACRO_AT_BOTTOM_OF_FILE /////////////////////

////////////////////////////////////////////////////////////////

//: This belongs somewhere in the future.
//  int F40_EngineLoop( void ){
//      while( 1 ){
//  
//          //:RenderingLogicHere
//  
//      };;
//  }//[;]//

////////////////////////////////////////////////////////////////

//:    www.khronos.org/registry/vulkan/specs
//: /1.1-extensions/man/html/VK_MAKE_VERSION.html
static unsigned int f40_MV( //:VK_MAKE_VERSION 
    unsigned int major
,   unsigned int minor
,   unsigned int patch
){

    unsigned int ret;
    ret = (((major) << 22) | ((minor) << 12) | (patch));
    return( ret );

}//[;]//


////////////////////////////////////////////////////////////////


//:f40_debugCallback:
//:Renamed to f60_debugCallback and moved into "F.60"

static int 
f40_EngineInit( void ){  //:CALLED:"initVulkan()" in tutorial.

    //:TODO: STUFF:

    //:What Extensions Do We Have?
    ////////////////////////////////////////////////////////////
    unsigned int
    extensionCount = 0;
    ((F03_03)F02_vkEnumerateInstanceExtensionProperties)(
        NULL
    ,   &extensionCount
    ,   NULL
    );;

        {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{

            int one = sizeof(struct F20_VkExtensionProperties);
            int all = one*extensionCount;
            f40_extensions = malloc( all );

        }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}

    ((F03_03)F02_vkEnumerateInstanceExtensionProperties)(
        NULL
    ,   &extensionCount
    ,    f40_extensions
    );;

    printf("[extensionCount]:%d\n", extensionCount);
    for( int i = 0; i < (int)extensionCount; i++ ){

        printf("[INST_EXT_NAME:%s\n",
            (f40_extensions[ i ]).extensionName
        );;
    };;
    fflush(stdout);

    ////////////////////////////////////////////////////////////

    //: Chapter 6: Using Validation Layers.
    //: VK_TUT_2018.PDF   , BOOK_PAGE[ 52 - 53 ]
    ////////////////////////////////////////////////////////////

    if( f40_layers ){ /** NOOP **/ };

    unsigned int layer_count = 0;
    ((F03_02)F02_vkEnumerateInstanceLayerProperties)(
        &layer_count
    ,   NULL
    );;
    
    if( layer_count <= 0 ){
        f40_Halt("[WTF:NoLayers]\n");
    };;
    
        {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{

        //: [ f40_layers / 40_instance_validation_layers ]

        int one = sizeof( struct F20_VkLayerProperties );
        int all = one*layer_count;
        f40_layers=malloc(all); 

        }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
    
    ((F03_02)F02_vkEnumerateInstanceLayerProperties)(
        &layer_count
    ,    f40_layers
    );;
    
    printf("[layer_count]:%d\n", ((int)layer_count));
    for( int i = 0; i < (int)layer_count; i++ ){
    
        printf("[VAL_LAY:%s\n",
            (f40_layers[ i ]).layerName
        );;
    };;
    fflush(stdout);


    //:Compare against the validation layers you want:
    {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
    int found;
    
        int wanted_count =(
            f40_wanted_validation_layers_count_MACRO
        );;
        for( int w = 0; w <     wanted_count;  w++ ){ //:WANTED  
        for( int h = 0; h < (int)layer_count;  h++ ){ //:HAVE   

            //:FIRST:"h"
            ////////////////////////////////////////////////////
            if(0==h){ found = 0; }; //:RESET, first "h"
            ////////////////////////////////////////////////////

            //:BODY:
            ////////////////////////////////////////////////////
            
            const char* have = f40_layers[h].layerName;
            const char* want = f40_wanted_validation_layers[w];
            int com_res =( strcmp( have, want ) );
            if(0==com_res){
                found=1; break;
            };;

            ////////////////////////////////////////////////////

            //:LAST:"h"
            ////////////////////////////////////////////////////
            if( h == ((int)layer_count-1) ){ //:(-1)==LAST_ITEM
                if(found <= 0 ){
                    printf("[MISSING_LAYER]:%s\n", want );
                    f40_Halt(
                        "[WANTED_VALIDATION_LAYER_NOT_FOUND]"
                    );;
                };;
            };;
            ////////////////////////////////////////////////////

        };;};; //[ NEXT: WANTED|HAVE ]// ///////////////////////
    
    
    }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}

        //:Create Instance:
        ////////////////////////////////////////////////////////
        f40_appInfo.sType    = 0; /** APPLICATION_INFO **/
        f40_appInfo.pApplicationName   = "HELLO_TRIANGLE";
        f40_appInfo.applicationVersion = f40_MV(1,0,0)   ;
        f40_appInfo.pEngineName        = "No Engine"     ;
        f40_appInfo.engineVersion      = f40_MV(1,0,0)   ;
        f40_appInfo.apiVersion         = f40_MV(1,0,0)   ;

        f40_createInfo.sType = 1; /** INSTANCE_CREATE_INFO **/
        f40_createInfo.pApplicationInfo = &(f40_appInfo);
        f40_createInfo.enabledExtensionCount=(
            f40_wanted_extensions_count_MACRO
        );;
        f40_createInfo.ppEnabledExtensionNames=(
            f40_wanted_extensions
        );;

        f40_createInfo.enabledLayerCount=0;
        f40_createInfo.ppEnabledLayerNames=NULL;

            ////////////////////////////////////////////////////
            /** ENABLE_VALIDATION_LAYERS ?  **/  
            /**       f40_use_validation_layers **/
            if( f40_MACRO_use_validation_layers > 1 ){

                f40_createInfo.enabledLayerCount =(
                    f40_wanted_validation_layers_count_MACRO
                );;
                f40_createInfo.ppEnabledLayerNames=(
                    f40_wanted_validation_layers
                );;

            };;
            ////////////////////////////////////////////////////
       
        unsigned int res=(
            (unsigned int)(unsigned long long)
            ((F03_03)F02_vkCreateInstance)(
                &(f40_createInfo)
            ,   (void*)NULL
            ,   &(f40_instance)
            )
        );;
        if( 0 != res ){
            f40_Halt( "[2019_12_11:0213AM]");
        }else{

            printf("[vkCreateInstance:WORKED!]\n");
            fflush(stdout);

        };;
        ////////////////////////////////////////////////////////
    
        /******************************************************/
        /**  Setup code continued in FILE[ F.60 ]            **/
        /**  Because we need to grab function pointers that  **/
        /**  require a reference to a vulkan instance.       **/
        /**  This is done in FILE[ F.50 ]                    **/
        /******************************************************/
   
    ////////////////////////////////////////////////////////////
    //:END Chapter 6

    return( 0 );
}//[;]//

//: Window now already opened via .SUPER_CHAIN
//: static int 
//: f40_OpenWindowAndInitializeEngine( void ){
//: 
//:     //:Start up the window loop:
//:     F10_CreateThread_Launches_StartRoutine();
//:     
//:     //:Initialize Vulkan Stuff:
//:     f40_EngineInit();
//: 
//:     return( 0 );
//: }//[;]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F40_Init(){
        printf("[BEG:F40:Init]\n");

        int ret = F35_Init(); //: ".SUPER_CHAIN()"

        //:Call here to avoid initialization fork:
        //:You don't want "F.50" to have to call TWO previous
        //:initializers and have to guess in which order they
        //:need to be called.
        //:f40_OpenWindowAndInitializeEngine();
        f40_EngineInit();

        printf("[END:F40:Init]\n");
        return( ret );
    }//[;]//
    int F40_Main(){
        F40_Init();

        printf("[F40:TO_EXIT:CTRL+C]\n");

        //:Stand in for where "mainLoop()" in future file.
        //:(Tutorial uses name "mainLoop()", I probably won't
        //:use that name. I'll probably call it: "EngineLoop()"
        while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


#undef  f40_wanted_extensions_count_MACRO         //////////////
#undef  f40_wanted_validation_layers_count_MACRO  //////////////
#undef  f40_MACRO_use_validation_layers           //////////////

//#FILE_REGION[ F.40 ]END#####################################//
//#FILE_REGION[ F.50 ]BEG#####################################//

//:DOTADIW: VK_INST_FUNCS
//:         ( GetVulkanExtensionFunctions )
//:         
//:OUTISDE OF SCOPE:
//:         Proper wrapper code for function pointers.
//:
//:GATHER VULKAN EXTENSION FUNCTIONS.
//:Lets go light on the "macro magic" though.
//:You can save ALMOST as much space without using macros,
//:and end up with much less obfuscated code.


F02_VOF
F50_vkCreateDebugUtilsMessengerEXT = NULL;


static F02_VOF //:<--returns generic function pointer.
f50_GIPA( /** vkGetInstanceProcAddr **/
    void*       vk_instance
,   const char* function_name
){
    if( vk_instance   ){ /** NOOP **/ };  
    if( function_name ){ /** NOOP **/ };

    //:TODO: logic.

    return( (F02_VOF)0 ); //:VOID FUNCTION.

}//[;]//

static void
f50_fetchAndLoad_VulkanInstanceFunctions(){

    F50_vkCreateDebugUtilsMessengerEXT=f50_GIPA(
        f40_instance
    ,   "vkCreateDebugUtilsMessengerEXT"
    );;

}//[;]//



//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F50_Init(){
        printf("[BEG:F50:Init]\n");

            //:Call previous initialiers on chain:
            int ret = F40_Init(); //: ".SUPER()"

            f50_fetchAndLoad_VulkanInstanceFunctions( );

        printf("[END:F50:Init]\n");
        return( ret );
    }//[;]//
    int F50_Main(){
        F50_Init();

            printf("[F50:TO_EXIT:CTRL+C]\n");
            while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//





//#FILE_REGION[ F.50 ]END#####################################//
//#FILE_REGION[ F.60 ]BEG#####################################//

//:
//: DOTADIW: VULKAN_INIT_PART_02
//:   






static int //:NOOP: No-operation.
f60_NOOP1( void* arg1 ){ 
    if( arg1 ){ /** NOOP **/ };
    return( 0 );
}//[;]//


//:PG[55]SC[VKT2018]
static unsigned int __stdcall
f60_debugCallback(
/**/  
/**/      /** VkDebugUtilsMessageSeverityFlagBitsEXT **/
/**/      unsigned int 
/**/      messageSeverity
/**/  
/**/      /** VkDebugUtilsMessageTypeFlagsEXT        **/
/**/  ,   unsigned int
/**/      messageType
/**/  
/**/  ,   const struct F20_VkDebugUtilsMessengerCallbackDataEXT* 
/**/      pCallbackData
/**/  
/**/  ,   void* 
/**/      pUserData
/**/  
){

    if( messageSeverity ){ /** NOOP **/ };
    if( messageType     ){ /** NOOP **/ };
    if( pUserData       ){ /** NOOP **/ };

    printf("[Validation_Layer]:%s\n", pCallbackData->pMessage);

    return( 0 /** VK_FALSE **/ );

}//[;]//

















//:  Picking up from where we left off with                  ://
//:  f40_OpenWindowAndInitializeEngine after a               ://
//:  short intermission to gather vulkan instance funcs.     ://
static void
f60_EngineInit_PART2_WindowAlreadyOpen( void ){

    //:BOOK_PAGE[57]://
    /** f40_MACRO_use_validation_layers **/
    if( f40_use_validation_layers > 0 ){

        struct F35_VkDebugUtilsMessengerCreateInfoEXT
        create_info={ 0 };

        /** VK_STRUCTURE_TYPE: 1000128004          **/
        /** DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT  **/
        create_info.sType = 1000128004;
        create_info.messageSeverity=(
         0 /** VK_DEBUG_UTILS_MESSAGE_SEVERITY_*_EXT **/
            | 0x00000001 /** VERBOSE_BIT **/
            | 0x00000100 /** WARNING_BIT **/
            | 0x00001000 /** ERROR_BIT   **/
        |0);;
        create_info.messageType     =(
         0 /** VK_DEBUG_UTILS_MESSAGE_TYPE_*_EXT **/
            | 0x00000001 /** GENERAL_BIT     **/
            | 0x00000002 /** VALIDATION_BIT  **/
            | 0x00000004 /** PERFORMANCE_BIT **/
        |0);;
        create_info.pfnUserCallback = f60_debugCallback;
        create_info.pUserData       = NULL; /** Optional **/

        printf("[TODO:vkGetInstanceProcAddr, page 58]\n");
        if( create_info.sType != 1000128004  ){ 
            f40_Halt("[sType!=1000128004]\n");
        };;

        f60_NOOP1( &create_info );
     //:f60_NOOP1( f40_callback );

    };;

}//[;]//


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F60_Init(){
        printf("[BEG:F60:Init]\n");

        //:Get instance function pointers:
        int ret = F50_Init(); //: ".SUPER_CHAIN()"

        f60_EngineInit_PART2_WindowAlreadyOpen();

        printf("[END:F60:Init]\n");
        return( ret );
    }//[;]//
    int F60_Main(){
        F60_Init();

        //:Stand in for a renderloop, so that program does
        //:not immediately exit and you never see window and
        //:assume error is in your code.
        printf("[F60:TO_EXIT:CTRL+C]\n");
        fflush(stdout );

        while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.60 ]END#####################################//
//#FILE_REGION[ VG03.H ]BEG###################################//

//|---- F01 ------|////[ DOTADIW:DLL_FUNC_LIST ]//
//|---- F02 ------|////[ DOTADIW:DLL_FUNC_LOAD ]//
//|-----F03 ------|////[ DOTADIW:DLL_CALL_CAST ]//

//|-----F04 ------|////[ DOTADIW:DLL_STRUCTS   ]//
//|-----F05 ------|////[ DOTADIW:DLL_TYPEDEFS  ]//

//|-----F06 ------|////[ DOTADIW:DLL_PARG_LIST ]//
//|-----F07 ------|////[ DOTADIW:DLL_WRAP_BOIL ]//
//|-----F08 ------|////[ DOTADIW:DLL_WRAP_MAKE ]//

//|-----F09 ------|////[ DOTADIW:MAKE_A_WINDOW ]//
//|-----F10 ------|////[ DOTADIW:WIN_IN_THREAD ]//

//|-----F20 ------|////[ DOTADIW:VULKAN_STRUCT ]//
//|-----F30 ------|////[ DOTADIW:VULKAN_PFN_TD ]//
//|-----F35 ------|////[ DOTADIW:STRUCTS_W_PFN ]//

//|-----F40 ------|////[ DOTADIW:VK_INIT_PART1 ]//
//|-----F50 ------|////[ DOTADIW:VK_INST_FUNCS ]//
//|-----F60 ------|////[ DOTADIW:VK_INIT_PART2 ]//
    

int
VG03_Demo( void ){
    printf("[BEG:VG03_DEMO]\n");


    //:F10_Main();
    //:F35_Main();
    //:F40_Main();
    //:F50_Main();
    F60_Main();


    printf("[END:VG03_DEMO]\n");
    return( 0 );
}//[;]//


//#FILE_REGION[ VG03.H ]END###################################//