
//#FILE_REGION[ W32/DLLL/DLLL.COMSET ]BEG#####################//


//| Only choose one to set to 1 |//
#define COMPILE_FOR_windows_10_64bit 1


//#FILE_REGION[ W32/DLLL/DLLL.COMSET ]END#####################//
//#FILE_REGION[ W32/DLLL/TARG/W10.X64 ]BEG####################//

#if( COMPILE_FOR_windows_10_64bit >= 1 ) //:VGAURD
//////////////////////////////////////////////////

//:PS2_3: Pebwalk_Substitution
//: "_3": More Widdling Away.
//:       Moved from _2 to _3 in order to remove
//:       large chunks of code that are never
//:       executed. (And thus I cannot test the)
//:       (validity of.)


//| 0x00: IMAGE_DATA_DIRECTORY    . VirtualAddress        |//
//| 0x70: IMAGE_OPTIONAL_HEADER   . DataDirectory         |//
//| 0x1C: IMAGE_EXPORT_DIRECTORY  . AddressOfFunctions    |//
//| 0x20: IMAGE_EXPORT_DIRECTORY  . AddressOfNames        |//
//| 0x24: IMAGE_EXPORT_DIRECTORY  . AddressOfNameOrdinals |//
//| 0x18: IMAGE_EXPORT_DIRECTORY  . NumberOfNames         |//
//| 0x18: IMAGE_NT_HEADERS        . OptionalHeader        |//
//| 0x3C: IMAGE_DOS_HEADER        . e_lfanew              |//
//| 0x00: LIST_ENTRY              . Flink                 |//
//| 0x20: LDR_DATA_TABLE_ENTRY    .Reserved2[0]           |//
//|                                                       |//
//| 0x48: LDR_DATA_TABLE_ENTRY    .FullDllName            |//
//| 0x08:                          FullDllName.Buffer     |//
//|                                                       |//
//| 0x18: PEB.Ldr                                         |//
//| 0x20:     Ldr.InMemoryOrderModuleList                 |//
//| 0x00:         InMemoryOrderModuleList.Flink           |//

// #define WIN32_LEAN_AND_MEAN
// #include <Windows.h>
// #include <winternl.h>
// #include <malloc.h>
// 
// #ifdef _M_AMD64
// #include <intrin.h>
// #elif defined(_M_ARM)
// #include <armintr.h>
// #endif



#include <string.h> //: strcmp


//|M:Macros: (Non-Local Macros)________________|//
//|MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM|//
//:See MSDN documentation on:
//:"ImageDirectoryEntryToDataEx"
#define MACRO_x_IMAGE_DIRECTORY_ENTRY_EXPORT 0

//:IMAGE_DATA_DIRECTORY struct is 128 bytes.
//:When doing address indexing math, multiply
//:by this value.
#define MACRO_sizeof_IMAGE_DATA_DIRECTORY 128

#define MACRO_WINAPI __stdcall
#define MACRO_WINDOWS_xxx_MB_OK 0x00000000L
//|MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM|//



typedef
    const char* //:<--ImmutableStringPointer
    TYPEDEF_LPCSTR;

typedef
    unsigned long //:32 bits, unsigned
    TYPEDEF_ULONG;

typedef
    unsigned long long //:64 bits, unsigned.
    TYPEDEF_DWORD_PTR;

typedef 
    const unsigned short *  TYPEDEF_LPCWSTR;

//:Though "HMODULE" is a void*, you cannot mix
//:"void*" with window's HMODULE because HMODULE
//:is declared using DECLARE_HANDLE hack. Which
//:creates a pointer to a dummy struct.
typedef 
    void* TYPEDEF_HMODULE;


//|FT:Function_Typedefs________________________|//
//|FTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFT|//

typedef 
    TYPEDEF_HMODULE                  //:RETURNS
    (MACRO_WINAPI *LoadLibraryAF)  //:CC+NAME
    (TYPEDEF_LPCSTR lpFileName    ); //:PARAM_L

typedef
    unsigned long long               //:RETURNS
    ( __stdcall  *TYPEDEF_FARPROC )  //:NAME
    ( /**NOT_SPECIFIED != void**/ ); //:PARAMS

typedef 
    TYPEDEF_FARPROC
    (MACRO_WINAPI *GetProcAddressF)
    (
        TYPEDEF_HMODULE hModule
    ,   TYPEDEF_LPCSTR lpProcName
    );

//|FTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFT|//

//////////////////////////////////////////////////

LoadLibraryAF
dll_LoadLibraryA   =NULL;

GetProcAddressF
dll_GetProcAddress =NULL;
//////////////////////////////////////////////////



#include <stdlib.h> //: exit()
#include <stdio.h> //:printf(...)

//:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX://  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    //:PERMA:SHORTCUT[ PASTE_COM_WID_STR_INS ]      //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//:CWSI: Compare_Wide_Strings_Insensitive           //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
#include <stdio.h> //:for: printf(...)              //[CWSI:2019_11_28]//
#include <assert.h>                                 //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
int                                                 //[CWSI:2019_11_28]//
JMIM_lstrcmpiW( //[lstrcmpiW]//                     //[CWSI:2019_11_28]//
    const unsigned short* str_1                     //[CWSI:2019_11_28]//
,   const unsigned short* str_2                     //[CWSI:2019_11_28]//
){                                                  //[CWSI:2019_11_28]//
    void JMIM_lstrcmpiW_LAZYTEST();                 //[CWSI:2019_11_28]//
         JMIM_lstrcmpiW_LAZYTEST();                 //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    #define U unsigned short /////////////////////  //[CWSI:2019_11_28]//
    #define S   signed short /////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    int dex =(0-1);                                 //[CWSI:2019_11_28]//
    U r_e_s_u_l_t ;                                 //[CWSI:2019_11_28]//
    U chr_1       ;                                 //[CWSI:2019_11_28]//
    U chr_2       ;            //: 97 - 65          //[CWSI:2019_11_28]//
    U       sub_to_get_uppercase = 'a'-'A';         //[CWSI:2019_11_28]//
    assert( sub_to_get_uppercase > 0 );             //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    #undef  U ////////////////////////////////////  //[CWSI:2019_11_28]//
    #undef  S ////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    while( 1 ){                                     //[CWSI:2019_11_28]//
        dex++;                                      //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        chr_1=str_1[ dex ];                         //[CWSI:2019_11_28]//
        chr_2=str_2[ dex ];                         //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        //:Convert both characters to uppercase:    //[CWSI:2019_11_28]//
        //////////////////////////////////////////  //[CWSI:2019_11_28]//
        if( chr_1 >= 'a' && chr_1 <= 'z' ){         //[CWSI:2019_11_28]//
            chr_1 = chr_1 - sub_to_get_uppercase;   //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
        if( chr_2 >= 'a' && chr_2 <= 'z' ){         //[CWSI:2019_11_28]//
            chr_2 = chr_2 - sub_to_get_uppercase;   //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
        //////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
                 r_e_s_u_l_t = (chr_1 - chr_2);     //[CWSI:2019_11_28]//
        if( 0 != r_e_s_u_l_t ){ break; };           //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        //:Null terminator found. Exit.             //[CWSI:2019_11_28]//
        if(0==chr_1 || 0==chr_2){                   //[CWSI:2019_11_28]//
            break;                                  //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
    };;                                             //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    return( (int)r_e_s_u_l_t );                     //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//////////////////////////////////////////////////  //[CWSI:2019_11_28]//
static char JMIM_lstrcmpiW_TESTED = 0;              //[CWSI:2019_11_28]//
static char JMIM_lstrcmpiW_TESTIN = 0;              //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
void                                                //[CWSI:2019_11_28]//
JMIM_lstrcmpiW_TESTIT(){                            //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTED=0;                        //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTIN=1;                        //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    int res;                                        //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    const unsigned short* A1=L"WIDE";               //[CWSI:2019_11_28]//
    const unsigned short* B1=L"wide";               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    res = JMIM_lstrcmpiW(A1,B1);                    //[CWSI:2019_11_28]//
    assert( 0==res );                               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    // ---------------------------------------- //  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    const unsigned short* A2=L"JEFF";               //[CWSI:2019_11_28]//
    const unsigned short* B2=L"PAUL";               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    res = JMIM_lstrcmpiW(A2,B2);                    //[CWSI:2019_11_28]//
    assert( 0!=res );                               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTIN=0;                        //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTED=1;                        //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
void                                                //[CWSI:2019_11_28]//
JMIM_lstrcmpiW_LAZYTEST(){                          //[CWSI:2019_11_28]//
    if( 0 == 0                                      //[CWSI:2019_11_28]//
    &&  0 >= JMIM_lstrcmpiW_TESTED //:NOT_TESTED    //[CWSI:2019_11_28]//
    &&  0 >= JMIM_lstrcmpiW_TESTIN //:NOT_TESTING   //[CWSI:2019_11_28]//
    ){       JMIM_lstrcmpiW_TESTIT(); };            //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//////////////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX://  //[CWSI:2019_11_28]//





void*
VOID_T16B( //:TruncatePointerTo16Bits (2bytes)

    void* addr

){

    #define U unsigned long long /////////////////

    /////////0xR_G_B_AA==4bytes,  32bits
    U mask = 0x0000FFFF ;     //: 16bits
    U addr_u = (U)addr;       //: Unsigned Long
    U addr_t = addr_u & mask; //: Truncated
    
    return( (void*)addr_t );

    #undef  U ////////////////////////////////////

}//[;]//

void*
VOID_T32B( //:TruncatePointerTo32Bits (4bytes)
    void* addr
){
    #define U unsigned long long /////////////////

    /////////0xR_G_B_AA==4bytes,32bits
    U mask = 0xFFFFFFFF ;
    U addr_u = (U)addr;       //:Unsigned Long
    U addr_t = addr_u & mask; //:Truncated
    
    return( (void*)addr_t );

    #undef  U ////////////////////////////////////
}//[;]//

//:Add two addresses together.
void*
VOID_Plus(
/**/    void* addr_01
,       void* addr_02
){

    #define U unsigned char //////////////////////
    #define L unsigned long long /////////////////

        //:addr_01 is casted to a byte pointer
        //:so that offsets from adding addr_02
        //:will be multiplied by 1 (sizeof byte)
        //:rather than 4 or 8.

        U* A_1=(U*)addr_01;
        L  A_2=(L )addr_02;
        U* A_3=( A_1 + A_2 );
        return( (void*)A_3 );

    #undef  U ////////////////////////////////////
    #undef  L ////////////////////////////////////

}//[;]//

//:Perform: (addr_01 - addr_02 )
void*
VOID_Minu(
/**/    void* addr_01
,       void* addr_02
){

    #define U unsigned char //////////////////////
    #define L unsigned long long /////////////////

    U* A_1=(U*)addr_01;
    L  A_2=(L )addr_02;
    U* A_3=( A_1 - A_2 );
    return( (void*)A_3 );

    #undef  U ////////////////////////////////////
    #undef  L ////////////////////////////////////

}//[;]//


//|Example Usage:                              |//
//|Find the relative offset in bytes from      |//
//|the base address "pOptionalHeader"          |//
//|to the member "DataDirectory"               |//
//|ANSWER: (0x70)                              |//
//|--------------------------------------------|//
//|  VOID_PROS(                                |//
//|      pOptionalHeader                       |//
//|  , &(pOptionalHeader->DataDirectory)       |//
//|  ,  "pOptionalHeader .DataDirectory"       |//
//|  );;                                       |//
void
VOID_PROS( //:PROS:Print_Relative_OffSet
/**/    void* base_address
,       void* seek_address
,       const char*    msg
){
    if( base_address > seek_address ){
        printf("[Bad_Ordering]\n");
        fflush(stdout);
        exit(666);
    };;

    //:   os:offset/delta:
    void* os = VOID_Minu(
        seek_address //:<----LARGER_VALUE
    ,   //  -     //
        base_address //:<----SMALLER_VALUE
    );;

    printf(
        "[PROS:msg]:%s\n[PROS:os]:%p\n"
    ,    msg,os
    );;

}//[;]//

void* 
VOID_Seek( 

/**/    void* data
,       int byte_offset 

){

    //:In order to have the correct byte offset
    //:applied to the pointers, you have to make
    //:sure they are casted to byte pointers
    //:first. Casting to void* seems to work
    //:as well. But I wouldn't trust that. Since
    //:the size of a pointer is either 4 or
    //:8 bytes, so offsets being multiplied by
    //:4 or 8 with void* would not suprise me
    //:depending on the C compiler.

    #define U unsigned char //////////////////////

        //:A_0: Start_Address
        //:A_1: End___Address

        U* A_0=(U*)data;  
        U* A_1=( A_0 + byte_offset );

        return( (void*)A_1 );

    #undef  U ////////////////////////////////////

}//[;]//

void* 
VOID_Load( 

/**/    void* data 

){

    //:Assumming the data is a pointer,
    //:it holds the address to some object
    //:somewhere else. We want to load that
    //:address.

    void** ptr = (void**)data; //:POINTER
    void*  aod = *(ptr);       //:ADDRESS_OR_DATA

    return( aod );
}//[;]//


//:Perform a series of memory offsets on an
//:address until you get to whatever destination
//:you are looking for.
//:
//:NOTE: Add 'A' and Seek 'S' instructions
//:      have the same result. But Add('A') was
//:      originally written for adding an address
//:      and Seek('S') was originally for a
//:      hexadecimal relative offset from the
//:      base address of a struct.
void*
VOID_Inst(
/**/    void*          initial_address  
,       unsigned long long* instruction_arr
){
    //:Instructions come in pairs:
    //:1: Instruction Type (Op-code)
    //:2: Instruction Data

    //: 0x00:     :  Terminate_Instruction_Stream
    //: 0x53: 'S' :  SEEK (takes an offset)
    //: 0x4C: 'L' :  LOAD
    //:              DATA==0: Load Full Address
    //:              DATA==4: Truncate to 4 bytes.
    //: 0x41: 'A' :  ADD  (Add addresses  )
    //: 0x54: 'T' :  Truncate to n bytes.(data==n)


    int code_index = (0-1);
    int data_index = (0-1);
    int pair_index = (0-1);

    unsigned long long  code;
    unsigned long long  data;

    void*  p = initial_address;
    void** pp= NULL;

    while(1){
        pair_index++;

        code_index = pair_index*2;
        data_index = code_index+1;
        
        code = instruction_arr[ code_index ];
        data = instruction_arr[ data_index ];

        if( 'S' == code ){ //:SEEK

            #define U unsigned long long /////////
            void* base_address = p;
            U     byte_offset  =(U)data;
            #undef  U ////////////////////////////

            #define U unsigned char //////////////

                //:A_0: Start_Address
                //:A_1: End___Address

                U* A_0=(U*)    base_address ;  
                U* A_1=( A_0 + byte_offset );

                p=(void*)A_1;

            #undef  U ////////////////////////////
            

        }else
        if( 'L' == code ){ //:LOAD
            if(data==0x00){
                //:LEA(Load Affective Address)
                //:by de-referencing the pointer.
                pp=(void**)p;
                p=(*pp);
            }else{

                //:LEA(Load Affective Address)
                //:by de-referencing the pointer.
                pp=(void**)p;
                p=(*pp);


                //:TRUNCATE address AFTER loading:


                #define U unsigned long long ///////////|------------|//
                                                      //| 2019_11_28 |//
                void* addr = p;                       //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                //:addr_f: Address_Full               //| 2019_11_28 |//
                //:addr_t: Address_Truncated          //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                ///////////0x1234567812345678         //| 2019_11_28 |//
                U mask_8 = 0xFFFFFFFFFFFFFFFF;//64bits//| 2019_11_28 |//
                ///////////0xR_G_B_AA == 4bytes,32bits//| 2019_11_28 |//
                U mask_4 = 0xFFFFFFFF;//:4bytes,32bits//| 2019_11_28 |//
                U mask_2 = 0xFFFF    ;//:2bytes,16bits//| 2019_11_28 |//
                U mask   = 0;                         //| 2019_11_28 |//
                if( 2 == data ){ mask = mask_2; };    //| 2019_11_28 |//
                if( 4 == data ){ mask = mask_4; };    //| 2019_11_28 |//
                if( 8 == data ){ mask = mask_8; };    //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                U addr_f = (U)addr;       //:All_Bits //| 2019_11_28 |//
                U addr_t = addr_f & mask; //:32__Bits //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                p=( (void*)addr_t );                  //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                #undef  U //////////////////////////////|____________|//

            };;

        }else
        if( 'T'  == code ){ //:TRUNCATE_4:
        //:Truncate address to first T bytes,
        //:The rest will be zeros.

            #define U unsigned long long ///////////|------------|//
                                                  //| 2019_11_28 |//
            void* addr = p;                       //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            //:addr_f: Address_Full               //| 2019_11_28 |//
            //:addr_t: Address_Truncated          //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            ///////////0x1234567812345678         //| 2019_11_28 |//
            U mask_8 = 0xFFFFFFFFFFFFFFFF;//64bits//| 2019_11_28 |//
            ///////////0xR_G_B_AA == 4bytes,32bits//| 2019_11_28 |//
            U mask_4 = 0xFFFFFFFF;//:4bytes,32bits//| 2019_11_28 |//
            U mask_2 = 0xFFFF    ;//:2bytes,16bits//| 2019_11_28 |//
            U mask   = 0;                         //| 2019_11_28 |//
            if( 2 == data ){ mask = mask_2; };    //| 2019_11_28 |//
            if( 4 == data ){ mask = mask_4; };    //| 2019_11_28 |//
            if( 8 == data ){ mask = mask_8; };    //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            U addr_f = (U)addr;       //:All_Bits //| 2019_11_28 |//
            U addr_t = addr_f & mask; //:32__Bits //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            p=( (void*)addr_t );                  //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            #undef  U //////////////////////////////|____________|//

        }else
        if( 'A' == code ){  //:ADD address

            #define U unsigned char ////////////// 
            #define L unsigned long long ///////// 
            
                //|addr_01 is casted to a byte |//
                //|pointer so that offsets from|//
                //|adding addr_02 will be      |//
                //|multiplied by 1 (sizeof     |//
                //|byte) rather than 4 or 8.   |//
            
                void* addr_01 = p;
                void* addr_02 = (void*)data;
            
                U* A_1=(U*)addr_01;
                L  A_2=(L )addr_02;
                U* A_3=( A_1 + A_2 );
            
                p = ( (void*)A_3 );
            
            #undef  U //////////////////////////// 
            #undef  L //////////////////////////// 

        }else
        if( 0x00 == code ){ //:END_OF_STREAM

            break;
        
        }else{
            printf("[INVALID_OP_CODE]\n");
            fflush(stdout);
            exit(666);
        };;

    };;
    
    //:Return the resulting address from all
    //:of the operations:
    return( p );

}//[;]//


//:Like VOID_Inst, but the instruction stream
//:first instruction is always an intitial('I')
//:start address to load. Thus only one argument
//:is needed instead of two.
void*
VOID_Oper(
    unsigned long long* instruction_arr
){
    if( 'I' != instruction_arr[0] ){
        printf("[I:ShouldBeFirstInstruction]\n");
        fflush(stdout);
        exit(666);
    };;

    //:Change first instruction to "add"
    instruction_arr[0]='A';
   
    //:Starting at address 0 essentially
    //:will load initial start address.
    void* p = VOID_Inst( 0x00, instruction_arr );

    //:Change the first instruction back to
    //:'I' so calling code is unaware of our
    //:hacky ways.
    instruction_arr[0]='I';

    return( p );

}//[;]//


//|_M_IX86 Defined as the integer literal value|//
//|600 for compilations that target x86        |//
//|processors. This macro isn't defined for x64|//
//|or ARM compilation targets.                 |//
//|SOURCE[ M_IX86-url ]                        |//
#ifdef _M_IX86 ///////////////////////////////////

    #error NOT_SUPPORTING_X86

#endif ///////////////////////////////////////////


static void* 
JMIM_ASM_GetBaseAddr_PEB_x64()
{
    void* base_address = 0;
    unsigned long long var_out = 0;

    __asm__(
        " movq %%gs:0x60, %[sym_out]  ; \n\t"
        :[sym_out] "=r"  (var_out) //:OUTPUTS
    );

    //: printf("[var_out]:%d\n", (int)var_out);

    base_address=(void*)var_out;
    return( base_address );
}

TYPEDEF_HMODULE MACRO_WINAPI 
JMIM_GetModuleBaseAddress(
    TYPEDEF_LPCWSTR moduleName
){

    //:Void pointers:
    //:void* p;
    void* p1;
    void* p2;
    //:void* p3; 

    //:Using void* instead of the actual types,
    //:so that we don't need to include the
    //:headers for these window's structs.
    //:SOURCES:
    //: https://www.codemachine.com/downloads/win80/winnt.h
    //: https://msdn.microsoft.com/en-us/windows/desktop/aa813706
    //: https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data
    //////////////////////////////////////////////
	void* //:PEB*        
    pPeb = NULL;

	void* //:LIST_ENTRY* 
    pListEntry = NULL;

	void* //:LDR_DATA_TABLE_ENTRY* 
    pLdrDataTableEntry = NULL;
    //////////////////////////////////////////////

    //:pPeb = (PPEB)JMIM_ASM_GetBaseAddr_PEB_x64();
    pPeb = JMIM_ASM_GetBaseAddr_PEB_x64();

	if (pPeb == NULL){
		return NULL;
    };;


    //:pPeb->Ldr->InMemoryOrderModuleList.Flink
    //////////////////////////////////////////////
    unsigned long long 
    instructions_to_Flink[] ={ 

        //:____________ Ldr ___________________://
        'S' , 0x18  //: PTR
    ,   'L' ,  0    //: OBJ

        //:____________ InMemoryOrderModuleList://
    ,   'S' , 0x20  //: PTR
    ,   'L' ,  0    //: OBJ

        //:____________ Flink
    ,   'S' , 0x00  //: PTR
    ,   0x00, 0x00  

    };;
    void* 
    first_link_in_list=(
        VOID_Inst( pPeb, instructions_to_Flink )
    );;
    //////////////////////////////////////////////
        


    
    
    pLdrDataTableEntry=( first_link_in_list );
    pListEntry        =( first_link_in_list );

    int we_wrapped_around_stop_looping = 0;
    
	do
	{

        //:pLdrDataTableEntry->FullDllName.Buffer
        //////////////////////////////////////////
        unsigned long long 
        instructions_to_Buffer[]={
            'S', 0x48  //:FullDllName:PTR
        ,   'S', 0x08  //:Buffer     :PTR
        ,   'L',  0    //:Buffer     :OBJ
        ,   0x00,0x00
        };;
        unsigned short* 
        full_dll_name_buffer=VOID_Inst( 
            pLdrDataTableEntry
            ,
            instructions_to_Buffer
        );;
        //////////////////////////////////////////
        
         
		if(0 ==
            JMIM_lstrcmpiW(

                //:"unsigned short"=="wide char"
                full_dll_name_buffer
            , 
                moduleName
            )
        ){
    
            //:No clue why, but the base address
            //:of the DLL seems to be at:
            //:"pLdrDataTableEntry->Reserved2[0]"
            //:which is the member right before
            //:"pLdrDataTableEntry->DllBase"

            //: pLdrDataTableEntry -> Reserved2[0]
            //////////////////////////////////////

            unsigned long long
            instructions_to_dll_module[]={
                'S', 0x20 //:Reserved2[0]:PTR
            ,   'L',  0   //:Reserved2[0]:OBJ
            ,   0x00,0x00
            };;

            void* 
            dll_module=VOID_Inst(
                pLdrDataTableEntry
            ,   instructions_to_dll_module
            );;

            return( dll_module );

            //////////////////////////////////////
        };;



        //: pListEntry = pListEntry -> Flink
        p1 = (void*)pListEntry;
        p1 = VOID_Seek( p1, 0x00 ); //:Flink:PTR
        p1 = VOID_Load( p1       ); //:Flink:OBJ
        pListEntry =    p1;



        //:pLdrDataTableEntry=pListEntry->Flink
        p2 = p1;
        p2 = VOID_Seek( p2, 0x00 ); //:Flink:PTR
        p2 = VOID_Load( p2       ); //:Flink:OBJ
        pLdrDataTableEntry = p2;



        if( pListEntry == first_link_in_list ){
            we_wrapped_around_stop_looping = 1;
        }else{
            we_wrapped_around_stop_looping = 0;
        };;



	}while( 0 == we_wrapped_around_stop_looping );

	return NULL;
}

TYPEDEF_FARPROC __stdcall 
JMIM_GetExportAddress(
    TYPEDEF_HMODULE hMod
,   const char *lpProcName
){

    void* p;

    //: printf("[helllooooo]");

	char *pBaseAddress = (char *)hMod;

    //|  Can be found in winnt.h header file.  |//
    //|----------------------------------------|//



    //////////////////////////////////////////////
	//| IMAGE_DOS_HEADER                       |//
    //| *pDosHeader =(                         |//
    //|         (IMAGE_DOS_HEADER *)           |//
    //|          pBaseAddress                  |//
    //| );;                                    |//
                                            //||//
    void*                                   //||//
    pDosHeader = pBaseAddress;              //||//
                                            //||//
    //////////////////////////////////////////////


    #define U unsigned long long /////////////////

    //| IMAGE_NT_HEADERS                       |//
    //| *pNtHeaders == pBaseAddress            |//
    //|                +                       |//
    //|                pDosHeader -> e_lfanew  |//

    unsigned long long oper_pNtHeaders[]={
        'I' , (U)pDosHeader   //:Initial_Address
    ,   'S' , 0x3C            //:e_lfanew:PTR
    ,   'L' ,  4              //:e_lfanew:OBJ
    ,   'A' , (U)pBaseAddress //:IMAGE_NT_HEADERS
    ,   0x00,0x00
    };;
    void* pNtHeaders=VOID_Oper(
        oper_pNtHeaders
    );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////
    
    U oper_OptionalHeader[]={
        'I' , (U)pNtHeaders
    ,   'S' , 0x18 //:OptionalHeader:PTR
    ,   0x00, 0x00
    };;
    void* //:IMAGE_OPTIONAL_HEADER
    pOptionalHeader =VOID_Oper( 
        oper_OptionalHeader
    );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////

    //| IMAGE_DATA_DIRECTORY                   |//
    //|*pDataDirectory=(                       |//
    //|    &(pOptionalHeader -> DataDirectory[ |//
    //|         IMAGE_DIRECTORY_ENTRY_EXPORT   |//
    //|     ])                                 |//
    //| );;                                    |//

    U oper_pDataDirectory[]={
        'I', (U)pOptionalHeader
    ,   'S', 0x70 //:DataDirectory[ 0 ]

        //: I_D_E_E:IMAGE_DIRECTORY_ENTRY_EXPORT
        //: DataDirectory[ I_D_E_E ]
    ,   'S', MACRO_x_IMAGE_DIRECTORY_ENTRY_EXPORT
             *
             MACRO_sizeof_IMAGE_DATA_DIRECTORY

        //:Dont load address. Keep as pointer.
       
    ,   0x00,0x00
    };;
    void*
    pDataDirectory=VOID_Oper( 
        oper_pDataDirectory 
    );;

    #undef  U ////////////////////////////////////
    

    //:pDataDirectory -> VirtualAddress
    p = pDataDirectory;
    p = VOID_Seek( p, 0x00 );//:VirtualAddress:PTR
    p = VOID_Load( p       );//:VirtualAddress:OBJ
    void* virtual_address = p;



        #define U unsigned long long /////////////
        
        U base = (U)pBaseAddress;
        
        U inst_to_image_export_directory[]={
            'T',  4   //:truncate to 4 bytes
        ,   'A', base //:Add base addr
        ,  0x00, 0x00 //:END
        };;
        void* 
        added_addresses=VOID_Inst(
            virtual_address
        ,   inst_to_image_export_directory
        );;
        
        #undef  U ////////////////////////////////

        void* //:IMAGE_EXPORT_DIRECTORY*
        pExportDirectory = added_addresses;


      // VOID_PROS(
      //     pExportDirectory
      // , &(pExportDirectory->NumberOfFunctions)
      // ,  "pExportDirectory .NumberOfFunctions"
      // );;

    //: data_directory_size==
    //: pDataDirectory -> Size
    p = pDataDirectory;
    p = VOID_Seek( p, 0x04 ); //:Size:PTR
    p = VOID_Load( p       ); //:Size:OBJ
    size_t data_directory_size=(size_t)( p );
    


    //|----------------------------------------|//



    #define U unsigned long long /////////////////

    //| ppFunctions=(                          |//
    //|    pBaseAddress                        |//
    //|    +                                   |//
    //|    pExportDirectory->AddressOfFunctions|//
    //| );;                                    |//
    
//x   U inst_to_ppFunctions[]={
//x       'S' , 0x1C      //:AddressOfFunctions:PTR
//x   ,   'L' ,  0        //:AddressOfFunctions:OBJ
//x   ,   'T' ,  4        //:Truncate to 4 bytes
//x   ,   'A' ,  (U)pBaseAddress //:Add base address
//x   ,   0x00,0x00
//x   };;
//x   void**
//x   ppFunctions=VOID_Inst(
//x       pExportDirectory
//x   ,   inst_to_ppFunctions
//x   );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////
    
    //|                                        |//
    //|         pOrdinals                      |//
    //|         ===                            |//
    //|         pBaseAddress                   |//
    //|         +                              |//
    //|         pExportDirectory               |//
    //|         ->AddressOfNameOrdinals        |//
    
    unsigned long long oper_pOrdinals[]={
    /**/'I' , (U)pExportDirectory
    ,   'S' , 0x24 //:AddressOfNameOrdinals:PTR
    ,   'L' ,  4   //:AddressOfNameOrdinals:OBJ  
    ,   'A' , (U)pBaseAddress //:pOrdinals
    ,   0x00,0x00  //:END_OF_INSTRUCTIONS
    };;
    unsigned short //:WORD* 
    *pOrdinals=VOID_Oper( oper_pOrdinals );
    
    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////

    U oper_pNames[]={
    /**/'I' , (U)pExportDirectory
    ,   'S' , 0x20 //:AddressOfNames:PTR
    ,   'L' ,  4   //:AddressOfNames:OBJ  
    ,   'A' , (U)pBaseAddress //:pNames
    ,   0x00,0x00  //:END_OF_INSTRUCTIONS
    };;
    TYPEDEF_ULONG*
    pNames=VOID_Oper( oper_pNames );


    #undef  U ////////////////////////////////////


	void *pAddress = NULL;



	unsigned long i; //:DWORD

	if (((TYPEDEF_DWORD_PTR)lpProcName >> 16) == 0)
	{
        //:The pointer only contains 16 bits.
        //:Why does this require different code?
        //:Don't know. SEE: PS2_2.C11 for
        //:reference.
        
        printf("[ERROR:2019_11_28:09_32AM]\n");
        fflush(stdout); 
        exit(666);
	}
	else
	{
        //: printf("[BOT:SELECTED]");

        #define U unsigned long long /////////////

        //| pExportDirectory -> NumberOfNames  |//

        U oper_NumberOfNames[]={
            'I' , (U)pExportDirectory
        ,   'S' , 0x18 //:NumberOfNames:PTR
        ,   'L' ,  4   //:NumberOfNames:OBJ
        ,   0x00,0x00
        };; 
        unsigned long
        number_of_names=(
            (unsigned long)
            (unsigned long long)
            VOID_Oper( oper_NumberOfNames )
        );;

        // ------------------------------------ //

        //| pExportDirectory                   |//
        //| -> AddressOfFunctions              |//

        U oper_AddressOfFunctions[]={
            'I' , (U)pExportDirectory
        ,   'S' , 0x1C //:AddressOfFunctions:PTR
        ,   'L' ,  4   //:AddressOfFunctions:OBJ
        ,   0x00,0x00 
        };; 
        unsigned long
        address_of_functions=(
            (unsigned long)
            (unsigned long long)
            VOID_Oper( oper_AddressOfFunctions )
        );;

        #undef  U ////////////////////////////////


        unsigned long
        *absolute_address_of_functions=(
            (unsigned long *)
            (
                pBaseAddress
                +
                address_of_functions
            )
        );;

		for(
            i = 0
            ; 
            i < number_of_names
            ; 
            i++
        ){
			char *szName =(
                (  char*  )pBaseAddress 
              + (TYPEDEF_DWORD_PTR)pNames[i]
            );;

			if (strcmp(lpProcName, szName) == 0)
			{
				pAddress =(
                    (void*)( //:(TYPEDEF_FARPROC)
                        pBaseAddress
                        +
                        absolute_address_of_functions
                        [pOrdinals[i]]
                    )
                );;

				break;
			};;
		}
	}

	if(
        (char *)pAddress
        >= 
        (char *)pExportDirectory 

        && 

        (char *)pAddress 
        < 
        (char *)pExportDirectory 
              + data_directory_size
    ){
        //:Not going to re-write dead
        //:code path until error is hit.
       
        printf("[ERROR:2019_11_28:09_37AM]\n");
        fflush(stdout); 
        exit(666);

	}

    //:https://stackoverflow.com/questions/14134245/
    //:iso-c-void-and-function-pointers
	//:return pAddress;
    TYPEDEF_FARPROC ret;
    *(void **)(&ret) = pAddress;
    return( ret );
}




//|////////////////////////////////////////////|//
//|     -///-                        -///-     |//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __  __  __  __      __  _|//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |//
//|      \  /                        \  /      |//
//|       \/                          \/       |//
//+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +//
//|           /\                  /\           |//
//|          /  \                /  \          |//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|//
//|                                            |//
//|       ______________________________       |//
//|______/                              \______|//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) /////////////
/** ****************************************** |||
                                                   
    typedef struct _UNICODE_STRING {
      USHORT Length;
      USHORT MaximumLength;
      PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;



    typedef struct _LIST_ENTRY {
       struct _LIST_ENTRY *Flink;
       struct _LIST_ENTRY *Blink;
    } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;



    typedef struct _LDR_DATA_TABLE_ENTRY {
        PVOID Reserved1[2];
        LIST_ENTRY InMemoryOrderLinks;
        PVOID Reserved2[2];
        PVOID DllBase;
        PVOID EntryPoint;
        PVOID Reserved3;
        UNICODE_STRING FullDllName;
        BYTE Reserved4[8];
        PVOID Reserved5[3];
        union {
            ULONG CheckSum;
            PVOID Reserved6;
        };
        ULONG TimeDateStamp;
    } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;



    typedef struct _PEB {
        BYTE                          Reserved1[2];
        BYTE                          BeingDebugged;
        BYTE                          Reserved2[1];
        PVOID                         Reserved3[2];
        PPEB_LDR_DATA                 Ldr;
        PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
        BYTE                          Reserved4[104];
        PVOID                         Reserved5[52];
        PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
        BYTE                          Reserved6[128];
        PVOID                         Reserved7[1];
        ULONG                         SessionId;
    } PEB, *PPEB;


IMAGE_DATA_DIRECTORY

    typedef struct _IMAGE_DATA_DIRECTORY {
      DWORD VirtualAddress;
      DWORD Size;
    } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
                                                
||| ****************************************** **/ 
#endif ///////////////////////////////////////////
//|______                                ______|//
//|||||||\______________________________/|||||||//
//|                                            |//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __  __  __  __      __  _|//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |//
//|      \  /                        \  /      |//
//|       \/                          \/       |//
//+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +//
//|           /\                  /\           |//
//|          /  \                /  \          |//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|//
//|                                            |//
//|____________________________________________|//


//////////////////////////////////////////////////
#endif  //:VGAURD

//#FILE_REGION[ W32/DLLL/TARG/W10.X64 ]END####################//
//#FILE_REGION[ W32/DLLL/DLLL.H ]BEG##########################//

//[ DLLL: DLLL_Loader                          ]//
//+--------------------------------------------+//
//| PUBLIC:                                    |//
//| DLLL_FUNC                                  |//
//| DLLL_DLIB                                  |//
//| DLLL_WRAP_LoadLibraryA                     |//
//| DLLL_WRAP_GetProcAddress                   |//
//+--------------------------------------------+//





//: typedef 
//:     void (*DLLL_GENERIC_FUNCTION_POINTER)
//:     ( void ); //:<<"void" may need to be omitted.




#if( COMPILE_FOR_windows_10_64bit >= 1 )

    //: #include "./TARG/WIN10_x64._"

    //: #include "V:/VG/03/W32/DLLL/TARG/W10.X64"

    typedef
        TYPEDEF_HMODULE
        DLLL_DLIB;

    typedef 
        TYPEDEF_FARPROC 
        DLLL_FUNC;

#endif


static unsigned char
dll_init_already_called =((( 0 )));
void
DLLL_Init(){

    if( dll_init_already_called>0){ return; };

    TYPEDEF_HMODULE 
    hKernel32 =(
    /**/    JMIM_GetModuleBaseAddress(
    /**/        L"KERNEL32.DLL"
    /**/    )
    );;

    LoadLibraryAF 
    pLoadLibraryA =(
    /**/    (LoadLibraryAF)
    /**/    JMIM_GetExportAddress(
    /**/        hKernel32
    /**/    ,  "LoadLibraryA"
    /**/    )
    );;

    GetProcAddressF 
    pGetProcAddress =(
    /**/    (GetProcAddressF)
    /**/    JMIM_GetExportAddress(
    /**/        hKernel32
    /**/    ,   "GetProcAddress"
    /**/    )
    );;

    //:Assign the private function pointers
    //:defined in the specific operating system
    //:implementation files:
    dll_LoadLibraryA   =pLoadLibraryA  ;
    dll_GetProcAddress =pGetProcAddress;

    dll_init_already_called=( 1 );
    
}//[;]//

DLLL_DLIB
DLLL_WRAP_LoadLibraryA(
    const char* name
){
    if(NULL==dll_LoadLibraryA){
        printf("[FORGOT:DLLL_Init()?](LLA)\n");
        assert(NULL!=dll_LoadLibraryA);
    };;

    //:Implementation_Specific:
    return( dll_LoadLibraryA( name ) );
}//[;]//

DLLL_FUNC
DLLL_WRAP_GetProcAddress(
    DLLL_DLIB   dlib
,   const char* name
){
    if(NULL==dll_GetProcAddress){
        printf("[FORGOT:DLLL_Init()?](GPA)\n");
        assert(NULL!=dll_GetProcAddress);
    };;

    //:Implementation_Specific:
    DLLL_FUNC ret;
    ret = (DLLL_FUNC)
           dll_GetProcAddress(dlib, name);
    return(  ret  );
}//[;]//

//////////////////////////////////////////////////
//|  Let's be real... You are not going to     |//
//|  remember "DLLL_WRAP_*" Better just stick  |//
//|  with habits that are less complex.        |//
//+--------------------------------------------+//               
//|  Also,prioritize ease of use! Not speed    |//
//|  here.                                     |//
//////////////////////////////////////////////////

DLLL_DLIB
DLLL_LoadLibraryA(
    const char* name
){
    DLLL_Init(); //:LazyInit

    DLLL_DLIB ret=(
    /**/    DLLL_WRAP_LoadLibraryA(
    /**/        name
    /**/    )
    );;

    if(NULL==ret){
        printf(
            "[DLLL_LoadLibraryA:FAIL]:%s\n"
        ,   name
        );;
    };;

    return( ret );

}//[;]//

DLLL_FUNC
DLLL_GetProcAddress(
    DLLL_DLIB   dlib
,   const char* name
){
    DLLL_Init(); //:LazyInit

    DLLL_FUNC ret=(
    /**/    DLLL_WRAP_GetProcAddress(
    /**/        dlib
    /**/    ,   name
    /**/    )
    );;

    #define MACRO_DLLL_H_fail_fast 1 ///////////////////////////
    if(NULL==ret){
        printf(
            "((([FILE:DLLL.H][DLLL_GetProcAddress:FAIL]))):%s\n"
        ,   name
        );;

        fflush(stdout);

        if( MACRO_DLLL_H_fail_fast != 0 ){
            exit(666);
        };;
    };;
    #undef  MACRO_DLLL_H_fail_fast /////////////////////////////


    return( ret );

}//[;]//

//#FILE_REGION[ W32/DLLL/DLLL.H ]END##########################//

#define F01_BASH_CONCATTED


//#FILE_REGION[ F.01 ]BEG#####################################//

//# DOTADIW:DLL_FUNC_LIST -----------------------------------]//

//[ The function you want, and the DLL file it comes from. --]//

//# NOTE: Using different cases like "User32 & usEr32" ------#//
//# Will screw up your DLL caching code!               ------#//
//! NODOC: Missing MSDN documentation. --------------------- !//

#ifndef F01_BASH_CONCATTED

F02_F01_MACRO( RegisterClassExW , user32  )  //[ 01 ]//
F02_F01_MACRO( CreateWindowExW  , user32  )  //[ 02 ]//
F02_F01_MACRO( DestroyWindow    , user32  )  //[ 03 ]//
F02_F01_MACRO( PostQuitMessage  , user32  )  //[ 04 ]//
F02_F01_MACRO( DefWindowProcW   , user32  )  //[ 05 ]//
F02_F01_MACRO( LoadIconA        , user32  )  //[ 06 ]//
F02_F01_MACRO( LoadCursorA      , user32  )  //[ 07 ]//
F02_F01_MACRO( GetWindowDC      , user32  )  //[ 08 ]//
F02_F01_MACRO( ChoosePixelFormat, gdi32   )  //[ 09 ]//
F02_F01_MACRO( SetPixelFormat   , gdi32   )  //[ 10 ]//
F02_F01_MACRO( GetModuleHandleW , kernel32)  //[ 11 ]//
F02_F01_MACRO( GetDesktopWindow , user32  )  //[ 12 ]//
F02_F01_MACRO( TranslateMessage , user32  )  //[ 13 ]//
F02_F01_MACRO( DispatchMessageW , user32  )  //[ 14 ]//
F02_F01_MACRO( PeekMessageW     , user32  )  //[ 15 ]//
F02_F01_MACRO( ShowWindow       , user32  )  //[ 16 ]//
F02_F01_MACRO( UpdateWindow     , user32  )  //[ 17 ]//
F02_F01_MACRO( SetFocus         , user32  )  //[ 18 ]//
F02_F01_MACRO( Sleep            , kernel32)  //[ 19 ]//
F02_F01_MACRO( GetProcessHeap   , kernel32)  //[ 20 ]//
F02_F01_MACRO( CreateThread     , kernel32)  //[ 21 ]//
F02_F01_MACRO( HeapAlloc        , kernel32)  //[ 22 ]//

//:Vulkan_Functions:
////////////////////////////////////////////////////////////////

//:MAKES: F02_vkEnumerateInstanceExtensionProperties
F02_F01_MACRO(  
              vkEnumerateInstanceExtensionProperties 
,   vulkan-1 
)

//:MAKES: F02_vkCreateInstance
F02_F01_MACRO( 
              vkCreateInstance 
,   vulkan-1 
)

//:MAKES: F02_vkEnumerateInstanceLayerProperties
F02_F01_MACRO(
              vkEnumerateInstanceLayerProperties
,   vulkan-1
)

//:MAKES: F02_vkGetInstanceProcAddr
F02_F01_MACRO(
              vkGetInstanceProcAddr
,   vulkan-1
)

//:MAKES: F02_vkEnumeratePhysicalDevices
F02_F01_MACRO(
              vkEnumeratePhysicalDevices
,   vulkan-1
)

//:MAKES: F02_vkGetPhysicalDeviceFeatures
F02_F01_MACRO(
              vkGetPhysicalDeviceFeatures
,   vulkan-1
)

//:MAKES: F02_vkGetPhysicalDeviceProperties
F02_F01_MACRO(
              vkGetPhysicalDeviceProperties
,   vulkan-1
)

//:MAKES: F02_vkGetPhysicalDeviceQueueFamilyProperties
F02_F01_MACRO(
              vkGetPhysicalDeviceQueueFamilyProperties
,   vulkan-1
)

//:MAKES: F02_vkCreateDevice
F02_F01_MACRO(
              vkCreateDevice
,   vulkan-1
)

//:MAKES:  F02_vkGetDeviceQueue
F02_F01_MACRO( vkGetDeviceQueue , vulkan-1 )

////////////////////////////////////////////////////////////////


//!( RegisterWindow   , user32  )  YOU_MADE_THIS_ONE_UP      !//

//[¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯]//
//[__________________________________________________________]//

#else //: F01_BASH_CONCATTED

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F01_Init(){
        printf("[BEG:F01:Init]\n");

        printf("[F01:Doing_Nothing:(DOTADIW:DLL_FUNC_LIST)]\n");

        printf("[END:F03:Init]\n");
        return( 0 );
    }//[;]//
    int F01_Main(){
        F01_Init();

        //:Nothing to do here.

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

#endif //: F01_BASH_CONCATTED

//#FILE_REGION[ F.01 ]END#####################################//


#undef  F01_BASH_CONCATTED


//#FILE_REGION[ F.02 ]BEG#####################################//

//[ DOTADIW: DLL_FUNC_LOAD ----------------------------------]//
//[          Load Function Pointers From DLL FIles.          ]//
//[         (DLL files or linux equivalent)                  ]//
//[                                                          ]//
//[ Example Function Pointer Created By This File:           ]//
//[                                                          ]//
//[         F02_VOF F02_DestroyWindow =<SomeDLLAddress>      ]//

#include <string.h> //: strcmp

//:Generic_Function_Pointer
typedef void (*F02_VOF)(void);


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

void F02_Halt( const char* msg ){ 
    printf( "[F02_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//

int F02_Same( const char* str_01, const char* str_02 ){
    return( 0 == strcmp( str_01, str_02 ) );
}//[;]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

    

    //[ Declare void pointers for every single DLL function  ]//
    //[ you want to call. They will be wrapped by functions  ]//
    //[ in a later file. Or called by casting to correct     ]//
    //[ signature on the fly.                                ]//
    #define F02_F01_MACRO(f,d) F02_VOF  F02_  ##  f ;
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    //:Create dummy F01_ functions to let you know
    //:you are wrong and should be calling F02_ functions.
    #define F02_F01_MACRO(f,d) F02_VOF  F01_  ##  f ;
        #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

////////////////////////////////////////////////////////////////
//:Positive: The index of the loaded dll address in array.
//:Negative: The index to insert/cache next dll.
//:DO NOT USE TO PEEK! When returning negative, expects you
//:to add to the cache array.
#define MACRO_STR const char * /////////////////////////////////
static DLLL_DLIB F02_Cache_ADDR[1+10]={0}; //:DLL_CACHE.address
static MACRO_STR F02_Cache_NAME[1+10]={0}; //:DLL_CACHE.name
int F02_GetCacheIndex( const char* dlib_name ){

    int i = 0;while(1){ i++;
        
        assert( 0 != i ); //:Invalid_Cache_Index
        assert( i <= 10); //:Out_Of_Pre_Allocated_Slots

        if( NULL ==    F02_Cache_ADDR[i]){ return(  0-i  ); }
        if( F02_Same(  F02_Cache_NAME[i], dlib_name  )   ){
            return( i );
        };;

    };;

    assert( 0 ); //:CRASH! Should have returned already!
    return( 0 ); //:Return invalid index.

}//[;]//
#undef MACRO_STR ///////////////////////////////////////////////

int F02_GF_total_number_of_functions_fetched=0;
static F02_VOF F02_GF( //:GF:Get_Function(Pointer)
/**/    const char* func_name //:EX:"ShowWindow"
/**/,   const char* dlib_name //:EX:"user32.dll" | "user32"
){
    DLLL_DLIB  dlib_addr; //:DLL Module   Address
    DLLL_FUNC  func_addr; //:DLL Function Address
    ////////////////////////////////////////////////////////////
    //:GET DLL Module:
    ////////////////////////////////////////////////////////////
    int cac_dex = F02_GetCacheIndex( dlib_name );
    if( cac_dex > 0 ){

        dlib_addr = F02_Cache_ADDR[ cac_dex ];

    }else
    if( cac_dex < 0 ){

        dlib_addr = DLLL_LoadLibraryA(
        dlib_name );;

        F02_Cache_ADDR[ 0-cac_dex ] = dlib_addr;
        F02_Cache_NAME[ 0-cac_dex ] = dlib_name;

    }else{
        F02_Halt( "[EUBOC:ZERO_IS_INVALID_CACHE_INDEX]" );
    };;
    ////////////////////////////////////////////////////////////
    //:PULL Function From DLL:
    ////////////////////////////////////////////////////////////

        func_addr = DLLL_GetProcAddress( dlib_addr, func_name );

    ////////////////////////////////////////////////////////////

    F02_GF_total_number_of_functions_fetched++;
    return( (F02_VOF)func_addr );

}//[;]//

void F02_WRONGNAME(void){

    printf("[Raw_Function_Pointers_Are_Named]\n");
    printf("[After_The_File_They_Are_Created]\n");
    printf("[in.(F.02)not_the_file_the_func_]\n");
    printf("[name_list_lives_in(F.01).------]\n");
    printf("[TL;DR::::::::::::::::::::::::::]\n");
    printf("[   YES: F02_SomeRawDLLFunction ]\n");
    printf("[    NO: F01_SomeRawDLLFunction ]\n");

    fflush(stdout);
    exit(666);

}//[;]//

//:Load Function Pointers: EX: F02_ShowWindow
int F02_Init(){
    printf("[BEG:F02:Init]\n");

    //:Call previous "init" before doing your work:
    F01_Init();

    #define F02_F01_MACRO(f,d) F02_ ## f = F02_GF(#f,#d);
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    //:In case you think the functions start with "F01_"
    #define F02_F01_MACRO(f,d) F01_ ## f = &(F02_WRONGNAME);
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

   // if( F02_GF_total_number_of_functions_fetched != 23 ){
   //     F02_Halt("[Expected_This_Many_Fetched_Funcs]");
   // };;

    printf("[F02:NUM_FUNCS_FETCHED]:%d\n",
        F02_GF_total_number_of_functions_fetched );;
    fflush(stdout);



    printf("[END:F02:Init]\n");
    return( 0 );

}//[;]//
int F02_Main(){

    printf("[F02_Init:Will_Fetch_Function_Pointers]\n");
    int ret = F02_Init();

    return( ret );
}//[;]//



//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//|////////////////////////////////////////////|////[ --64-- ]//
//|     -///-                        -///-     |////[ --64-- ]//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ --64-- ]//
//|_  __      __  __  __  __  __  __      __  _|////[ --64-- ]//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ --64-- ]//
//|      \  /                        \  /      |////[ --64-- ]//
//|       \/                          \/       |////[ --64-- ]//
//+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ --64-- ]//
//|           /\                  /\           |////[ --64-- ]//
//|          /  \                /  \          |////[ --64-- ]//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ --64-- ]//
//|                                            |////[ --64-- ]//
//|       ______________________________       |////[ --64-- ]//
//|______/                              \______|////[ --64-- ]//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) /////////////
/** ****************************************** |||
                                                   
//+----------------------------------------------------------+//
//[ Because macros generate these functions, I thought it    ]//
//[ a good idea to write them down here in a comment.        ]//
//[ If I don't, "CTRL+F" will not save the poor soul         ]//
//[ looking for the declaration of these functions.          ]//
//[ (They are declared in this file (F.02) with macros)      ]//
//[                                                          ]//
//|     void*( *F02_RegisterClassExW )( void );              |//
//|     void*( *F02_CreateWindowExW  )( void );              |//
//|     void*( *F02_DestroyWindow    )( void );              |//
//|     void*( *F02_PostQuitMessage  )( void );              |//
//|     void*( *F02_DefWindowProcW   )( void );              |//
//|     void*( *F02_LoadIconA        )( void );              |//
//|     void*( *F02_LoadCursorA      )( void );              |//
//|     void*( *F02_GetWindowDC      )( void );              |//
//|     void*( *F02_ChoosePixelFormat)( void );              |//
//|     void*( *F02_SetPixelFormat   )( void );              |//
//|     void*( *F02_GetModuleHandleW )( void );              |//
//|     void*( *F02_GetDesktopWindow )( void );              |//
//|     void*( *F02_TranslateMessage )( void );              |//
//|     void*( *F02_DispatchMessageW )( void );              |//
//|     void*( *F02_PeekMessageW     )( void );              |//
//|     void*( *F02_ShowWindow       )( void );              |//
//|     void*( *F02_UpdateWindow     )( void );              |//
//|     void*( *F02_SetFocus         )( void );              |//
//|     void*( *F02_Sleep            )( void );              |//
//|     void*( *F02_GetProcessHeap   )( void );              |//
//|     void*( *F02_CreateThread     )( void );              |//
//|     void*( *F02_HeapAlloc        )( void );              |//
//+----------------------------------------------------------+//
                                                   
||| ****************************************** **/ 
#endif ///////////////////////////////////////////
//|______                                ______|////[ --64-- ]//
//|||||||\______________________________/|||||||////[ --64-- ]//
//|                                            |////[ --64-- ]//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ --64-- ]//
//|_  __      __  __  __  __  __  __      __  _|////[ --64-- ]//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ --64-- ]//
//|      \  /                        \  /      |////[ --64-- ]//
//|       \/                          \/       |////[ --64-- ]//
//+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ --64-- ]//
//|           /\                  /\           |////[ --64-- ]//
//|          /  \                /  \          |////[ --64-- ]//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ --64-- ]//
//|                                            |////[ --64-- ]//
//|____________________________________________|////[ --64-- ]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//



//#FILE_REGION[ F.02 ]END#####################################//
//#FILE_REGION[ F.03 ]BEG#####################################//

//[F02: DOTADIW: DLL_CALL_CAST (HACK) -----------------------]//
//[ Quick_Hack_For_Calling_DLL_Func_Pointers  ---------------]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[ Making typedefs and wrappers for function signatures can ]//
//[ get a bit verbose and annoying. When you feel like       ]//
//[ skipping that effort, you can use these hacks depending  ]//
//[ on the number of parameters the function has.            ]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

#define  V void* ///////////////////////////////////////////////
#define  a void* ///////////////////////////////////////////////
#define  b void* ///////////////////////////////////////////////
#define  c void* ///////////////////////////////////////////////
#define  d void* ///////////////////////////////////////////////
#define  e void* ///////////////////////////////////////////////

typedef  V (* F03_00)( void );
typedef  V (* F03_01)( a                                      );
typedef  V (* F03_02)( a,a                                    );
typedef  V (* F03_03)( a,a,a                                  );
typedef  V (* F03_04)( a,a,a,a                                );
typedef  V (* F03_05)( a,a,a,a,b                              );
typedef  V (* F03_06)( a,a,a,a,b,b                            );
typedef  V (* F03_07)( a,a,a,a,b,b,b                          );
typedef  V (* F03_08)( a,a,a,a,b,b,b,b                        );
typedef  V (* F03_09)( a,a,a,a,b,b,b,b,c                      );
typedef  V (* F03_10)( a,a,a,a,b,b,b,b,c,c                    );
typedef  V (* F03_11)( a,a,a,a,b,b,b,b,c,c,c                  );
typedef  V (* F03_12)( a,a,a,a,b,b,b,b,c,c,c,c                );
typedef  V (* F03_13)( a,a,a,a,b,b,b,b,c,c,c,c,d              );
typedef  V (* F03_14)( a,a,a,a,b,b,b,b,c,c,c,c,d,d            );
typedef  V (* F03_15)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d          );
typedef  V (* F03_16)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d        );
typedef  V (* F03_17)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e      );
typedef  V (* F03_18)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e    );
typedef  V (* F03_19)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e  );
typedef  V (* F03_20)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e,e);

#undef   V /////////////////////////////////////////////////////
#undef   a /////////////////////////////////////////////////////
#undef   b /////////////////////////////////////////////////////
#undef   c /////////////////////////////////////////////////////
#undef   d /////////////////////////////////////////////////////
#undef   e /////////////////////////////////////////////////////

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F03_Init(){
        printf("[BEG:F03:Init]\n");

        //:No action besides calling down the chain.

        int ret = F02_Init();

        printf("[END:F03:Init]\n");
        return( ret );
    }//[;]//
    int F03_Main(){
        F03_Init();

        printf("[F03:DLL_CALL_CAST. Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.03 ]END#####################################//
//#FILE_REGION[ F.04 ]BEG#####################################//

//: F.04: DLL_STRUCTS.
//:       STRUCTS needed to create wrappers for DLL funcs.

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F04_Init(){
        printf("[BEG:F04:Init]\n");

        //:No action besides calling down the chain.

        int ret = F03_Init();

        printf("[END:F04:Init]\n");
        return( ret );
    }//[;]//
    int F04_Main(){
        F04_Init();

        printf("[F04:DLL_STRUCTS. Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.04 ]END#####################################//
//#FILE_REGION[ F.05 ]BEG#####################################//

//: F.05: DLL_TYPEDEFS (Should all be function pointer typedefs)
//:       TYPDEFS to create proper wrappers for DLL FUNCS:


//:LSR:LPTHREAD_START_ROUTINE:
typedef 
    unsigned long (__stdcall *F05_LSR ) (  
        void* lpThreadParameter  
    );
//[typedef]//
 





//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F05_Init(){    
        printf("[BEG:F05:Init]\n");

        int ret = F04_Init();

        printf("[END:F05:Init]\n");
        return( ret );
    }//[;]//
    int F05_Main(){
        F05_Init();

        printf("[F05:DLL_TYPEDEFS. Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.05 ]END#####################################//

#define F06_BASH_CONCATTED


//#FILE_REGION[ F.06 ]BEG#####################################//

//[ DOTADIW : DLL_PARG_LIST  --------------------------------]//
//[           PARG: PARAMETER/ARGUMENT                       ]//
//[           Param Lists Of Funcs Fetched From DLL(s)       ]//
//[          (Or linux equivalent of DLL files)              ]//

#ifndef F06_BASH_CONCATTED

#if( F08_F06_MACRO_CreateWindowExW > 0 ) ///////////////////////

    #if( F07_F06_MACRO_actual_argument_list > 0 )

        #define MACRO_L     
        #define MACRO_S_PTR 
        #define MACRO_I     
        #define MACRO_V_PTR 

    #elif( F07_F06_MACRO_formal_param_list > 0 )

        #define MACRO_L       unsigned long
        #define MACRO_S_PTR   const unsigned short *
        #define MACRO_I       int
        #define MACRO_V_PTR   void *

    #else

        #error ARE_ARGUMENTS_ACTUAL_OR_FORMAL

    #endif
/**/            MACRO_L      dwExStyle    /**DWORD     01 **/
,               MACRO_S_PTR  lpClassName  /**LPCWSTR   02 **/
,               MACRO_S_PTR  pWindowName  /**LPCWSTR   03 **/
,               MACRO_L      dwStyle      /**DWORD     04 **/
,               MACRO_I      X            /**          05 **/
,               MACRO_I      Y            /**          06 **/
,               MACRO_I      nWidth       /**          07 **/
,               MACRO_I      nHeight      /**          08 **/
,               MACRO_V_PTR  hWndParent   /**HWND      09 **/
,               MACRO_V_PTR  hMenu        /**HMENU     10 **/
,               MACRO_V_PTR  hInstance    /**HINSTANCE 11 **/
,               MACRO_V_PTR  lpParam      /**HINSTANCE 12 **/

        #undef  MACRO_L     
        #undef  MACRO_S_PTR 
        #undef  MACRO_I     
        #undef  MACRO_V_PTR 

#elif( F08_F06_MACRO_CreateThread > 0 ) ////////////////////////

    #if( F07_F06_MACRO_actual_argument_list > 0 )

        #define macro_LPSECURITY_ATTRIBUTES
        #define macro_SIZE_T
        #define macro_LPTHREAD_START_ROUTINE
        #define macro_HINSTANCE
        #define macro_DWORD
        #define macro_LPDWORD

    #elif( F07_F06_MACRO_formal_param_list > 0 )

        #define macro_LPSECURITY_ATTRIBUTES    void*
        #define macro_SIZE_T     unsigned long long  //:64bits                 
        #define macro_LPTHREAD_START_ROUTINE   F05_LSR
        #define macro_HINSTANCE                void*
        #define macro_DWORD           unsigned long
        #define macro_LPDWORD         unsigned long*         

    #else

        #error ARE_ARGUMENTS_ACTUAL_OR_FORMAL ? CREATE_THREAD

    #endif

    /**/macro_LPSECURITY_ATTRIBUTES       //[DT]//
        lpThreadAttributes                //[DT]//
                                          //[DT]//
    ,   macro_SIZE_T                      //[DT]//
        dwStackSize                       //[DT]//
                                          //[DT]//
    ,   macro_LPTHREAD_START_ROUTINE      //[DT]//
        lpStartAddress                    //[DT]//
                                          //[DT]//
    ,   macro_HINSTANCE                   //[DT]//
        lpParameter                       //[DT]//
                                          //[DT]//
    ,   macro_DWORD                       //[DT]//
        dwCreationFlags                   //[DT]//
                                          //[DT]//
    ,   macro_LPDWORD                     //[DT]//
        lpThreadId                        //[DT]//

        #undef  macro_LPSECURITY_ATTRIBUTES
        #undef  macro_SIZE_T
        #undef  macro_LPTHREAD_START_ROUTINE
        #undef  macro_HINSTANCE
        #undef  macro_DWORD
        #undef  macro_LPDWORD

#else  ////////////////////////////////////////////////////////

    #error NO_SELECTION_MADE_USING_MACRO_DECLARATION

#endif

#else  //: F06_BASH_CONCATTED 

    //:Non Macro Stuff:
    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

    int F06_Init(){
        printf("[BEG:F06:Init]\n");

        //:No action besides calling down the chain.

        int ret = F05_Init();

        printf("[END:F06:Init]\n");
        return( ret );
    }//[;]//
    int F06_Main(){
        F06_Init();

        printf("[F06:Is_A_Macro_File.Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

#endif //: F06_BASH_CONCATTED 


//#FILE_REGION[ F.06 ]END#####################################//


#undef  F06_BASH_CONCATTED



#define F07_BASH_CONCATTED


//#FILE_REGION[ F.07 ]BEG#####################################//

//[ DOTADIW : DLL_WRAP_BOIL ---------------------------------]//
//[           DLL function call WRAPper                      ]//
//[           BOILerplate template.                          ]//
//[                                                          ]//
//[                                                          ]//
//[ Further abstracts use of parameter lists file so that    ]//
//[ we don't have to write function wrapper boilerplate      ]//
//[ every time we wrap a function.                           ]//
//[ All we have done here is replaced lines that have the    ]//
//[ comment #Example# with a macro for the function names.   ]//

//|F08_F07_MACRO_wrapper: Wrapping function with type safety.|//
//|F08_F07_MACRO_wrapped: Uncasted func ptr pulled from dll. |//

#ifndef F07_BASH_CONCATTED 

    //:Can we abstract this further?
    F08_F07_MACRO_RETURNTYPE
    
    //:
    F08_F07_MACRO_wrapper //:<--#Example#: F07_CreateWindowExW
    (

                ////////////////////////////////////////////////
                #define F07_F06_MACRO_formal_param_list 1
                
                #include "./F.06" //:DOTADIW:DLL_PARG_LIST
                
                #undef  F07_F06_MACRO_formal_param_list
                ////////////////////////////////////////////////

    ){

        typedef  
            F08_F07_MACRO_RETURNTYPE
            (*pfn )(            
                 
                ////////////////////////////////////////////////
                #define F07_F06_MACRO_formal_param_list 1

                #include "./F.06"  //:DOTADIW:DLL_PARG_LIST

                #undef  F07_F06_MACRO_formal_param_list
                ////////////////////////////////////////////////
     
            );

        pfn fun =(pfn) 
        F08_F07_MACRO_wrapped; //:<--#EX#:F01_CreateWindowExW

        F08_F07_MACRO_RETURNTYPE 
        ret=( fun(

                ////////////////////////////////////////////////
                #define F07_F06_MACRO_actual_argument_list 1
                
                #include "./F.06" //:DOTADIW:DLL_PARG_LIST
                
                #undef  F07_F06_MACRO_actual_argument_list
                ////////////////////////////////////////////////

        ));

        return(  ret  );

    }//[F08_F07_MACRO_wrapper]//

#else

    //:Non Macro Stuff:
    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

    int F07_Init(){
        
        //:No action besides calling down the chain.

        int ret = F06_Init();

        return( ret );
    }//[;]//
    int F07_Main(){
        F07_Init();

        printf("[F07:Is_A_Macro_File.Nothing_To_Do_Here]\n");

        return( 0 );
    }//[;]//

    //:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

#endif

//#FILE_REGION[ F.07 ]END#####################################//


#undef  F07_BASH_CONCATTED


//#FILE_REGION[ F.08 ]BEG#####################################//

//[ DOTADIW: DLL_WRAP_MAKE ----------------------- --------- ]//
//[ Make wrapper functions for DLL func pointers.  --------- ]//

//:We could abstract this further, by creating a list
//:of function names that have had typedefs created for them.

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//:MAKES: F08_CreateWindowExW by wrapping F02_CreateWindowExW:
#define F08_F07_MACRO_RETURNTYPE void*  ////////////////////////
#define F08_F06_MACRO_CreateWindowExW 1  ///////////////////////

    #define F08_F07_MACRO_wrapper   F08_CreateWindowExW
    #define F08_F07_MACRO_wrapped   F02_CreateWindowExW

        #include "./F.07" //:<<--#DOTADIW:DLL_WRAP_BOIL  
                                 //(wrapper_func_template)
    #undef  F08_F07_MACRO_wrapper
    #undef  F08_F07_MACRO_wrapped

#undef  F08_F07_MACRO_RETURNTYPE  //////////////////////////////
#undef  F08_F06_MACRO_CreateWindowExW ////////////////////////// 

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//:MAKES: F08_CreateThread by wrapping F02_CreateThread:
#define F08_F07_MACRO_RETURNTYPE void*  ////////////////////////
#define F08_F06_MACRO_CreateThread   1  ////////////////////////

    #define F08_F07_MACRO_wrapper   F08_CreateThread
    #define F08_F07_MACRO_wrapped   F02_CreateThread

        #include "./F.07" //:<<--#DOTADIW:DLL_WRAP_BOIL 
                                 //(wrapper_func_template)
    #undef  F08_F07_MACRO_wrapper
    #undef  F08_F07_MACRO_wrapped

#undef  F08_F07_MACRO_RETURNTYPE        ////////////////////////
#undef  F08_F06_MACRO_CreateThread      //////////////////////// 

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


//:Non Macro Stuff:
//:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

int F08_Init(){
    
    //:No action besides calling down the chain.

    int ret = F07_Init();

    return( ret );
}//[;]//
int F08_Main(){
    F08_Init();

    printf("[F08:Is_A_Macro_File.Nothing_To_Do_Here]\n");

    return( 0 );
}//[;]//

//:NMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNMNM://

//#FILE_REGION[ F.08 ]END#####################################//
//#FILE_REGION[ F.09 ]BEG#####################################//

//[ DOTADIW: MAKE_A_WINDOW                                   ]//

//[V:Variables. #VARS_TOP_OF_FILE_BIG_PICTURE#               ]//
//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//:Initial_Window_Size_And_Position:
////////////////////////////////////////////
int f09_X    = 22  ; /**  GLEB_SWIN.X    **/
int f09_Y    = 22  ; /**  GLEB_SWIN.Y    **/
int f09_WID  = 1024; /**  GLEB_SWIN.WID  **/
int f09_HIG  = 512 ; /**  GLEB_SWIN.HIG  **/
////////////////////////////////////////////

    signed char f09_window_created     = 0;
    signed char f09_window_just_closed = 0;
      
    void* f09_handle_to_window      = NULL; //:HWND
    void* f09_window_device_context = NULL; //:HDC
    void* f09_handle_to_exe         = NULL; //:HINSTANCE
    
    //:Forward declare so we can keep variables
    //:at top of file.
    struct F09_STRUCT_PIXELFORMATDESCRIPTOR;
    struct F09_STRUCT_PIXELFORMATDESCRIPTOR
                f09_pixel_format_descriptor;
    signed char f09_InitPixelFormatDescriptor_DONE=0;

//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//[H:Halt Always first function in file._____________________]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
static void 
f09_Halt( const char*     msg ){ 
    printf( "[f09_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

//:PUBLIC GETTERS:
////////////////////////////////////////////////////////////////
void*
F09_GetHWND( void ){
    if(NULL==f09_handle_to_window){
        f09_Halt("[WindowHandleIsNull]");
    };;
    return( f09_handle_to_window );
}//[;]//

void*
F09_GetHINSTANCE( void ){
    if(NULL==f09_handle_to_exe){
        f09_Halt("[ExeHandleIsNull]");
    };;
    return( f09_handle_to_exe );
}//[;]//


////////////////////////////////////////////////////////////////

//[SI:Structs_And_Initializers (Initializers For The Structs)]//
//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//

typedef void (*F09_GENERIC_FUNC)(void);


typedef 
    __int64
    (__stdcall *F09_WNDPROC)(
        void*             //: HWND
    ,   unsigned   int    //: UINT
    ,   unsigned __int64  //: WPARAM
    ,            __int64  //: LPARAM
    );

// ---------------------------------------------------------- //

struct F09_STRUCT_WNDCLASSEXW {
                unsigned int   cbSize       ;
                unsigned int   style        ;
                 F09_WNDPROC   lpfnWndProc  ;
                         int   cbClsExtra   ;
                         int   cbWndExtra   ;
                        void*  hInstance    ;
                        void*  hIcon        ;
                        void*  hCursor      ;
                        void*  hbrBackground;
        const unsigned short*  lpszMenuName ;
        const unsigned short*  lpszClassName;
                        void*  hIconSm      ;
};

// ---------------------------------------------------------- //

struct F09_STRUCT_POINT{

    long x;
    long y;

};//[struct]//

//:winuser.h
struct F09_STRUCT_MSG {

    void*                    hwnd    ;  //: HWND    ://
    unsigned   int           message ;  //: UINT    ://
    unsigned __int64         wParam  ;  //: WPARAM  ://

             __int64         lParam  ;  //: LPARAM  ://
    unsigned    long         time    ;  //: DWORD   ://

    struct F09_STRUCT_POINT  pt      ;  //: POINT   ://
    unsigned    long         lPrivate;  //: DWORD   ://

};//[struct]//



//[  docs.microsoft.com/en-us/windows/win32/api/wingdi       ]//
//[  /ns-wingdi-pixelformatdescriptor                        ]//
#define W unsigned short /** WORD **/  /////////////////////////
#define D unsigned long  /**DWORD **/  /////////////////////////
#define B unsigned char  /** BYTE **/  /////////////////////////
struct F09_STRUCT_PIXELFORMATDESCRIPTOR {
    W  nSize;   
    W  nVersion;

    D dwFlags;

    B  iPixelType;
    B  cColorBits;
    B  cRedBits;
    B  cRedShift;
    B  cGreenBits;
    B  cGreenShift;
    B  cBlueBits;
    B  cBlueShift;
    B  cAlphaBits;
    B  cAlphaShift;
    B  cAccumBits;
    B  cAccumRedBits;
    B  cAccumGreenBits;
    B  cAccumBlueBits;
    B  cAccumAlphaBits;
    B  cDepthBits;
    B  cStencilBits;
    B  cAuxBuffers;
    B  iLayerType;
    B  bReserved;

    D dwLayerMask;
    D dwVisibleMask;
    D dwDamageMask;

};//[struct]//
#undef  W ////////////// /** WORD **/  /////////////////////////
#undef  D ////////////// /**DWORD **/  /////////////////////////
#undef  B ////////////// /** BYTE **/  /////////////////////////
void                                       
f09_InitPixelFormatDescriptor(       
    void                                   
){          
    if( f09_InitPixelFormatDescriptor_DONE != 0 ){
        f09_Halt("[AlreadyInited:PFD]");
    };;
                                                                           
    struct F09_STRUCT_PIXELFORMATDESCRIPTOR                  
    p ={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct F09_STRUCT_PIXELFORMATDESCRIPTOR ), //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;     

    //:Quick smoke test in case I missed a param
    //:and my data is mis-aligned.
    if( 32 != p.cColorBits   ){
        f09_Halt( "[32!=p.cColorBits]" );
    };;
    if( 24 != p.cDepthBits  ){
        printf("[p.cDepthBits]:%d\n" , p.cDepthBits );
        f09_Halt( "[24!=p.cDepthBits]");
    };;
    if(  8 != p.cStencilBits ){
       f09_Halt( "[08!=p.cStencilBits]");
    };;
                                           
    //[ Copy Over To Global Variable ]// 
    f09_pixel_format_descriptor =( p );
    f09_InitPixelFormatDescriptor_DONE = 1;
                                           
} //[InitPixelFormatDescriptor]//          

//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//


// ---------------------------------------------------------- //

////////////////////////////////////////////////////////////////             

typedef const unsigned short *  TYPEDEF_LPCWSTR;


char*
F09_MakeIntResourceA( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
}//[;]//

////////////////////////////////////////////////////////////////

//:WinMsgHanWndPoc:WINDOW_MESSAGE_HANDLER_WNDPROC
__stdcall
__int64 //:LRESULT
F09_WinMsgHanWndPoc(
/**/           void*    Hw     //:HWND
,   unsigned   int      Msg    //:...?...
,   unsigned __int64    wParam //:WPARAM
,            __int64    lParam //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[GLEB_SWIN:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 ((F03_01)(F02_DestroyWindow))(Hw);

            if(0==ok){f09_Halt("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            ((F03_01)(F02_DestroyWindow))(Hw);

        if(0==ok){f09_Halt("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((F03_01)F02_PostQuitMessage)(0);

    case 0x000F /**wm_paint**/:
        //:[TODO]:Something to pace the updating
        //:of graphics.


        //+ DELETE THIS BLOCK +//
        //- //:I dont think this is needed:         -//
        //- //: You may use the same HDC in both    -//
        //- //: threads, but not at the same time.  -//
        //- //: SEE[ gl-hdc-thread-quote ]          -//
        //- if(GLEB_SWIN.render_tick_function_has){ -//
        //-    GLEB_SWIN.render_tick_function();    -//
        //- };;                                     -//

        //: This might be better done setting a flag
        //: than using a callback. In order to prevent
        //: drawing code from being invoked on the
        //: wrong thread.

        //: With that said, setting a flag:
        //- ENGETHER.THREADING.InterlockedIncrement64( -//
        //-     &( GLEB_SWIN.THREAD_SAFE_FLAGS.        -//
        //-        redraw_message_count )              -//
        //- );;                                        -//

        
        //+ This call needs to be made from    +//
        //+ the same thread as your OpenGL     +//
        //+ calls.                             +//
        //# DONT_HERE:GLEB_SWIN_SwapBuffers(); #//





    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            ((F03_04)(F02_DefWindowProcW))(
            /**/(void*)                     Hw  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //[F09_WinMsgHanWndPoc]//

////////////////////////////////////////////////////////////////


int //:BOOL
F09_RegisterWindow(
/**/                    void*  hInstance                
/**/,   const unsigned short*  unique_window_name    
){

    //|Smoke_Test:-----------------------|//
    size_t struct_size =(
        sizeof( struct F09_STRUCT_WNDCLASSEXW )
    );;
    if( struct_size != 80 ){
        f09_Halt("[BadStructSize]");
    };;//|-------------------------------|//
    
    //: WNDCLASSEXW W;
    struct F09_STRUCT_WNDCLASSEXW 
    W = {0};

    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////

    W.cbSize=sizeof( struct F09_STRUCT_WNDCLASSEXW );
    W.style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                     //| ...ClassWin32         |//
    0);;
    W.lpfnWndProc=F09_WinMsgHanWndPoc;
    W.cbClsExtra=0;
    W.cbWndExtra=0;
    W.hInstance=hInstance;

    char* idi_application = F09_MakeIntResourceA( 32512 );
    char* idc_arrow       = F09_MakeIntResourceA( 32512 );

    W.hIcon  =((F03_02)F02_LoadIconA)(  
        NULL
    ,   idi_application
    );;
    W.hCursor=((F03_02)F02_LoadCursorA)(  
        NULL
    ,   idc_arrow
    );;

    //| Looking at:                            |//
    //| https://github.com/glfw/glfw/blob/     |//
    //| master/src/win32_window.c              |//
    //| does not look like background          |//
    //| brush color eneds to be set.           |//
    //|                                        |//
    //| Code here specifically says:           |//
    //| "No Background Required For GL"        |//
    //| http://nehe.gamedev.net/tutorial       |//
    //| /creating_an_opengl_window_(win32)     |//
    //| /13001/                                |//
    //- W.hbrBackground=(                      -//
    //-     /**/(HBRUSH)                       -// 
    //-     /**/ FP->GDI32.GetStockObject(     -// 
    //-     /**/     FP->GDI32.DATA.BRUSH.BLACK-// 
    //-     /**/)                              -// 
    //- );;                                    -//
    W.hbrBackground=NULL;

    W.lpszMenuName=NULL;
    W.lpszClassName=unique_window_name;
    W.hIconSm=(
        ((F03_02)F02_LoadIconA)(
            NULL
        ,   idi_application
        )
    );;

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //! If you forget to register your         !//
    //! window class, the observable effect    !//
    //! is the window never opening, and the   !//
    //! wait loop exiting immediately.         !//
    //|________________________________________|//
    return(
        (int)(unsigned long long)
        ((F03_01)F02_RegisterClassExW)(
            &( W )
        )
    );;
} //[Register]//


void //:gleb_swin_MakeWindowCompatibleWith_GL
f09_MakeWindowCompatibleWith_GL(
    void*  Hw /**HWND**/
){
    
    f09_InitPixelFormatDescriptor();

    void* /** HDC **/ 
    window_device_context =(
        ((F03_01)F02_GetWindowDC)( Hw ) /**user32**/
    );;
    int
    pixel_format_number=(
        (int)(unsigned long long)
        ((F03_02)F02_ChoosePixelFormat)( /**gdi32**/
            window_device_context
        , &( f09_pixel_format_descriptor )
        )
    );;
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((F03_03)F02_SetPixelFormat)(
        /**/
        /**/        window_device_context
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        pixel_format_number
        /**/    ,
        /**/        &( f09_pixel_format_descriptor )
        )
    );;
    if( setting_pixel_format_worked ){
        //: printf("[SPF:OK]\n");
    }else{
        f09_Halt("[SPF:FAIL]\n");
    };;

    f09_window_device_context=(
        window_device_context
    );;

} //[MakeWindowCompatibleWith_GL]//


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

int //:BOOL
f09_TakeOrLookMessage( 
/**/
    struct F09_STRUCT_MSG*
    dont_prefix_message_with_and_symbol /**LPMSG**/
    ,
    int    
    take_the_message
){

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        f09_Halt("[Exp:Pos|Or|Zero]");
    };;

    int ret =(
    (int)(unsigned long long)
    ((F03_05)F02_PeekMessageW)(
        (void*)
        dont_prefix_message_with_and_symbol
        ,
        NULL
        ,
        0
        ,
        0
        ,
        (void*)(unsigned long long)
        look_or_take

    ));;

    return( ret );

} //[TakeOrLookMessage]//



int //:BOOL
f09_LookMessage(
    struct F09_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=f09_TakeOrLookMessage(msg,look);
    return( ret );
} //[LookMessage]//



int //:BOOL
f09_TakeMessage(
    struct F09_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=f09_TakeOrLookMessage(msg,take);
    return( ret );
} //[TakeMessage]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


struct F09_STRUCT_MSG //:MSG struct
f09_WindowLoop(
    void*  Hw //:HWND
){

    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;
    ((F03_02)F02_ShowWindow  )(  Hw, show  ); 
    ((F03_01)F02_UpdateWindow)(  Hw        ); 
    ((F03_01)F02_SetFocus    )(  Hw        );

    unsigned int  wm_quit =  0x12;          

    struct F09_STRUCT_MSG  
    M; //:MSG struct

    f09_LookMessage( &M );
    while(
        M.message
        !=
        wm_quit
    ){
        if( f09_TakeMessage(    &M )){

            ((F03_01)F02_TranslateMessage)( &M );

            ((F03_01)F02_DispatchMessageW)( &M );

        };;

    };;

    f09_window_just_closed = ('t'|'r'|'u'|'e');

   //: //# [HACK]:Sleep a bit so other threads    #//
   //: //#        see "window_just_closed" update.#//
   //: //# You really should use a proper mutex.  #//
    ((F03_01)F02_Sleep)( (void*)64 );

    return( M );

} //[WindowLoop]//


//: Call this function on a separate thread!
//: Refactor_Of:gleb_swin_OPEN_WINDOW_LOOP_FOREVER
unsigned __int64 //:WPARAM
F09_OpenWindowAndLoopForever(
    //:UNICODE_STRING
    const unsigned short *  //:LPCWSTR (Technically_LPCTSTR)
    unique_window_name      
    ,
    const unsigned short *  //:LPCWSTR (Technically_LPCTSTR)
    window_titlebar_text

    //:#Technically_LPCTSTR#://
    //: Technically LPCTSTR, not LPCWSTR,
    //: But using extended (ex) function and unicode/wide
    //: characters where I can. Thus resolved type is LPCWSTR.
){
     
    //: void* /**HMODULE**/ hin=(
    //:     ((F03_01)F02_GetModuleHandleW)(
    //:         NULL
    //:     )
    //: );;//[a]//

    /** HMODULE / HINSTANCE / Handle_To_Running_Exe_File **/
    if(NULL != f09_handle_to_exe ){
        f09_Halt("[Expected_Null_exe_handle_to_start]");
    };;
    f09_handle_to_exe =(
         ((F03_01)F02_GetModuleHandleW)(
             NULL
         )
    );;

    if(NULL==f09_handle_to_exe){
        f09_Halt(
            "[FailedToGetModuleHandle]"
        );;
    };;//[b]//

    /////////////////////////////////////
    void*                              //
    Hw = NULL;  //:HWND                //
                                       //
    struct F09_STRUCT_MSG              //
    Msg       ;   //:tagMSG (Struct)   //
    /////////////////////////////////////

    if(0 >=
        F09_RegisterWindow(
            f09_handle_to_exe /** HINSTANCE/HMODULE **/
        ,   unique_window_name
        )
    ){ 

        f09_Halt( /** Originally: gleb_swin_Alert **/
            "[FailedToRegisterWindow]"
        );;
        return 0; 

    };;//[c]//

    int X   = f09_X   ; //:Initial_X_Position
    int Y   = f09_Y   ; //:Initial_Y_Position
    int WID = f09_WID ; //:Initial_WIDTH
    int HIG = f09_HIG ; //:Initial_HEIGHT

    unsigned long ws_overlappedwindow=( 0
    |   0x00000000L  /** WS_OVERLAPPED  **/
    |   0x00C00000L  /** WS_CAPTION     **/
    |   0x00080000L  /** WS_SYSMENU     **/
    |   0x00040000L  /** WS_THICKFRAME  **/
    |   0x00020000L  /** WS_MINIMIZEBOX **/
    |   0x00010000L  /** WS_MAXIMIZEBOX **/
    );;//[d]//

    unsigned long cs_owndc = 0x0020;

    //:NOOP's so I can comment out call to CreateWindowExW:
    if( cs_owndc            ){ /** NOOP **/ };
    if( ws_overlappedwindow ){ /** NOOP **/ };
    if( X|Y|WID|HIG         ){ /** NOOP **/ };
    if( f09_handle_to_exe   ){ /** NOOP **/ };

    void*
    the_desktop_window=((F03_00)F02_GetDesktopWindow)();

    Hw=F08_CreateWindowExW
    (

    /**/0x00000008L           /** ws_ex_topmost **/
    ,   unique_window_name    /** lpClassName   **/
    ,   window_titlebar_text  /** lpWindowName  **/      
  
    , 
        (0
        |  ws_overlappedwindow /** STYLE **/   
        |  cs_owndc            /** STYLE **/
        |
        0)

    ,   X,Y,WID,HIG

    ,   the_desktop_window //:-- hWndParent ---://
    ,   NULL   //:-------------- hMenu      ---://
    ,   f09_handle_to_exe  //:-- hInstance  ---://        
    ,   NULL   //:-------------- lpParam    ---://  
    );//[e]//

    if(Hw==NULL){
        f09_Halt("[F09:WindowCreateFail]");
        return 0;
    };;//[f]//

    //:Store the handle to window in global state:
    f09_handle_to_window=Hw;

    //:Modifications to make window opengl
    //:compatible:
    //////////////////////////////////////////////
    f09_MakeWindowCompatibleWith_GL(
        Hw
    );;//[g]//

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯MC|//
    //!PUT AFTER device context has been     MC!//
    //!set, or your device context fetching  MC!//
    //!function waiting on this flag to be   MC!//
    //!set in this thread will end up        MC!//
    //!with a NULL device context.           MC!//
    //!Speaking Of:                          MC!//
    //!GLEB_SWIN_GetWindowDeviceContext();   MC!//
    f09_window_created=1;                 //|MC|//
    //|______________________________________MC|//

    //////////////////////////////////////////////

    Msg = f09_WindowLoop( Hw );

    return Msg.wParam;
} //[OPEN_WINDOW_LOOP_FOREVER]//

int F09_Init(){
    
    //:No action besides calling down the chain.

    int ret = F08_Init();

    return( ret );
}//[;]//
int F09_Main(){
    F09_Init();

    //:NOT called int "Init" function, because we want
    //:to create the window in different thread higher
    //:up the chain.
    F09_OpenWindowAndLoopForever(
        L"MOTHER_FUCKING_UNIQUE_WINDOW_CLASS_ID"
    ,   L"[SEE_FILE[ F.07 ]][伍零s丁]"
    );;

    return( 0 );
}//[;]//

int F09_Demo_SingleThreaded(){
    F09_Main();
    return( 0 );
}//[;]//


//[ ]////|////////////////////////////////////////////|////[ ]//
//[ ]////|     -///-                        -///-     |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|       ______________________________       |////[ ]//
//[ ]////|______/                              \______|////[ ]//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) ///////////////////////////
/** ******************************************************** |||
                                                   
#VARS_TOP_OF_FILE_BIG_PICTURE#
    Variables are at the top of the file because they are
    what is most likely to be re-looked at when looking
    over the code months later.
                                                 
  
||| ******************************************************** **/ 
#endif /////////////////////////////////////////////////////////
//[ ]////|______                                ______|////[ ]//
//[ ]////|||||||\______________________________/|||||||////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|____________________________________________|////[ ]//

//#FILE_REGION[ F.09 ]END#####################################//
//#FILE_REGION[ F.10 ]BEG#####################################//

//:DOTADIW: WIN_IN_THREAD
//:  ( launch_window_in_new_thread )



//||Thread is closed using the HANDLE.                      ||//
//||So not sure what the point of the thread_id is.         ||//
//||                                                        ||//
//||StackOverflow:                                          ||//
//||    Under Windows,the thread handle is different from   ||//
//||    the thread ID, in the same way that a file handle   ||//                               
//||    is different from a file name.                      ||//
    //[ The fact that these threads are for the "window"     ]//
    //[ are implied by the DOTADIW of [F.10/F10_] namespace. ]//
    void*               F10_thread_handle ;         
    long unsigned int   F10_thread_id     ;  

    struct F10_STRUCT_MYDATA{
        int val1;
        int val2;
    };//[struct:MYDATA]//

    struct F10_STRUCT_MYDATA* 
    F10_custom_data_ptr=NULL;


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//[H:Halt Always first function in file._____________________]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
void F10_Halt( const char*     msg ){ 
    printf( "[F10_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//             
                                           
                                          
void                                      
F10_PrintCustomThreadData(          
                                          
    void* custom_data                     
                                          
){            
    #define MYDATA  struct F10_STRUCT_MYDATA   /////////////////
                                                 
        //[-----------------------------------]////[ xxxxxxx ]//
        //[ Both will print the same thing:---]////[ xxxxxxx ]//
        //[-----------------------------------]////[ xxxxxxx ]//
        //[PRINT:File_Member_Variable: -------]////[ xxxxxxx ]//
        printf( "[PARAMS]:( %d, %d )\n"          //[ xxxxxxx ]//
        ,   ((MYDATA*)F10_custom_data_ptr)->val1 //[ xxxxxxx ]//                           
        ,   ((MYDATA*)F10_custom_data_ptr)->val2 //[ xxxxxxx ]//
        );;                                      //[ xxxxxxx ]//
        //[PRINT:Input_Argument: -------------]////[ xxxxxxx ]//
        printf( "[PARAMS]:( %d, %d )\n"          //[ xxxxxxx ]//
        ,   ((MYDATA*)    custom_data)->val1     //[ xxxxxxx ]//       
        ,   ((MYDATA*)    custom_data)->val2     //[ xxxxxxx ]//
        );;                                      //[ xxxxxxx ]//
        //[___________________________________]////[ xxxxxxx ]//

    #undef  MYDATA /////////////////////////////////////////////
                                          
} //[PrintCustomThreadData]//   


unsigned long __stdcall           
F10_StartRoutine_CreatesWindow_CalledInNewThread(               
                                          
    void*  custom_data              
                                          
){                                        
    F10_PrintCustomThreadData( custom_data );                                  
                                                    
    #define T const unsigned short*                     
    T unique_window_name=(                  
        L"F10_UNIQUE_WINDOW_NAME"   
    );;     
    T window_titlebar_text=(
        L"[SEE_FILE[ F.08 ]]((╯°□°）╯︵ ┻━┻))"
    );;
                              
    F09_OpenWindowAndLoopForever(   
        unique_window_name   //:<---PlayItSafeStickToAsciiChars
    ,   window_titlebar_text //:<---WhateverYouWant
    );;                                   
                                          
    return 0;                             
} //[gleb_swin_THREAD_FUNCTION / F10_StartRoutine ]//      




void                                       
F10_CreateThread_Launches_StartRoutine(){                  
                                                                     
    void* process_heap=((F03_00)F02_GetProcessHeap)();
    if(NULL==process_heap){ F10_Halt("process_heap"); };                                   
                                          
    //[ Allocate memory for thread data. ]//
    F10_custom_data_ptr =((struct F10_STRUCT_MYDATA *)

        ((F03_03)F02_HeapAlloc)(                                       
            process_heap                  
        ,   
            (void*)(unsigned long long)
            0x00000008 /** HEAP_ZERO_MEMORY **/ 
                                       
        ,   
            (void*)(unsigned long long)
            sizeof(struct F10_STRUCT_MYDATA)                                  
        ) 
                                
    );;                                    
                                          
    //[¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯]//
    //[ System if out of memory, you will ]//
    //[ be unable to print error message. ]//
    //[ But what about error code?        ]//
    //[___________________________________]//
    if( F10_custom_data_ptr == NULL ){ 
        exit( 9873 );                     
    };;                                   
                                          
    //! Set Some Custom Data           !//
    F10_custom_data_ptr -> val1 = 333;   
    F10_custom_data_ptr -> val2 = 777;   
                                          
    //: typedef              //[ <<< LPTHREAD_START_ROUTINE -----]//
    //:     unsigned long    //[ <<< LPTHREAD_START_ROUTINE -----]//
    //:     (__stdcall *pfn) //[ <<< LPTHREAD_START_ROUTINE -----]//
    //:     (void*);         //[ <<< LPTHREAD_START_ROUTINE -----]//


    ////////////////////////////////////////////////////////////
    #define   P_F_N   F05_LSR //:PFN:LPTHREAD_START_ROUTINE
              P_F_N 
    pfn_start_routine=(
        F10_StartRoutine_CreatesWindow_CalledInNewThread
    );;
    #undef    P_F_N
    ////////////////////////////////////////////////////////////

    ////////// //:Not really the way I want to solve this:
    //////////  F02_VOF vof_start_routine=(     
    ////////// (F02_VOF)pfn_start_routine  );; 
                                          
    //[ Create the thread to begin execution on its own. --- ]//
    F10_thread_handle=( ////////////////////////////////////////
    /**/F08_CreateThread(   ///////////////////////////////////
    /**/   
    /**/       NULL               /** default_security   [01]**/               
    /**/   ,   0                  /** default_stack_size [02]**/                    
    /**/   ,   pfn_start_routine  /** lpStartAddress     [03]**/  
    /**/                                                 
    /**/   ,   F10_custom_data_ptr/** thread_func_arg    [04]**/    
    /**/   ,   0       /** Use_Default_Creation_Flags    [05]**/              
    /**/   ,   &( F10_thread_id ) /** Output_Param       [06]**/ 
    /**/
    /**/)    ///////////////////////////////////////////////////
    );;/////////////////////////////////////////////////////////
                                          
} //[CreateThread]//            

int F10_Init(){
    //:No action needed besides calling further down chain:

    int ret = F09_Init(); //: .SUPER_CHAIN

    //:F10 specific init logic:
    F10_CreateThread_Launches_StartRoutine();

    return( ret );

}//[;]//
    
int F10_Main(){
    F10_Init();

    printf(
        "***************** [CTRL+C:ToExit] *****************\n"
    );;

    fflush(stdout);

    while(1){

        //:Inifinite loop to keep program from
        //:exiting while window is running in
        //:that other thread.
        
        //:This is where you would launch other threads,
        //:or do a (game|render) loop.

    };;

}//[;]//

//#FILE_REGION[ F.10 ]END#####################################//
//#FILE_REGION[ F.20 ]BEG#####################################//

//: DOTADIW: VULKAN_STRUCT
//: (ALSO SEE: F.35: Structs that take function pointers)
//: (Declarations, no instantiation!)


//:void* types (via DECLARE_HANDLE( whatever ) )
//[ F20_VkDebugUtilsMessengerEXT ==== void*  ]//
//[ F20_VkDeviceSize ================ UI64   ]//
//[ F20_VkSurfaceKHR ================ void*  ]//

struct F20_VkApplicationInfo {
    unsigned int       sType; //:VkStructureType
    const void*        pNext;
    const char*        pApplicationName;
    unsigned int       applicationVersion; //:uint32_t
    const char*        pEngineName;
    unsigned int       engineVersion;      //:unsigned int
    unsigned int       apiVersion;         //:unsigned int
};//[struct]//

struct F20_VkInstanceCreateInfo {
    unsigned int                sType; //:VkStructureType
    const void*                 pNext;
    unsigned int                flags;

    const struct F20_VkApplicationInfo*    
                      pApplicationInfo;

    unsigned int                enabledLayerCount;
    const char* const*          ppEnabledLayerNames;

    //:Is "const char**" same as "const char* const*" ?
    //:In fact.. Both are "char**" with extra constraints.

    unsigned int                enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;

};//[struct]//

struct F20_VkExtensionProperties {

    char        
    extensionName[ 

        256 /**VK_MAX_EXTENSION_NAME_SIZE**/ 

    ];

    unsigned int /** uint32_t **/    
    specVersion;

};//[struct]//

struct F20_VkLayerProperties {
    
    #define MACRO_A 256 //:VK_MAX_EXTENSION_NAME_SIZE
    #define MACRO_B 256 //:VK_MAX_DESCRIPTION_SIZE

    char            layerName[   MACRO_A ];//:MAX_EXT
    unsigned int    specVersion;
    unsigned int    implementationVersion;
    char            description[ MACRO_B ];//:MAX_DSC

    #undef MACRO_A
    #undef MACRO_B

};//[struct]//

struct 
F20_VkDebugUtilsLabelEXT {
    unsigned int       sType; /** VkStructureType **/
    const void*        pNext;
    const char*        pLabelName;
    float              color[4];
};//[struct]//

struct 
F20_VkDebugUtilsObjectNameInfoEXT {
    unsigned int         sType;        /** VkStructureType **/
    const   void*        pNext;
    unsigned int         objectType;   /** VkObjectType    **/
    unsigned long long   objectHandle; /** uint64_t        **/
    const char*          pObjectName;
};

////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////

struct 
F20_VkDebugUtilsMessengerCallbackDataEXT {

    unsigned int /** VkStructureType **/
    sType;

    const void*                                  
    pNext;

    /** VkDebugUtilsMessengerCallbackDataFlagsEXT **/ 
    unsigned int    
    flags;

    const char*                                  
    pMessageIdName;

    signed int /** int32_t **/                                      
    messageIdNumber;

    const char*                                  
    pMessage;

    unsigned int /** uint32_t **/                                     
    queueLabelCount;

    const struct F20_VkDebugUtilsLabelEXT*                  
    pQueueLabels;

    unsigned int /** uint32_t **/                                     
    cmdBufLabelCount;

    const struct F20_VkDebugUtilsLabelEXT*                  
    pCmdBufLabels;

    unsigned int /** uint32_t **/                                     
    objectCount;

    const struct F20_VkDebugUtilsObjectNameInfoEXT*         
    pObjects;

};

//+----------------------------------------------------------+//
//|                                                          |//
//|          www.khronos.org/registry/vulkan/specs/          |//
//|          1.1-extensions/man/html/                        |//
//|          VkPhysicalDeviceFeatures.html                   |//
//|                                                          |//
//+----------------------------------------------------------+//
/** UI32  =~=  typedef uint32_t VkBool32 **/ ///////////////////
#define UI32 unsigned int //////////////////////////////////////
struct F20_VkPhysicalDeviceFeatures {

        UI32    robustBufferAccess;
        UI32    fullDrawIndexUint32;
        UI32    imageCubeArray;
        UI32    independentBlend;
        UI32    geometryShader;
        UI32    tessellationShader;
        UI32    sampleRateShading;
        UI32    dualSrcBlend;
        UI32    logicOp;
        UI32    multiDrawIndirect;
        UI32    drawIndirectFirstInstance;
        UI32    depthClamp;
        UI32    depthBiasClamp;
        UI32    fillModeNonSolid;
        UI32    depthBounds;
        UI32    wideLines;
        UI32    largePoints;
        UI32    alphaToOne;
        UI32    multiViewport;
        UI32    samplerAnisotropy;
        UI32    textureCompressionETC2;
        UI32    textureCompressionASTC_LDR;
        UI32    textureCompressionBC;
        UI32    occlusionQueryPrecise;
        UI32    pipelineStatisticsQuery;
        UI32    vertexPipelineStoresAndAtomics;
        UI32    fragmentStoresAndAtomics;
        UI32    shaderTessellationAndGeometryPointSize;
        UI32    shaderImageGatherExtended;
        UI32    shaderStorageImageExtendedFormats;
        UI32    shaderStorageImageMultisample;
        UI32    shaderStorageImageReadWithoutFormat;
        UI32    shaderStorageImageWriteWithoutFormat;
        UI32    shaderUniformBufferArrayDynamicIndexing;
        UI32    shaderSampledImageArrayDynamicIndexing;
        UI32    shaderStorageBufferArrayDynamicIndexing;
        UI32    shaderStorageImageArrayDynamicIndexing;
        UI32    shaderClipDistance;
        UI32    shaderCullDistance;
        UI32    shaderFloat64;
        UI32    shaderInt64;
        UI32    shaderInt16;
        UI32    shaderResourceResidency;
        UI32    shaderResourceMinLod;
        UI32    sparseBinding;
        UI32    sparseResidencyBuffer;
        UI32    sparseResidencyImage2D;
        UI32    sparseResidencyImage3D;
        UI32    sparseResidency2Samples;
        UI32    sparseResidency4Samples;
        UI32    sparseResidency8Samples;
        UI32    sparseResidency16Samples;
        UI32    sparseResidencyAliased;
        UI32    variableMultisampleRate;
        UI32    inheritedQueries;

};

#undef  UI32 ///////////////////////////////////////////////////

////////////////////////////////////////////////////////////////


#define I_32   signed int  /////////////////////////////////////
#define UI32 unsigned int  /////////////////////////////////////
#define UI64 unsigned long long ////////////////////////////////
#define FLOT float /////////////////////////////////////////////

struct F20_VkPhysicalDeviceLimits {

    //:ImageDimension:
    UI32    maxImageDimension1D;
    UI32    maxImageDimension2D;
    UI32    maxImageDimension3D;
    UI32    maxImageDimensionCube;

    //:max.... whatever.
    UI32    maxImageArrayLayers;
    UI32    maxTexelBufferElements;
    UI32    maxUniformBufferRange;
    UI32    maxStorageBufferRange;
    UI32    maxPushConstantsSize;
    UI32    maxMemoryAllocationCount;
    UI32    maxSamplerAllocationCount;

    
    UI64    bufferImageGranularity; /** VkDeviceSize **/
    UI64    sparseAddressSpaceSize; /** VkDeviceSize **/

    //:DescriptorSets (PLURAL)
    //:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://

    //:Max number of descriptor sets that can 
    //:be simultaneously used by a pipeline. 
    UI32    maxBoundDescriptorSets;

    //:Descriptor
    UI32        maxPerStageDescriptorSamplers;
    UI32        maxPerStageDescriptorUniformBuffers;
    UI32        maxPerStageDescriptorStorageBuffers;
    UI32        maxPerStageDescriptorSampledImages;
    UI32        maxPerStageDescriptorStorageImages;
    UI32        maxPerStageDescriptorInputAttachments;

    //:Max number of resources that can be accessible 
    //:to a single shader stage in a pipeline layout.
    UI32    maxPerStageResources;

    //:DescriptorSet:
    UI32        maxDescriptorSetSamplers;
    UI32        maxDescriptorSetUniformBuffers;
    UI32        maxDescriptorSetUniformBuffersDynamic;
    UI32        maxDescriptorSetStorageBuffers;
    UI32        maxDescriptorSetStorageBuffersDynamic;
    UI32        maxDescriptorSetSampledImages;
    UI32        maxDescriptorSetStorageImages;
    UI32        maxDescriptorSetInputAttachments;

    //:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://

    //:Vertex:
    UI32    maxVertexInputAttributes;
    UI32    maxVertexInputBindings;
    UI32    maxVertexInputAttributeOffset;
    UI32    maxVertexInputBindingStride;
    UI32    maxVertexOutputComponents;

    //:Tessellation:
    UI32    maxTessellationGenerationLevel;
    UI32    maxTessellationPatchSize;
    UI32    maxTessellationControlPerVertexInputComponents;
    UI32    maxTessellationControlPerVertexOutputComponents;
    UI32    maxTessellationControlPerPatchOutputComponents;
    UI32    maxTessellationControlTotalOutputComponents;
    UI32    maxTessellationEvaluationInputComponents;
    UI32    maxTessellationEvaluationOutputComponents;

    //:Geometry:
    UI32    maxGeometryShaderInvocations;
    UI32    maxGeometryInputComponents;
    UI32    maxGeometryOutputComponents;
    UI32    maxGeometryOutputVertices;
    UI32    maxGeometryTotalOutputComponents;

    //:Fragment:
    UI32    maxFragmentInputComponents;
    UI32    maxFragmentOutputAttachments;
    UI32    maxFragmentDualSrcAttachments;
    UI32    maxFragmentCombinedOutputResources;

    //:Compute:
    UI32    maxComputeSharedMemorySize;
    UI32    maxComputeWorkGroupCount[3];
    UI32    maxComputeWorkGroupInvocations;
    UI32    maxComputeWorkGroupSize[3];

    //:PrecisionBits
    UI32    subPixelPrecisionBits;
    UI32    subTexelPrecisionBits;
    UI32    mipmapPrecisionBits;

    UI32    maxDrawIndexedIndexValue;
    UI32    maxDrawIndirectCount;
   
    FLOT    maxSamplerLodBias;
    FLOT    maxSamplerAnisotropy;

    UI32    maxViewports;
    UI32    maxViewportDimensions[2];

    FLOT    viewportBoundsRange[2];
    
    UI32    viewportSubPixelBits;
    
    UI64    minMemoryMapAlignment; /** size_t type **/

    //:VkDeviceSize: UI64 (unsigned long long)
    //:[ _____________ BufferOffsetAlignment ]            
    ////////////////////////////////////////////////////////////
                                                           /////
                                                           /////
    UI64      minTexelBufferOffsetAlignment;   //:SEE_01   /////
    UI64    minUniformBufferOffsetAlignment;   //:SEE_02   /////
    UI64    minStorageBufferOffsetAlignment;   //:SEE_03   /////
                                                           /////
            //: SEE_01: VkBufferViewCreateInfo             /////
            //: SEE_02: VkDescriptorBufferInfo             /////
            //: SEE_03: VkDescriptorBufferInfo             /////
                                                           /////
    ////////////////////////////////////////////////////////////

    I_32    minTexelOffset;
    UI32    maxTexelOffset;

    I_32    minTexelGatherOffset;
    UI32    maxTexelGatherOffset;

    FLOT    minInterpolationOffset;
    FLOT    maxInterpolationOffset;

    UI32    subPixelInterpolationOffsetBits;

    UI32    maxFramebufferWidth;
    UI32    maxFramebufferHeight;
    UI32    maxFramebufferLayers;

    //: VkSampleCountFlags: UI32 ///////////////////////////////
    ////////////////////////////////////////////////////////////
                                                   /////////////
    UI32    framebufferColorSampleCounts        ;  /////////////
    UI32    framebufferDepthSampleCounts        ;  /////////////
    UI32    framebufferStencilSampleCounts      ;  /////////////
    UI32    framebufferNoAttachmentsSampleCounts;  /////////////
                                                   /////////////
    ////////////////////////////////////////////////////////////

    UI32    maxColorAttachments; /** uint32_t **/

    //: VkSampleCountFlags: UI32 ///////////////////////////////
    ////////////////////////////////////////////////////////////
                                              //////////////////
    UI32    sampledImageColorSampleCounts  ;  //////////////////
    UI32    sampledImageIntegerSampleCounts;  //////////////////
    UI32    sampledImageDepthSampleCounts  ;  //////////////////
    UI32    sampledImageStencilSampleCounts;  //////////////////
    UI32    storageImageSampleCounts       ;  //////////////////
                                              //////////////////
    ////////////////////////////////////////////////////////////

    //:uint32_t: UI32 ( unsigned int )
    ////////////////////////////////////////////////////////////

    UI32    maxSampleMaskWords;

    ////////////////////////////////////////////////////////////

    //:VkBool32: UI32
    ////////////////////////////////////////////////////////////

    UI32    imestampComputeAndGraphics;

    ////////////////////////////////////////////////////////////

    FLOT    timestampPeriod;

    //:uint32_t: UI32 ( unsigned int )
    ////////////////////////////////////////////////////////////

    UI32    maxClipDistances;
    UI32    maxCullDistances;
    UI32    maxCombinedClipAndCullDistances;
    UI32    discreteQueuePriorities;

    ////////////////////////////////////////////////////////////

    FLOT    pointSizeRange[2];
    FLOT    lineWidthRange[2];
    FLOT    pointSizeGranularity;
    FLOT    lineWidthGranularity;

    //:VkBool32: UI32
    ////////////////////////////////////////////////////////////

    UI32    strictLines;
    UI32    standardSampleLocations;

    ////////////////////////////////////////////////////////////

    //:VkDeviceSize: UI64 ( unsigned long long )
    ////////////////////////////////////////////////////////////

    UI64    optimalBufferCopyOffsetAlignment;
    UI64    optimalBufferCopyRowPitchAlignment;
    UI64    nonCoherentAtomSize;

    ////////////////////////////////////////////////////////////
};
#undef  I_32  //////////////////////////////////////////////////
#undef  UI32  //////////////////////////////////////////////////
#undef  UI64  //////////////////////////////////////////////////
#undef  FLOT  //////////////////////////////////////////////////

////////////////////////////////////////////////////////////////

struct F20_VkPhysicalDeviceSparseProperties {

    //:residency:
    //:    An object is considered to be resident 
    //:    when it is accessible by the GPU. -MSDN
   
    #define UI32 unsigned int //////////////////////////////////

            /////// residency //////////////////////////////////
            UI32    residencyStandard2DBlockShape;
            UI32    residencyStandard2DMultisampleBlockShape;
            UI32    residencyStandard3DBlockShape;
            UI32    residencyAlignedMipSize;
            UI32    residencyNonResidentStrict;
            /////// residency //////////////////////////////////

    #undef  UI32 ///////////////////////////////////////////////
};

////////////////////////////////////////////////////////////////

struct F20_VkPhysicalDeviceProperties {

    unsigned int /** uint32_t **/ apiVersion;
    unsigned int /** uint32_t **/ driverVersion;
    unsigned int /** uint32_t **/ vendorID;
    unsigned int /** uint32_t **/ deviceID;

    unsigned int /** enum VkPhysicalDeviceType **/                
    deviceType;

    char                                
    deviceName[ 256 /** VK_MAX_PHYSICAL_DEVICE_NAME_SIZE **/ ];

    unsigned char /** uint8_t **/              
    pipelineCacheUUID[ 16 /** VK_UUID_SIZE **/ ];

    struct F20_VkPhysicalDeviceLimits              
    limits;

    struct F20_VkPhysicalDeviceSparseProperties    
    sparseProperties;

} VkPhysicalDeviceProperties;

struct F20_VkExtent3D {

    #define UI32 unsigned int //////////////////////////////////
            UI32    width ;
            UI32    height;
            UI32    depth ;
    #undef  UI32 ///////////////////////////////////////////////
};

struct F20_VkQueueFamilyProperties {
    unsigned int    queueFlags; /** VkQueueFlags --> VkFlags **/
    unsigned int    queueCount;          /** uint32_t **/
    unsigned int    timestampValidBits;  /** uint32_t **/
    
    struct F20_VkExtent3D  
    minImageTransferGranularity;
};

struct F20_VkDeviceQueueCreateInfo {
    unsigned int   sType; /** VkStructureType **/
    const void*    pNext; 
    unsigned int   flags; /** VkDeviceQueueCreateFlags **/

    unsigned int   queueFamilyIndex; /** uint32_t **/
    unsigned int   queueCount      ; /** uint32_t **/
    const float*   pQueuePriorities;
};

//:For creating "Logical" device.
struct F20_VkDeviceCreateInfo{
    unsigned int                       sType; /** VkStructureType **/
    const void*                        pNext;
    unsigned int                       flags; /** VkDeviceCreateFlags **/

    // ------------------------------------------------------ //

    unsigned int /** uint32_t **/                           
    queueCreateInfoCount;

    const struct F20_VkDeviceQueueCreateInfo*     
    pQueueCreateInfos;
    
    // ------------------------------------------------------ //

    unsigned int                       enabledLayerCount;

    //:Just a read only char** (List of strings):
    const char* const*                 ppEnabledLayerNames;

    unsigned int                       enabledExtensionCount;

    //:Another read-only char** (List Of Strings):
    const char* const*                 ppEnabledExtensionNames;

    //:
    const struct F20_VkPhysicalDeviceFeatures*    
    pEnabledFeatures;
};

//: VkWin32SurfaceCreateInfoKHR 
struct 
F20_VkWin32SurfaceCreateInfoKHR{

    unsigned int    sType; /** VkStructureType **/
    const void*     pNext;
    unsigned int    flags; /** VkWin32SurfaceCreateFlagsKHR **/
    void*       hinstance; /** HINSTANCE **/
    void*            hwnd; /** HWND      **/

};//




////////////////////////////////////////////////////////////////
//    ABOVE: DATA                                             //
//    BELOW: FUNC                                             //
////////////////////////////////////////////////////////////////

//:HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH://
//:First function always "Halt":
static void 
f20_Halt( const char* msg ){ 
    printf( "[f20_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//:HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH://

//:BUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBU://
//:BU:BlowUp
static void
f20_BlowUpIfStructSizesIncorrect( void ){

    //:The hardcoded sizes are from my x64 windows 10 machine.
    //:AKA: ZOTAC_BOX
    //:(Comparing against lunarG vulkan headers)
    //:SEE[ SC[ edit_vk_struct_sizes_c11 ] ]

    int siz;

    siz = (int)sizeof( 
        struct F20_VkDebugUtilsMessengerCallbackDataEXT 
    );;if( 96 != siz ){ f20_Halt("[!96]"); };

    siz = (int)sizeof( 
        struct F20_VkDebugUtilsObjectNameInfoEXT
    );;if( 40 != siz ){ f20_Halt("[!40:DUONIE]"); };

    siz = (int)sizeof( 
        struct F20_VkDebugUtilsLabelEXT
    );;if( 40 != siz ){ f20_Halt("[!40:DULE]"); };

    siz = (int)sizeof( 
        struct F20_VkLayerProperties 
    );;if( 520 != siz ){ f20_Halt("[!520:LP]"); };

    siz = (int)sizeof( 
        struct F20_VkExtensionProperties 
    );;if( 260 != siz ){ f20_Halt("[!260:EP]"); };

    siz = (int)sizeof( 
        struct F20_VkInstanceCreateInfo 
    );;if( 64 != siz ){ f20_Halt("[!64:ICI]"); };

    siz = (int)sizeof( 
        struct F20_VkApplicationInfo 
    );;if( 48 != siz ){ f20_Halt("[!48:AI]"); };

    siz = (int)sizeof(
        struct F20_VkPhysicalDeviceFeatures
    );;if( 220 != siz ){ f20_Halt("[!220:PDF]"); };

    siz = (int)sizeof(
        struct F20_VkPhysicalDeviceLimits
    );;if( 504 != siz ){ f20_Halt("[!504:PDL]"); }

    siz = (int)sizeof(
        struct F20_VkPhysicalDeviceProperties
    );;if( 824 != siz ){ f20_Halt("[!824:PDP]"); }

    siz = (int)sizeof(
        struct F20_VkPhysicalDeviceSparseProperties
    );;if( 20 != siz ){ f20_Halt("[!20:PDSP]"); }

    siz = (int)sizeof(
        struct F20_VkExtent3D
    );;if( 12 != siz ){ f20_Halt("[!12:E3D]"); }

    siz = (int)sizeof(
        struct F20_VkQueueFamilyProperties
    );;if( 24 != siz ){ f20_Halt("[!24:QFP]"); }

    siz = (int)sizeof(
        struct F20_VkDeviceQueueCreateInfo
    );;if( 40 != siz ){ f20_Halt("[!40:DQCI]"); }

    siz = (int)sizeof(
        struct F20_VkDeviceCreateInfo
    );;if( 72 != siz ){ f20_Halt("[!72:DCI]"); }

    siz = (int)sizeof(
        struct F20_VkWin32SurfaceCreateInfoKHR
    );;if( 40 != siz ){ f20_Halt("[!40:W32SCI]"); }

        

    
    printf("\n");
    printf("[f20:struct_size_checks_pass]\n");
    printf("\n");
    fflush(stdout);


}//[;]//
//:BUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBUBU://


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F20_Init(){
        printf("[BEG:F20:Init]\n");

        int ret = F10_Init();

        f20_BlowUpIfStructSizesIncorrect();

        printf("[END:F20:Init]\n");
        return( ret );
    }//[;]//
    int F20_Main(){
        F20_Init();


        
        printf("[F20:TO_EXIT:CTRL+C]\n");
        while( 1 ){ /** Keep threaded window open. **/ };



        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.20 ]END#####################################//


//:DOTADIW: VULKAN_PFN_TD
//:         Vulkan Function Typedefs
//:         (do not typedef structs)

typedef 
    unsigned int /** VkBool32 **/ 
    (
        __stdcall /** VKAPI_PTR **/ 
        *F30_PFN_vkDebugUtilsMessengerCallbackEXT
    )
    (
        /** VkDebugUtilsMessageSeverityFlagBitsEXT **/
        signed int
        messageSeverity 
        ,
        /** VkDebugUtilsMessageTypeFlagsEXT  **/
        signed int
        messageTypes 
        ,
        const struct F20_VkDebugUtilsMessengerCallbackDataEXT*      
        pCallbackData 
        ,
        void*                                            
        pUserData
    );


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

    int F30_Init(){
        printf("[BEG:F30:Init]\n");

        int ret = F20_Init();

        printf("[END:F30:Init]\n");
        return( ret );
    }//[;]//
    int F30_Main(){
        F30_Init();

        

        printf("[F30:TO_EXIT:CTRL+C]\n");
        while( 1 ){ /** Keep threaded window open. **/ };



        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
//#FILE_REGION[ F.35 ]BEG#####################################//

//:DOTADIW: STRUCTS_W_PFN
//:        ( structs_with_pfn_members )
//:F.35: 
//:      Vulkan Structs that take function pointers as
//:      defined in F.30

struct 
F35_VkDebugUtilsMessengerCreateInfoEXT {

    signed int  /** VkStructureType **/   
    sType;

    const void*                             
    pNext;

    signed int  /** VkDebugUtilsMessengerCreateFlagsEXT **/
    flags;

    signed int  /** VkDebugUtilsMessageSeverityFlagsEXT **/
    messageSeverity;

    signed int  /** VkDebugUtilsMessageTypeFlagsEXT     **/         
    messageType;

    F30_PFN_vkDebugUtilsMessengerCallbackEXT      
    pfnUserCallback;

    void*                                   
    pUserData;

};//[struct]//

//:PROBABLY_COMMENTED_OUT_BECAUSE:
//:1: Don't want to create all of these "PFN_" types.
//:2: Not using allocation callback params of any function
//:   calls at the moment.
//:----------------------------------------------------------://
//       www.khronos.org/registry/vulkan/specs/1.1-extensions
//       /man/html/VkAllocationCallbacks.html
// struct
// F35_VkAllocationCallbacks{
//     
//     void*                                   pUserData;
//     PFN_vkAllocationFunction                pfnAllocation;
//     PFN_vkReallocationFunction              pfnReallocation;
//     PFN_vkFreeFunction                      pfnFree;
//     PFN_vkInternalAllocationNotification    pfnInternalAllocation;
//     PFN_vkInternalFreeNotification          pfnInternalFree;
// 
// };//[struct]//
//:----------------------------------------------------------://


//:HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH://
//:First function always "Halt":
static void 
f35_Halt( const char* msg ){ 
    printf( "[f35_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//:HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH://

static void
f35_BlowUpIfStructSizesIncorrect( void ){

    int siz;
    siz = (int)sizeof( 
        struct F35_VkDebugUtilsMessengerCreateInfoEXT );;

    if( 48 != siz ){
        f35_Halt("[!48]");
    };;

}//[;]//


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F35_Init(){
        printf("[BEG:F35:Init]\n");

            //:Call previous initialiers on chain:
            int ret = F30_Init(); //: ".SUPER_CHAIN()"

            f35_BlowUpIfStructSizesIncorrect();

        printf("[END:F35:Init]\n");
        return( ret );
    }//[;]//
    int F35_Main(){
        F35_Init();

            printf("[F35:TO_EXIT:CTRL+C]\n");
            while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.35 ]END#####################################//
//#FILE_REGION[ F.37 ]BEG#####################################//

    //:DOTADIW: INST_EXT_LIST
    //:       ( instance_extension_list   )
    //:       ( AND VALIDATION LAYERS LIST)
    //: 1. Wanted_Instance_Extensions_Check
    //: 2. Creation of instance extensions
    //:    name array to use later in instance
    //:    creation.

    //:This is to prepare for INSTANCE creation.
    //:Instance creation comes before device (logical device)
    //:creation.

static void
f37_PrivateInit( void ){

}//[;]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F37_Init(){
        printf("[BEG:F37:Init]\n");
        
            int ret = F35_Init(); //: ".SUPER_CHAIN()"
            f37_PrivateInit();
        
        printf("[END:F37:Init]\n");
        
            return( ret );
    }//[;]//
    int F37_Main(){
        F37_Init();

        printf("[F37:TO_EXIT:CTRL+C]\n");
        while( 1 ){ }; //:FAKE_GAME_LOOP

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


//#FILE_REGION[ F.37 ]END#####################################//
//#FILE_REGION[ F.40 ]BEG#####################################//

//:DOTADIW: Make_Vulkan_Instance
//:        ( Originally: VK_INIT_PART1               )
//:        ( Originally: Vulkan Tutorial Code Begins )

static void 
f40_Halt( const char* msg ){ 
    printf( "[F40_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//

          /** f40_use_validation_layers **/
#define f40_MACRO_use_validation_layers 0 //:ENABLE==CRASH!

//:For use outside this file, so we can undefine the
//:macro before we leave.
int f40_use_validation_layers=(

    f40_MACRO_use_validation_layers

);//[ON_SCOOBY_DOO_SHAGGYS_REAL_NAME_IS:Norville Rogers]//
//:https://en.wikipedia.org/wiki/Shaggy_Rogers

static struct 
F20_VkApplicationInfo 
f40_appInfo = { 0 };

static void* 
f40_instance = NULL; //: VkInstance

static struct 
F20_VkInstanceCreateInfo
f40_createInfo = { 0 };

static struct 
F20_VkExtensionProperties* 
f40_extensions = NULL;

static struct
F20_VkLayerProperties*
f40_layers=NULL; //:f40_instance_validation_layers

//: static void* /** VkDebugUtilsMessengerEXT **/
//: f40_callback=NULL;

//: static int //:NOOP: No-operation.
//: f40_NOOP1( void* arg1 ){ 
//:     if( arg1 ){ /** NOOP **/ };
//:     return( 0 );
//: }//[;]//

////////////////////////////////////////////////////////////////

                 /** f40_use_validation_layers **/
    #if(       f40_MACRO_use_validation_layers <= 0 ) //:OFF

        #define f40_wanted_extensions_count_MACRO 2

        static const char* 
        f40_wanted_extensions[
     //:f40_wanted_extensions=="instanceExtensions"

            f40_wanted_extensions_count_MACRO 

        ]={ 
                "VK_KHR_surface"
            ,   "VK_KHR_win32_surface"
        };

                 /** f40_use_validation_layers **/
    #elif(     f40_MACRO_use_validation_layers >  0 ) //:ENABLE
    
        #define f40_wanted_extensions_count_MACRO 3

        static const char* 
        f40_wanted_extensions[ 
     //:f40_wanted_extensions=="instanceExtensions"

            f40_wanted_extensions_count_MACRO 

        ]={ 
                "VK_KHR_surface"
            ,   "VK_KHR_win32_surface"
            ,   "VK_EXT_debug_utils" //:PG[55]SC[VKT2018]
        };

                 /** f40_use_validation_layers **/
    #endif //: f40_MACRO_use_validation_layers

#undef  UNDEF_THAT_MACRO_AT_BOTTOM_OF_FILE /////////////////////
#define f40_wanted_validation_layers_count_MACRO 1 /////////////

    static const char*
    f40_wanted_validation_layers[
        f40_wanted_validation_layers_count_MACRO
    ]={

        "VK_LAYER_LUNARG_standard_validation"

    };

#undef  UNDEF_THAT_MACRO_AT_BOTTOM_OF_FILE /////////////////////

////////////////////////////////////////////////////////////////

//: This belongs somewhere in the future.
//  int F40_EngineLoop( void ){
//      while( 1 ){
//  
//          //:RenderingLogicHere
//  
//      };;
//  }//[;]//

////////////////////////////////////////////////////////////////

//:    www.khronos.org/registry/vulkan/specs
//: /1.1-extensions/man/html/VK_MAKE_VERSION.html
static unsigned int f40_MV( //:VK_MAKE_VERSION 
    unsigned int major
,   unsigned int minor
,   unsigned int patch
){

    unsigned int ret;
    ret = (((major) << 22) | ((minor) << 12) | (patch));
    return( ret );

}//[;]//


////////////////////////////////////////////////////////////////


//:f40_debugCallback:
//:Renamed to f60_debugCallback and moved into "F.60"

static int 
f40_EngineInit( void ){  //:CALLED:"initVulkan()" in tutorial.

    printf("[BEG:f40_EngineInit]\n"); fflush(stdout);

    //:TODO: STUFF:

    //:What Extensions Do We Have?
    ////////////////////////////////////////////////////////////
    unsigned int
    extensionCount = 0;
    ((F03_03)F02_vkEnumerateInstanceExtensionProperties)(
        NULL
    ,   &extensionCount
    ,   NULL
    );;

        {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{

            int one = sizeof(struct F20_VkExtensionProperties);
            int all = one*extensionCount;
            f40_extensions = malloc( all );

        }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}

    ((F03_03)F02_vkEnumerateInstanceExtensionProperties)(
        NULL
    ,   &extensionCount
    ,    f40_extensions /** instanceExtensions **/
    );;                 /** instance_extensions**/

    printf("[extensionCount]:%d\n", extensionCount);
    for( int i = 0; i < (int)extensionCount; i++ ){

        printf("[INST_EXT_NAME:%s\n",
            (f40_extensions[ i ]).extensionName
        );;
    };;
    fflush(stdout);

    ////////////////////////////////////////////////////////////

    //: Chapter 6: Using Validation Layers.
    //: VK_TUT_2018.PDF   , BOOK_PAGE[ 52 - 53 ]
    ////////////////////////////////////////////////////////////

    if( f40_layers ){ /** NOOP **/ };

    unsigned int layer_count = 0;
    ((F03_02)F02_vkEnumerateInstanceLayerProperties)(
        &layer_count
    ,   NULL
    );;
    
    if( layer_count <= 0 ){
        f40_Halt("[WTF:NoLayers]\n");
    };;
    
        {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{

        //: [ f40_layers / 40_instance_validation_layers ]

        int one = sizeof( struct F20_VkLayerProperties );
        int all = one*layer_count;
        f40_layers=malloc(all); 

        }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
    
    ((F03_02)F02_vkEnumerateInstanceLayerProperties)(
        &layer_count
    ,    f40_layers
    );;
    
    printf("[layer_count]:%d\n", ((int)layer_count));
    for( int i = 0; i < (int)layer_count; i++ ){
    
        printf("[VAL_LAY:%s\n",
            (f40_layers[ i ]).layerName
        );;
    };;
    fflush(stdout);


    //:Compare against the validation layers you want:
    {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
    int found;
    
        int wanted_count =(
            f40_wanted_validation_layers_count_MACRO
        );;
        for( int w = 0; w <     wanted_count;  w++ ){ //:WANTED  
        for( int h = 0; h < (int)layer_count;  h++ ){ //:HAVE   

            //:FIRST:"h"
            ////////////////////////////////////////////////////
            if(0==h){ found = 0; }; //:RESET, first "h"
            ////////////////////////////////////////////////////

            //:BODY:
            ////////////////////////////////////////////////////
            
            const char* have = f40_layers[h].layerName;
            const char* want = f40_wanted_validation_layers[w];
            int com_res =( strcmp( have, want ) );
            if(0==com_res){
                found=1; break;
            };;

            ////////////////////////////////////////////////////

            //:LAST:"h"
            ////////////////////////////////////////////////////
            if( h == ((int)layer_count-1) ){ //:(-1)==LAST_ITEM
                if(found <= 0 ){
                    printf("[MISSING_LAYER]:%s\n", want );
                    f40_Halt(
                        "[WANTED_VALIDATION_LAYER_NOT_FOUND]"
                    );;
                };;
            };;
            ////////////////////////////////////////////////////

        };;};; //[ NEXT: WANTED|HAVE ]// ///////////////////////
    
    
    }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}

        //:Create Instance:
        ////////////////////////////////////////////////////////
        f40_appInfo.sType    = 0; /** APPLICATION_INFO **/
        f40_appInfo.pApplicationName   = "HELLO_TRIANGLE";
        f40_appInfo.applicationVersion = f40_MV(1,0,0)   ;
        f40_appInfo.pEngineName        = "No Engine"     ;
        f40_appInfo.engineVersion      = f40_MV(1,0,0)   ;
        f40_appInfo.apiVersion         = f40_MV(1,0,0)   ;

        f40_createInfo.sType = 1; /** INSTANCE_CREATE_INFO **/
        f40_createInfo.pApplicationInfo = &(f40_appInfo);
        f40_createInfo.enabledExtensionCount=(
            f40_wanted_extensions_count_MACRO
        );;
        f40_createInfo.ppEnabledExtensionNames=(
            f40_wanted_extensions
        );;

        f40_createInfo.enabledLayerCount=0;
        f40_createInfo.ppEnabledLayerNames=NULL;

            ////////////////////////////////////////////////////
            /** ENABLE_VALIDATION_LAYERS ?  **/  
            /**       f40_use_validation_layers **/
            /** f40_MACRO_use_validation_layers **/
            if( f40_use_validation_layers > 1 ){

                f40_createInfo.enabledLayerCount =(
                    f40_wanted_validation_layers_count_MACRO
                );;
                f40_createInfo.ppEnabledLayerNames=(
                    f40_wanted_validation_layers
                );;

            };;
            ////////////////////////////////////////////////////
       
        unsigned int res=(
            (unsigned int)(unsigned long long)
            ((F03_03)F02_vkCreateInstance)(
                &(f40_createInfo)
            ,   (void*)NULL
            ,   &(f40_instance)
            )
        );;
        if( 0 != res ){
            f40_Halt( "[2019_12_11:0213AM]");
        }else{

            printf("[vkCreateInstance:WORKED!]\n");
            fflush(stdout);

        };;
        ////////////////////////////////////////////////////////
    
        /******************************************************/
        /**  Setup code continued in FILE[ F.60 ]            **/
        /**  Because we need to grab function pointers that  **/
        /**  require a reference to a vulkan instance.       **/
        /**  This is done in FILE[ F.50 ]                    **/
        /******************************************************/
   
    ////////////////////////////////////////////////////////////
    //:END Chapter 6

    printf("[END:f40_EngineInit]\n"); fflush(stdout);
    return( 0 );
}//[;]//

//: Window now already opened via .SUPER_CHAIN
//: static int 
//: f40_OpenWindowAndInitializeEngine( void ){
//: 
//:     //:Start up the window loop:
//:     F10_CreateThread_Launches_StartRoutine();
//:     
//:     //:Initialize Vulkan Stuff:
//:     f40_EngineInit();
//: 
//:     return( 0 );
//: }//[;]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F40_Init(){
        printf("[BEG:F40:Init]\n");

        int ret = F37_Init(); //: ".SUPER_CHAIN()"

        f40_EngineInit(); /** f40_PrivateInit() **/

        printf("[END:F40:Init]\n");
        return( ret );
    }//[;]//
    int F40_Main(){
        F40_Init();

        printf("[F40:TO_EXIT:CTRL+C]\n");

        while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


#undef  f40_wanted_extensions_count_MACRO         //////////////
#undef  f40_wanted_validation_layers_count_MACRO  //////////////
#undef  f40_MACRO_use_validation_layers           //////////////

//#FILE_REGION[ F.40 ]END#####################################//
//#FILE_REGION[ F.50 ]BEG#####################################//

//:DOTADIW: VK_INST_FUNCS
//:         ( GetVulkanExtensionFunctions )
//:         
//:OUTISDE OF SCOPE:
//:         Proper wrapper code for function pointers.
//:         (SEE: "F.55" for that)
//:
//:GATHER VULKAN EXTENSION FUNCTIONS.
//:Lets go light on the "macro magic" though.
//:You can save ALMOST as much space without using macros,
//:and end up with much less obfuscated code.


//:PUBLIC Functions Fetched+Loaded in [ F.50 / F50 ]:
//:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://





    F02_VOF //:<--GenericFunctionPointer
    F50_vkCreateDebugUtilsMessengerEXT = NULL;



    F02_VOF  
    F50_vkCreateWin32SurfaceKHR =NULL;


    F02_VOF
    F50_vkGetPhysicalDeviceSurfaceSupportKHR =NULL;










//:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://
////////////////////////////////////////////////////////////////

    //:Private typedef and casted function pointer for
    //:getting instance functions:

    typedef
        F02_VOF //:RET:GenericFuncPtr
        (*f50_PFN_vkGetInstanceProcAddr)(
            void*       vk_instance   /**VkInstance:instance**/
        ,   const char* function_name /**----------:pName   **/
        );

    f50_PFN_vkGetInstanceProcAddr
    f50_FUN_vkGetInstanceProcAddr=NULL;

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
static void //[ #FFAH# ]//
f50_Halt( const char* msg ){ 
    printf( "[f50_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
////////////////////////////////////////////////////////////////


static F02_VOF //:<--returns generic function pointer.
f50_GIPA( /** WRAPPER:vkGetInstanceProcAddr **/
    void*       vk_instance
,   const char* function_name
){
    #define H f50_Halt /////////////////////////////////////////
    if( NULL==vk_instance                   ){ H("[VKI]"); };  
    if( NULL==function_name                 ){ H("[FNN]"); };
    if( NULL==f50_FUN_vkGetInstanceProcAddr ){ H("[FUN]"); };
    #undef  H //////////////////////////////////////////////////

    F02_VOF vulkan_instance_function_address = NULL;

    ////////////////////////////////////////////////////////////



    vulkan_instance_function_address=(
        f50_FUN_vkGetInstanceProcAddr(
            vk_instance   /** instance **/
        ,   function_name /**    pName **/
        )
    );;



    ////////////////////////////////////////////////////////////
    if(NULL==vulkan_instance_function_address){
        f50_Halt("[FTGA]");//:FailedToGetInstanceFunctionAddress
    };;
    return( vulkan_instance_function_address );//:VOID FUNCTION.

}//[;]//

static void
f50_fetchAndLoad_VulkanInstanceFunctions(){
    printf("[BEG:f50_fetchAndLoad_VulkanInstanceFunctions]\n");
    if(NULL==f40_instance){ f50_Halt("[I]"); };
    
        //:Setup function pointer GIPA uses:
        ////////////////////////////////////////////////////////
        f50_FUN_vkGetInstanceProcAddr=(
            (f50_PFN_vkGetInstanceProcAddr)
                 F02_vkGetInstanceProcAddr
        );;
        ////////////////////////////////////////////////////////

        
        //:Begin fetching functions:
        ////////////////////////////////////////////////////////

        if( f40_use_validation_layers > 0 ){

            //:Validation Layer Functions:

            F50_vkCreateDebugUtilsMessengerEXT=f50_GIPA(
                f40_instance
            ,   "vkCreateDebugUtilsMessengerEXT"
            );;
            if(NULL==F50_vkCreateDebugUtilsMessengerEXT){
                f50_Halt("[CDUME:VOF]");
            };;

        };;

        F50_vkCreateWin32SurfaceKHR=f50_GIPA(
            f40_instance
        ,   "vkCreateWin32SurfaceKHR"
        );;

        F50_vkGetPhysicalDeviceSurfaceSupportKHR=f50_GIPA(
            f40_instance
        ,  "vkGetPhysicalDeviceSurfaceSupportKHR"
        );;

        ////////////////////////////////////////////////////////


    printf("[END:f50_fetchAndLoad_VulkanInstanceFunctions]\n");
}//[;]//



//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F50_Init(){
        printf("[BEG:F50:Init]\n");

            //:Call previous initialiers on chain:
            int ret = F40_Init(); //: ".SUPER()"

            f50_fetchAndLoad_VulkanInstanceFunctions( );

        printf("[END:F50:Init]\n");
        return( ret );
    }//[;]//
    int F50_Main(){
        F50_Init();

            printf("[F50:TO_EXIT:CTRL+C]\n");
            while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//





//#FILE_REGION[ F.50 ]END#####################################//
//#FILE_REGION[ F.55 ]BEG#####################################//


//:DOTADIW: CAS_VK_EXT_FUNC_PTRS
//: ( Casted Vulkan Extension Function Pointers )
//: ( specific_pointers_for_instance_funcs      )
//:
//:         Cast previously fetched raw pointers to 
//:         vulkan instance extension functions into
//:         more specific function pointers complete
//:         with proper calling convention.


//: TODO: Put the typedefs in a file before this file to
//:       reduce clutter.

////////////////////////////////////////////////////////////////
typedef
    signed int /** VkResult **/ 
    ( __stdcall * F55_PFN_vkCreateDebugUtilsMessengerEXT )(

    void*        /** VkInstance --------------**/   
    instance
    ,
    const struct
    F35_VkDebugUtilsMessengerCreateInfoEXT*   
    pCreateInfo
    ,
    const void*  /** VkAllocationCallbacks    **/   
    pAllocator
    ,
    //:VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugUtilsMessengerEXT)
    void*  /** VkDebugUtilsMessengerEXT **/   
    pMessenger

    );
    F55_PFN_vkCreateDebugUtilsMessengerEXT
    F55_FUN_vkCreateDebugUtilsMessengerEXT=NULL;
////////////////////////////////////////////////////////////////

    typedef
        F02_VOF //:RET:GenericFuncPtr
        (*F55_PFN_vkCreateWin32SurfaceKHR )(
            void*       vk_instance   /**VkInstance:instance**/
        ,   
            struct F20_VkWin32SurfaceCreateInfoKHR*
            create_info
        ,
            const void* /** VkAllocationCallbacks **/
            pAllocator
        ,
            void* /** VkSurfaceKHR / F20_VkSurfaceKHR **/
            pSurface
        );

    F55_PFN_vkCreateWin32SurfaceKHR  
    F55_FUN_vkCreateWin32SurfaceKHR =NULL;

////////////////////////////////////////////////////////////////
static void 
f55_Halt( const char* msg ){ 
    printf( "[f60_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//

static void
f55_SRC( F02_VOF func_ptr, const char* on_err_msg ){

    if(NULL==func_ptr){
        printf("[f55_SRC:NULL!MSG=]:%s\n", on_err_msg);
        f55_Halt("[SEE_MESSAGE_TAGGED:f55_SRC]");
    };;

}//[;]//

static void
f55_DST( F02_VOF func_ptr, const char* on_err_msg ){

    if(NULL==func_ptr){
        printf("[f55_DST:NULL!MSG=]:%s\n", on_err_msg);
        f55_Halt("[SEE_MESSAGE_TAGGED:f55_DST]");
    };;

}//[;]//


//:R:Reload
//[RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR]//

static void
f55_RLIFPTST_ValidationLayerFunctions( void ){

    #define V F02_VOF //////////////////////////////////////////

    //:Check source pointers for null:
    f55_SRC( (V)F50_vkCreateDebugUtilsMessengerEXT , "[A]");

    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - //

    F55_FUN_vkCreateDebugUtilsMessengerEXT=(
  ( F55_PFN_vkCreateDebugUtilsMessengerEXT )
        F50_vkCreateDebugUtilsMessengerEXT
    );;

    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - //

    //:Check destination pointers for null:
    f55_DST( (V)F55_FUN_vkCreateDebugUtilsMessengerEXT , "[A]");

    #undef  V //////////////////////////////////////////////////

}//[;]//
static void
f55_RLIFPTST_NOTDEBUG_InstanceExtensionFunctions( void ){

    #define V F02_VOF //////////////////////////////////////////

    //:Check source pointers for null:
    f55_SRC( (V)F50_vkCreateWin32SurfaceKHR        , "[B]");

    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - //

    F55_FUN_vkCreateWin32SurfaceKHR=(
  ( F55_PFN_vkCreateWin32SurfaceKHR )
        F50_vkCreateWin32SurfaceKHR
    );;

    //- - - - - - - - - - - - - - - - - - - - - - - - - - - - //

    //:Check destination pointers for null:
    f55_DST( (V)F55_FUN_vkCreateWin32SurfaceKHR        , "[B]");

    #undef  V //////////////////////////////////////////////////

}//[;]//

static void
f55_ReLoadInstanceFunctionPointersToSpecificTypes( void ){

    if( f40_use_validation_layers > 0 ){
        //: RLIFPTST:
        //: ReLoadInstanceFunctionPointersToSpecificTypes
        //: R L   I       F       P       T S       T
        f55_RLIFPTST_ValidationLayerFunctions();
    };;

    f55_RLIFPTST_NOTDEBUG_InstanceExtensionFunctions();

}//[;]//

//[RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F55_Init(){
        printf("[BEG:F55:Init]\n");

        //:Get instance function pointers:
        int ret = F50_Init(); //: ".SUPER_CHAIN()"

        //## f55 init logic goes AFTER super!!! ##//
        //:Initialize re-casted function pointers:
        f55_ReLoadInstanceFunctionPointersToSpecificTypes();


        printf("[END:F55:Init]\n");
        return( ret );
    }//[;]//
    int F55_Main(){

        printf("[F55_Main:Before:F55_Init()]\n");

        F55_Init();

        printf("[F55_Main:Afterr:F55_Init()]\n");

        //:Stand in for a renderloop, so that program does
        //:not immediately exit and you never see window and
        //:assume error is in your code.
        printf("[F55:TO_EXIT:CTRL+C]\n");
        fflush(stdout );


        while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//





//#FILE_REGION[ F.55 ]END#####################################//
//#FILE_REGION[ F.60 ]BEG#####################################//

//:
//: DOTADIW: VULKAN_INIT_PART_02
//:          Setting up debug callback for validation layers.
//:   

      //:F20_VkDebugUtilsMessengerEXT
void* //:AKA: DECLARE_HANDLE( VkDebugUtilsMessengerEXT )
f60_debug_utils_messenger = NULL;


////////////////////////////////////////////////////////////////
//:First function always "Halt":
static void 
f60_Halt( const char* msg ){ 
    printf( "[f60_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
static void
f60_DebugMessage( const char* msg ){
    printf( "[f60_DMSG]:%s\n", msg ); //:DMSG:Debug_MeSsaGe
    fflush(stdout);
}//[;]//
////////////////////////////////////////////////////////////////

// static int //:NOOP: No-operation.
// f60_NOOP1( void* arg1 ){ 
//     if( arg1 ){ /** NOOP **/ };
//     return( 0 );
// }//[;]//


//:PG[55]SC[VKT2018]
static unsigned int __stdcall
f60_debugCallback(
/* ------ */  
/* ------ */      /** VkDebugUtilsMessageSeverityFlagBitsEXT **/
/* ------ */      signed int 
/* ------ */      messageSeverity
/* ------ */  
/* ------ */      /** VkDebugUtilsMessageTypeFlagsEXT        **/
/* ------ */  ,   signed int
/* ------ */      messageType
/* ------ */  
/* ------ */  ,   const struct 
/* ------ */      F20_VkDebugUtilsMessengerCallbackDataEXT* 
/* ------ */      pCallbackData
/* ------ */  
/* ------ */  ,   void* 
/* ------ */      pUserData
/* ------ */  
){
    printf("[DO_WE_GET_HERE?]\n");
    fflush(stdout);

    if( messageSeverity ){ /** NOOP **/ };
    if( messageType     ){ /** NOOP **/ };
    if( pUserData       ){ /** NOOP **/ };
    
    if(NULL==pCallbackData){
        f60_Halt("[NullCallbackData]");
    };;

    printf("[Validation_Layer]:%s\n", pCallbackData->pMessage);

    return( 0 /** VK_FALSE **/ ); //:<<<<SupposedToDoThis
    //return( 1 /** VK_TRUE **/ );

}//[;]//
////////////////////////////////////////////////////////////////
//:  Picking up from where we left off with                  ://
//:  f40_OpenWindowAndInitializeEngine after a               ://
//:  short intermission to gather vulkan instance funcs.     ://
static void
f60_EngineInit_PART2_WindowAlreadyOpen( void ){
f60_DebugMessage( "[BEG:f60_EngineInit_PART2_WAO]" );

    //:BOOK_PAGE[57]://
    /** f40_MACRO_use_validation_layers **/
    if( f40_use_validation_layers > 0 ){

        printf("[SEE[ debug-layer-crash-(01|02|03|04) ]]\n");
        f60_Halt("[VALIDATION_LAYERS_WILL_CRASH]");
        

        struct F35_VkDebugUtilsMessengerCreateInfoEXT
        create_info={ 0 };

        /** VK_STRUCTURE_TYPE: 1000128004          **/
        /** DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT  **/
        create_info.sType = 1000128004;
        create_info.messageSeverity=(
         0 /** VK_DEBUG_UTILS_MESSAGE_SEVERITY_*_EXT **/
            | 0x00000001 /** VERBOSE_BIT **/
            | 0x00000100 /** WARNING_BIT **/
            | 0x00001000 /** ERROR_BIT   **/
        |0);;
        create_info.messageType     =(
         0 /** VK_DEBUG_UTILS_MESSAGE_TYPE_*_EXT **/
            | 0x00000001 /** GENERAL_BIT     **/
            | 0x00000002 /** VALIDATION_BIT  **/
            | 0x00000004 /** PERFORMANCE_BIT **/
        |0);;
        create_info.pfnUserCallback =&( f60_debugCallback );
        create_info.pUserData       = NULL; /** Optional **/

        printf("[TODO:vkGetInstanceProcAddr, page 58]\n");
        if( create_info.sType != 1000128004  ){ 
            f40_Halt("[sType!=1000128004]\n");
        };;

        //:Check on what could go wrong with calling:
        //:F50_vkCreateDebugUtilsMessengerEXT
        ////////////////////////////////////////////////////////
        if(NULL==F50_vkCreateDebugUtilsMessengerEXT){
            f60_Halt("[NULL:CDUME]");
        };;
        if(NULL==F55_FUN_vkCreateDebugUtilsMessengerEXT){
            f60_Halt("[NULL:CDUME:Strict]");
        };;
        if(NULL==f40_instance){ f60_Halt("[NULL:INST]"); }

        ////////////////////////////////////////////////////////

        f60_DebugMessage("[BEF:vk_CDUME]"); //:BEF:BEFORE

        //: vulkan_core.h ___________________________________://
        //|    VKAPI_ATTR VkResult                           |//
        //|    VKAPI_CALL vkCreateDebugUtilsMessengerEXT(    |//
        //|                                                  |//
        //|        VkInstance                                |// 
        //|        instance,                                 |//
        //|                                                  |//
        //|        const VkDebugUtilsMessengerCreateInfoEXT* |// 
        //|        pCreateInfo,                              |//
        //|                                                  |//
        //|        const VkAllocationCallbacks*              |// 
        //|        pAllocator,                               |//
        //|                                                  |//
        //|        VkDebugUtilsMessengerEXT*                 |//  
        //|        pMessenger                                |//
        //|    );                                            |//
        //:--------------------------------------------------://

        //: https://github.com/KhronosGroup/Vulkan-ValidationLayers/
        //:       issues/134
        //: Crash when enabling EXT_debug_utils and 
        //: EXT_debug_report concurrently #134

        //:PAGE[58]VKTUT2018PDF
        int res=
        F55_FUN_vkCreateDebugUtilsMessengerEXT(
            f40_instance    /** VkInstance  **/
        ,   &(create_info)  /** pCreateInfo **/
        ,   (void*)NULL     /** pAllocator  **/
        ,
            /** DECLARE_HANDLE( VkDebugUtilsMessengerEXT )   **/
            /** F20_VkDebugUtilsMessengerEXT* : pMessenger   **/
            /** pMessenger is just a void* to opaque type.   **/
            f60_debug_utils_messenger 
        );;

        f60_DebugMessage("[AFT:vk_CDUME]"); //:AFT:AFTER

        if( res!=0 /**VK_SUCCESS**/ ){ f60_Halt("[A]"); };
        if( NULL==f60_debug_utils_messenger){ f60_Halt("[B]");};

    };;

f60_DebugMessage( "[END:f60_EngineInit_PART2_WAO]" );
}//[;]//


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F60_Init(){
        printf("[BEG:F60:Init]\n");

        //:Get instance function pointers:
        int ret = F55_Init(); //: ".SUPER_CHAIN()"


        f60_EngineInit_PART2_WindowAlreadyOpen();

        printf("[END:F60:Init]\n");
        return( ret );
    }//[;]//
    int F60_Main(){

        printf("[F60_Main:Before:F60_Init()]\n");

        F60_Init();

        printf("[F60_Main:Afterr:F60_Init()]\n");

        //:Stand in for a renderloop, so that program does
        //:not immediately exit and you never see window and
        //:assume error is in your code.
        printf("[F60:TO_EXIT:CTRL+C]\n");
        fflush(stdout );


        while( 1 ){ }; //:LOOP_FOREVER

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//

//#FILE_REGION[ F.60 ]END#####################################//
//#FILE_REGION[ F.61 ]BEG#####################################//

//############################################################//
//##  F61: Creating window surface:                         ##//
//##  (Originally F45, but realize in wrong place)          ##//
//############################################################//

//: DOTADIW: WIN32_SURFACE
//:         ( Create Window Surface )

  
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
void*  /** F20_VkSurfaceKHR / VkSurfaceKHR **/
F61_vulkan_surface = NULL;

//: NOTE_01: VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)
//:
//: NOTE_02: "VkWin32SurfaceKHR" does not exist!
//:           You made that up!!!!!!!!!!!!!
//: NOTE_03:
//: Pretty sure VkSurfaceKHR wrapps/abstracts what type
//: of operating system it is for, so there is no need
//: to create a "F61_win32_surface" and "F61_linux_surface"
//: or something like that.
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

////////////////////////////////////////////////////////////////

//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
/** ---- **/                                        /** ---- **/
/** ---- **/    //:First function always "Halt":    /** ---- **/
/** ---- **/    static void                         /** ---- **/
/** ---- **/    f61_Halt( const char* msg ){        /** ---- **/
/** ---- **/        printf(                         /** ---- **/
/** ---- **/            "[f61_Halt]:%s\n", msg      /** ---- **/
/** ---- **/        );;                             /** ---- **/
/** ---- **/        fflush(stdout); exit(666);      /** ---- **/
/** ---- **/    }//[;]//                            /** ---- **/
/** ---- **/                                        /** ---- **/
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

static void
f61_PrivateInit_CreateWindowSurface( void ){

    struct F20_VkWin32SurfaceCreateInfoKHR 
    ci = {0};

    ci.sType     = 1000009000; //:WIN32_SURFACE_CREATE_INFO
    ci.hwnd      = F09_GetHWND();
    ci.hinstance = F09_GetHINSTANCE();

    //:VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR 
    //:==[1000009000]

    ////////////////////////////////////////////////////////////
    if( ci.sType != 1000009000 ){
        f61_Halt("[NOOP_disguised_as_error_check]");
    };;
    if(NULL==F55_FUN_vkCreateWin32SurfaceKHR){
        f61_Halt("[NULL:F55_FUN_vkCreateWin32SurfaceKHR]");
    };;
    ////////////////////////////////////////////////////////////

    int res=(int)(unsigned long long)(
    /**/   F55_FUN_vkCreateWin32SurfaceKHR(
    /**/       f40_instance
    /**/       
    /**/       /** createInfo / VkWin32SurfaceCreateInfoKHR **/
    /**/   ,   &( ci ) 
    /**/   ,   NULL
    /**/   ,   &( F61_vulkan_surface )
    /**/   )
    );;
    
    if( res != 0 /** VK_SUCCESS **/ ){
        f61_Halt("[FailedToCreateWin32Surface]");
    }else{
        printf("[OK:MADE:F61_vulkan_surface]\n");
    };;
    
    if(NULL == F61_vulkan_surface ){
        f61_Halt("[I_Take_It_Back:win32_surface_create_fail]");
    };;

}//[;]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F61_Init(){
        printf("[BEG:F61:Init]\n");

            ////////////////////////////////////////////////////

            //: ".SUPER_CHAIN()"
            int ret = F60_Init(); 

            //: LAST_ITEM_IN_CODE_CHAIN:
            f61_PrivateInit_CreateWindowSurface();

            ////////////////////////////////////////////////////

        printf("[END:F61:Init]\n");
        return( ret );
    }//[;]//
    int F61_Main(){

        printf("[F61_Main:Before:F61_Init()]\n");
        ////////////////////////////////////////////////////////

        F61_Init();

        ////////////////////////////////////////////////////////
        printf("[F61_Main:Afterr:F61_Init()]\n");


        
        //:RLSI:RENDER_LOOP_STAND_IN
        ////////////////////////////////////////////////////////

        printf("[F61:TO_EXIT:CTRL+C]\n");
        fflush(stdout );
        while( 1 ){ }; //:LOOP_FOREVER

        ////////////////////////////////////////////////////////

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


//#FILE_REGION[ F.61 ]END#####################################//

//#FILE_REGION[ F.62 ]BEG#####################################//

//:DOTADIW: PHYDEV_SELECT
//:        ( vulkan_chapter_seven:   )
//:        (Physical Device Selection)

//:When more confident, we increment file numbers by 2
//:instead of 10. Confident in not making more insertion
//:files between numbers.

//:PUBLIC_VARS:
//:PVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPV://
#define VAR_01 void*
#define VAR_02 struct F20_VkPhysicalDeviceFeatures   ///////////
#define VAR_03 struct F20_VkPhysicalDeviceProperties ///////////
#define VAR_04 struct F20_VkQueueFamilyProperties    ///////////
#define VAR_05 struct F20_VkQueueFamilyProperties    ///////////
#define VAR_06 int                                   ///////////
#define VAR_07 unsigned int                          ///////////
#define VAR_08 unsigned int                          ///////////

    VAR_01  F62_physical_device;
    VAR_02  F62_physical_device_features;
    VAR_03  F62_physical_device_properties;

    VAR_04  F62_qfp_graphics  ; //:qfp:queue_family_properties
    VAR_05  F62_qfp_compute   ;
    VAR_06  F62_qfp_graphics_and_compute_are_same_object;

    VAR_07  F62_qfi_graphics  ; //:qfi:queue_family_index
    VAR_08  F62_qfi_compute   ;

#undef  VAR_01  ////////////////////////////////////////////////
#undef  VAR_02  ////////////////////////////////////////////////
#undef  VAR_03  ////////////////////////////////////////////////
#undef  VAR_04  ////////////////////////////////////////////////
#undef  VAR_05  ////////////////////////////////////////////////
#undef  VAR_06  ////////////////////////////////////////////////
#undef  VAR_07  ////////////////////////////////////////////////
#undef  VAR_08  ////////////////////////////////////////////////
//:PVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPVPV://


//:The choosen physical device:
////////////////////////////////////////////////////////////////

    void*
    F62_physical_device = NULL; 
    /** physicalDevice : DEFINE_HANDLE( VkPhysicalDevice ) **/

////////////////////////////////////////////////////////////////

//:Features of the choosen physical device:
////////////////////////////////////////////////////////////////

    struct F20_VkPhysicalDeviceFeatures
    F62_physical_device_features={0};
    
////////////////////////////////////////////////////////////////

//:Properties of the choosen physical device:
////////////////////////////////////////////////////////////////

    struct F20_VkPhysicalDeviceProperties
    F62_physical_device_properties={0};

////////////////////////////////////////////////////////////////

//:Queue Family Properties Of Physical Device:
////////////////////////////////////////////////////////////////

    #define QFP struct F20_VkQueueFamilyProperties  ////////////
            
    QFP     F62_qfp_graphics = { 0 };
    QFP     F62_qfp_compute  = { 0 };
    int     F62_qfp_graphics_and_compute_are_same_object=0;

    #undef QFP /////////////////////////////////////////////////

    //:qfi:Queue_Family_Index:
    #define U32 unsigned int ///////////////////////////////////

            U32     F62_qfi_graphics = (777); //:#ITIV
            U32     F62_qfi_compute  = (888); //:#ITIV#

    #undef  U32 ////////////////////////////////////////////////

////////////////////////////////////////////////////////////////

            
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
/** ---- **/                                        /** ---- **/
/** ---- **/    //:First function always "Halt":    /** ---- **/
/** ---- **/    static void                         /** ---- **/
/** ---- **/    f62_Halt( const char* msg ){        /** ---- **/
/** ---- **/        printf(                         /** ---- **/
/** ---- **/            "[f62_Halt]:%s\n", msg      /** ---- **/
/** ---- **/        );;                             /** ---- **/
/** ---- **/        fflush(stdout); exit(666);      /** ---- **/
/** ---- **/    }//[;]//                            /** ---- **/
/** ---- **/                                        /** ---- **/
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

////////////////////////////////////////////////////////////////

static void
f62_PrivateInitChapterSeven_07( void ){

    unsigned int device_count = 0;

    ((F03_03)F02_vkEnumeratePhysicalDevices)(
        f40_instance
    ,   &device_count
    ,   NULL
    );;

    if( 0==device_count ){
        f62_Halt("[No_Physical_Devices]");
    }else{
        printf("[WE_HAVE_THIS_MANY_DEVICES]:%d\n"
            ,device_count
        );;fflush(stdout);
    };;

    //:Skip this bullshit for now, we only have 1 device
    //:on our ZOTAC machine. -[JMIM.2019.12.14]
    if( device_count != 1 ){

        f62_Halt("[MUST_ADD:ChooseCorrectDeviceFromMany]");

        //:ADD the "isDeviceSuitable" method from page 62
        //:of SC[ VKTUTPDF2018 ]

    };;

    //:Create temporary device array:
    //:int one = sizeof( void* ); /** one: VkPhysicalDevice **/
    //:int num = device_count;    /** num/amt of elements.  **/
    //:int all = malloc( one * num );
    void** arr = calloc( device_count, sizeof( void* ) );

    ((F03_03)F02_vkEnumeratePhysicalDevices)(
        f40_instance
    ,   &device_count
    ,   arr //:array of devices to populate.
    );;

    //[[  [HACK]:Just take the first device ]]//
    F62_physical_device = arr[ 0 ];

    if( NULL == F62_physical_device ){
        f62_Halt("[OhFuck]");
    }else{
        printf("[WeGotOurPhysicalDeviceBoys!]\n");
        fflush(stdout);
    };;

    //:Device Features:
    ////////////////////////////////////////////////////////////
    ((F03_02)F02_vkGetPhysicalDeviceFeatures)(
          F62_physical_device
    ,   &(F62_physical_device_features)
    );;

    if( F62_physical_device_features.shaderInt64 != 1 ){

        f62_Halt("[NOT_SUPPORTED:shaderInt64]");
    
    }else{

        printf("[SUPPORTED:shaderInt64]\n");
        fflush(stdout);
    
    };;
    ////////////////////////////////////////////////////////////


    //:Device Properties:
    ////////////////////////////////////////////////////////////
    ((F03_02)F02_vkGetPhysicalDeviceProperties)(
          F62_physical_device
    ,   &(F62_physical_device_properties)
    );;

    int DT = F62_physical_device_properties.deviceType;
    if( 11 
        && (1 != DT) //:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU 
        && (2 != DT) //:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU 
        && (3 != DT) //:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU 
    ){

        f62_Halt("[I_NEED_A_FUCKING_GPU]");
    
    }else{

        printf("[I_HAVE_A_FUCKING_GPU]\n");
        fflush(stdout);
    
    };;

        //:Id like to see what my texture limit is:
        ////////////////////////////////////////////////////////

        int lim =( F62_physical_device_properties.
                   limits.maxImageDimension2D );;

        printf("[maxImageDimension2D]:%d\n", lim); //:16384
        //: 16384 / 2 == 8192
        //:  8192 / 2 == 4096
        //:  4096 / 2 == 2048
        //:  2048 / 2 == 1024
        //:  1024 / 2 == 512
        //:   512 / 2 == 256 ......

        ////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////

    //:Queue Families:
    ////////////////////////////////////////////////////////////

        //:Making assumption that opaque handle would not
        //:evaluate to [ NULL | 0 ] if valid.
        if(NULL == F62_physical_device){
            f62_Halt("[NULL:PD]");
        };;
        if(NULL== F02_vkGetPhysicalDeviceQueueFamilyProperties){
            f62_Halt("[NULL:GET_PDQFP]");
        };;
            
        struct F20_VkQueueFamilyProperties*
        qfp_arr=NULL;
        
        unsigned int
        qfp_num = 0;
        
        ((F03_03)F02_vkGetPhysicalDeviceQueueFamilyProperties)(
        
            F62_physical_device
        
        ,           &( qfp_num )
        ,   NULL    //:qfp_arr
        );;
        
        //:Allocate Space For qfp objects:
        //:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC://
        printf("[qfp_num]:%d\n", qfp_num );fflush(stdout);
        int qfp_one = sizeof( 
            struct F20_VkQueueFamilyProperties
        );;
        qfp_arr = calloc( qfp_num, qfp_one );
        if(NULL==qfp_arr){ f62_Halt("[FUCK_01]"); };
        //:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC://

        ((F03_03)F02_vkGetPhysicalDeviceQueueFamilyProperties)(
        
            F62_physical_device
        
        ,           &( qfp_num )
        ,              qfp_arr
        );;

        if(NULL==qfp_arr){ f62_Halt("[FUCK_02]"); };

        printf("[qfp_arr[0].queueFlags]:%d\n"
        ,        qfp_arr[0].queueFlags
        );;fflush(stdout);;

        //:LOOP:
        //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://

        F62_qfp_graphics_and_compute_are_same_object=0;
        int found_graphics = 0;
        int found_compute  = 0;

        struct F20_VkQueueFamilyProperties cur = {0};
      //struct F20_VkQueueFamilyProperties emp = {0};
        for(int dex = 0; dex < (int)qfp_num; dex++ ){
        
            //:Copy memory into cur to take a look:
            cur = qfp_arr[ dex ];
        
            unsigned int f = cur.queueFlags;
            unsigned int c = cur.queueCount;

            printf("\n");
        
                printf("[dex]:%d\n", dex );
                printf("[f,c]:(%d)(%d)\n", f,c);
        
            printf("\n");

            if( 0==(f|c) ){
                f62_Halt("[DataNotLoaded]");
            };;

            //: VK_QUEUE_GRAPHICS_BIT : 0x00000001
            //: VK_QUEUE_COMPUTE_BIT  : 0x00000002
            if( cur.queueFlags & 0x00000001 ){ //:Graphics
            if( cur.queueFlags & 0x00000002 ){ //:Compute

                F62_qfp_graphics = cur;
                F62_qfp_compute  = cur;
                F62_qfp_graphics_and_compute_are_same_object=1;
                
                found_graphics=1;
                found_compute =1;

                F62_qfi_graphics = dex;
                F62_qfi_compute  = dex;

                break; 
            };;};;

            if( cur.queueFlags & 0x00000001 ){ //:Graphics
                F62_qfp_graphics = cur;
                  found_graphics = 1;
                F62_qfi_graphics = dex;
            };;
            if( cur.queueFlags & 0x00000002 ){ //:Compute
                F62_qfp_compute  = cur;
                  found_compute  = 1;
                F62_qfi_compute  = dex;
            };; 
                
        };;fflush(stdout);

        if(0==(found_graphics|found_compute)){
            f62_Halt("[DidNotFindBoth:QFP]");
        }else{
            printf("[QFP(s):Found]");
            fflush(stdout);
        };;

        //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://

    ////////////////////////////////////////////////////////////
    
    free( qfp_arr );
    free( arr     );
    return;
}//[;]//

////////////////////////////////////////////////////////////////

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F62_Init(){
        printf("[BEG:F62:Init]\n");

            ////////////////////////////////////////////////////

            //: ".SUPER_CHAIN()"
            int ret = F61_Init(); 

            //: LAST_ITEM_IN_CODE_CHAIN:
            f62_PrivateInitChapterSeven_07();

            ////////////////////////////////////////////////////

        printf("[END:F62:Init]\n");
        return( ret );
    }//[;]//
    int F62_Main(){

        printf("[F62_Main:Before:F62_Init()]\n");
        ////////////////////////////////////////////////////////

        F62_Init();

        ////////////////////////////////////////////////////////
        printf("[F62_Main:Afterr:F62_Init()]\n");


        
        //:RLSI:RENDER_LOOP_STAND_IN
        ////////////////////////////////////////////////////////

        printf("[F62:TO_EXIT:CTRL+C]\n");
        fflush(stdout );
        while( 1 ){ }; //:LOOP_FOREVER

        ////////////////////////////////////////////////////////

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


    //: #ITIV# : Init_To_Invalid_Value

//#FILE_REGION[ F.62 ]END#####################################//

//#FILE_REGION[ F.63 ]BEG#####################################//

//:DOTADIW: GET_PRESENT_Q
//:         ( Get present queue: )

//: Other queues are in file: "F.62" / F62_*


#define QFP struct F20_VkQueueFamilyProperties /////////////////
#define QFI unsigned int //:queue_family_index /////////////////


        //:For presenting images to screen:
        //:(graphics and compute are in: "F.62" / F62_*
        QFP    F63_qfp_present ;
        QFI    F63_qfi_present ;


#undef  QFP ////////////////////////////////////////////////////
#undef  QFI ////////////////////////////////////////////////////

//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
/** ---- **/                                        /** ---- **/
/** ---- **/    //:First function always "Halt":    /** ---- **/
/** ---- **/    static void                         /** ---- **/
/** ---- **/    f63_Halt( const char* msg ){        /** ---- **/
/** ---- **/        printf(                         /** ---- **/
/** ---- **/            "[f63_Halt]:%s\n", msg      /** ---- **/
/** ---- **/        );;                             /** ---- **/
/** ---- **/        fflush(stdout); exit(666);      /** ---- **/
/** ---- **/    }//[;]//                            /** ---- **/
/** ---- **/                                        /** ---- **/
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//


static void
f63_PrivateInit( void ){

    //:Does the current queue_family_index support
    //:presenting an image to the screen?
    unsigned int /** VkBool32 **/
    supports_present = 0;

    void* res_as_void = NULL;

    unsigned int 
    res = 0;

    struct F20_VkQueueFamilyProperties*
    qfp_arr=NULL;

    int
    qfp_one=0; //:The size of one element in qfp_arr.
    
    unsigned int
    qfp_num = 0;

    unsigned int
    qfp_dex = 0; //: queue_family_index

    int found = 0;

    ////////////////////////////////////////////////////////////

    //:GET: qfp_num && qfp_arr 
    //:NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN://
    ((F03_03)F02_vkGetPhysicalDeviceQueueFamilyProperties)(
        F62_physical_device, &( qfp_num ), NULL
    );;
    qfp_one = sizeof( struct F20_VkQueueFamilyProperties );
    qfp_arr = calloc( qfp_num, qfp_one );
    ((F03_03)F02_vkGetPhysicalDeviceQueueFamilyProperties)(
        F62_physical_device, &( qfp_num ), qfp_arr
    );;
    //:NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN://

    //:LOOP_USING:[ qfp_arr && qfp_dex && qfp_num ]
    //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://
    for( qfp_dex = 0; qfp_dex < qfp_num; qfp_dex++ ){ //////////

        res_as_void =(((F03_04) ///////////////////////////////
        F50_vkGetPhysicalDeviceSurfaceSupportKHR)(

            /** physicalDevice **/
            F62_physical_device 
        ,   
            /** queue_family_index / queueFamilyIndex **/
            (void*)(unsigned long long)
            qfp_dex  
        ,
            /** VkSurfaceKHR  surface **/
            F61_vulkan_surface 
        ,
            /** VkBool32*  pSupported **/
            &( supports_present ) 

        ));; ///////////////////////////////////////////////////

        res = (int)(unsigned long long)res_as_void;

        //:Even if current queue_family_index does NOT support
        //:what you are looking for, this command should
        //:still WORK!
        if( res != 0 /** VK_SUCCESS **/ ){
            f63_Halt("[CRASH:GPDSS]");
        };;

        if( supports_present ){

            found=1;
            F63_qfp_present = qfp_arr[ qfp_dex ];
            F63_qfi_present =          qfp_dex  ;

            break;
        };;
    
    };; ////////////////////////////////////////////////////////
    //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://

    if(found != 1 ){
        f63_Halt( "[UNABLE_TO_FIND_PRESENT_QUEUE]" );
    }else{
        printf("[F63:FOUND_PRESENTATION_QUEUE_INFO]\n");
        fflush(stdout);;
    };;

    free( qfp_arr );
}//[;]//

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F63_Init(){
        printf("[BEG:F63:Init]\n");

            ////////////////////////////////////////////////////

            int ret = F62_Init();  //: ".SUPER_CHAIN()"
            f63_PrivateInit();     //: ".LAST_INVOKED_LINK"

            ////////////////////////////////////////////////////

        printf("[END:F63:Init]\n");
        return( ret );
    }//[;]//
    int F63_Main(){

        F63_Init();

        //:RLSI:RENDER_LOOP_STAND_IN
        ////////////////////////////////////////////////////////

        printf("[F63:TO_EXIT:CTRL+C]\n");
        fflush(stdout );
        while( 1 ){ }; //:LOOP_FOREVER

        ////////////////////////////////////////////////////////

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


//#FILE_REGION[ F.63 ]BEG#####################################//
//#FILE_REGION[ F.64 ]BEG#####################################//

//:DOTADIW: MAK_LOGIC_DEV
//:        (make logical device)
//:        (chapter_8_of_vulkan_tutorial )

////////////////////////////////////////////////////////////////

    void*  /** VK_DEFINE_HANDLE(VkDevice) **/
    F64_logical_device = NULL;

    struct F20_VkPhysicalDeviceFeatures
    F64_enabled_logical_device_features = { 0 };

    int*  F64_qfi_unique_set    =NULL;
    int   F64_qfi_unique_set_len= 0  ;


//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
/** ---- **/                                        /** ---- **/
/** ---- **/    //:First function always "Halt":    /** ---- **/
/** ---- **/    static void                         /** ---- **/
/** ---- **/    f64_Halt( const char* msg ){        /** ---- **/
/** ---- **/        printf(                         /** ---- **/
/** ---- **/            "[f64_Halt]:%s\n", msg      /** ---- **/
/** ---- **/        );;                             /** ---- **/
/** ---- **/        fflush(stdout); exit(666);      /** ---- **/
/** ---- **/    }//[;]//                            /** ---- **/
/** ---- **/                                        /** ---- **/
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

////////////////////////////////////////////////////////////////
static int f64_NOOP0(void){ return( 1 ); }

static void
f64_AllocateArrayOfUniqueQueueIndicies( void ){

    printf("[BEG:AAOUQI]"); fflush(stdout);

    int Q_01 = F62_qfi_graphics;  //: qfi[ qfi_ptr=0 ] == Q_01
    int Q_02 = F62_qfi_compute ;  //: qfi[ qfi_ptr=1 ] == Q_02
    int Q_03 = F63_qfi_present ;  //: qfi[ qfi_ptr=2 ] == Q_03

    #define  MACRO_QFI_LEN 3 ///////////////////////////////////
    int qfi[ MACRO_QFI_LEN ]={
        Q_01
    ,   Q_02
    ,   Q_03
    };;//[qinit]//

    //:Empty Set:
    int set_dat[3]={-1,-2,-3};
    int set_len   = 0;
    
    

    int qfi_ptr =( 0-1 );
    int max_dex = (MACRO_QFI_LEN-1);
    while( 1 ){
        qfi_ptr++;
        if( qfi_ptr > max_dex ){ break; }
        
        //:Loop through all set entries:
        int already_exists = 0;
        int potential_set_entry = qfi[ qfi_ptr ];
        for( int se = 0; se < set_len; se++ ){

            if( potential_set_entry == qfi[ se ] ){
                already_exists = 1;
            };;
        };;
        
        if( 0==already_exists ){
            set_dat[ set_len ] = potential_set_entry;
                     set_len++ ;
        };;//[ae]//
    };;//[w1]//
    
    #undef  MACRO_QFI_LEN //////////////////////////////////////

    //:Copy data into malloced array:
    F64_qfi_unique_set      = calloc( set_len, sizeof(int) );
    F64_qfi_unique_set_len  = set_len;
    for( int se = 0; se < set_len; se++ ){
        F64_qfi_unique_set[ se ] = set_dat[ se ];
        printf("[ENTRY]%d [VALUE]%d \n", se, set_dat[ se ] );;
    };;//[cd]//

    printf("[Q_01]%d\n", Q_01 );
    printf("[Q_02]%d\n", Q_02 );
    printf("[Q_03]%d\n", Q_03 );
       
    printf("[END:AAOUQI]"); fflush(stdout);

}//[;]//

static void
f64_PrivateInitChapterEight_08( void ){

    if( f64_NOOP0() != 1 ){ f64_Halt("[X_X]"); };

    //********************************************************//
    //:PAGE 75 says you need one of these structs for         //
    //:each queue type you want to make.                      //
    //:(one F20_VkDeviceQueueCreateInfo per queue made)       //
    //:(Unless the queue indices for two or more of your)     //
    //:(queue types (graphics,compute,present) are identical  //
    //:indicies.                                              //
    //********************************************************//
    // struct F20_VkDeviceQueueCreateInfo ci_qqq ={0};
    // ci_qqq.sType = 2; /** DEVICE_QUEUE_CREATE_INFO **/
    // ci_qqq.queueFamilyIndex = F62_qfi_graphics;
    // ci_qqq.queueCount       = 1;
    // float queue_priority = 1.0f; //:Array of 1 element.
    // ci_qqq.pQueuePriorities = &(queue_priority);
    //********************************************************//

    f64_AllocateArrayOfUniqueQueueIndicies();
    struct F20_VkDeviceQueueCreateInfo*
    ci_qqq_POINTER=(
        calloc(     
            F64_qfi_unique_set_len
        ,   sizeof( struct F20_VkDeviceQueueCreateInfo)
        )
    );;
    for( int i = 0; i < F64_qfi_unique_set_len; i++ ){
        #define PTR ci_qqq_POINTER /////////////////////////////

        PTR[i].sType = 2; /** DEVICE_QUEUE_CREATE_INFO **/

        //:Example: F62_qfi_graphics
        PTR[i].queueFamilyIndex =(
            F64_qfi_unique_set[ i ]
        );;

        //:Number of queues from this qfi(queue_family_index)
        //:you are requesting.
        PTR[i].queueCount       = 1;

        float queue_priority = 1.0f; //:Array of 1 element.
        PTR[i].pQueuePriorities = &(queue_priority);

        #undef  PTR  ///////////////////////////////////////////
    };;

    //:QUESTION:
    //:Why does tutorial8 want VkPhysicalDeviceFeatures? 
    //:We already created
    //:F62_physical_device_features when creating our
    //:physical device in previous file.        
    //:( VK_PDF / VkPhysicalDeviceFeatures )
    //:
    //:ANSWER:
    //:F62_physical_device_features : 
    //:         What hardware CAN do.
    //:
    //:F64_enabled_logical_device_features:
    //:         What tasks you require of the logical
    //:         abstraction of that hardware.
    //:        
    //:         Example: I may be able to:
    //:              1: lift 50 LBS
    //:              2; program
    //:
    //:         But as a logical device working for
    //:         five guys burgers and fries, they only need
    //:         to enable "LIFTING" but not "PROGRAMMING".
    ////////////////////////////////////////////////////////////

    //: F64_enabled_logical_device_features  (See top of file)

    ////////////////////////////////////////////////////////////

    //: ci_qqq_POINTER=NULL; CAUSE_CRASH_TO_MAKE_SURE_WORKING

    struct F20_VkDeviceCreateInfo ci_dev = { 0 };
    ci_dev.sType = 3; /** DEVICE_CREATE_INFO **/

//: ci_dev.pQueueCreateInfos = &( ci_qqq ); //:<<<ARRAY!
    ci_dev.pQueueCreateInfos =  ( ci_qqq_POINTER );

    ci_dev.queueCreateInfoCount = F64_qfi_unique_set_len;
    ci_dev.pEnabledFeatures = &( 
        F64_enabled_logical_device_features
    );;

    int res =(

        (int)(unsigned long long)

        ((F03_04)F02_vkCreateDevice)(
        /**/      F62_physical_device
        /**/    , &( ci_dev )
        /**/    , NULL
        /**/    ,&( F64_logical_device )
        )
    );;
    if( res != 0 /** VK_SUCCESS **/ ){
        f64_Halt("[FailedToMakeLogicalDevice]");
    }else{
        printf("[LOGICAL_DEVICE_GOT!]\n");
        fflush(stdout);
    };;

    free( ci_qqq_POINTER );
}//[;]//


////////////////////////////////////////////////////////////////

//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F64_Init(){
        printf("[BEG:F64:Init]\n");

            ////////////////////////////////////////////////////

            //: ".SUPER_CHAIN()"
            int ret = F63_Init(); 

            //: LAST_ITEM_IN_CODE_CHAIN:
            f64_PrivateInitChapterEight_08();

            ////////////////////////////////////////////////////

        printf("[END:F64:Init]\n");
        return( ret );
    }//[;]//
    int F64_Main(){

        printf("[F64_Main:Before:F64_Init()]\n");
        ////////////////////////////////////////////////////////

        F64_Init();

        ////////////////////////////////////////////////////////
        printf("[F64_Main:Afterr:F64_Init()]\n");


        
        //:RLSI:RENDER_LOOP_STAND_IN
        ////////////////////////////////////////////////////////

        printf("[F64:TO_EXIT:CTRL+C]\n");
        fflush(stdout );
        while( 1 ){ }; //:LOOP_FOREVER

        ////////////////////////////////////////////////////////

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//



//#FILE_REGION[ F.64 ]END#####################################//

//#FILE_REGION[ F.66 ]BEG#####################################//

//:DOTADIW:  RET_QUEUE_HAN
//:         ( Retrieve Queue Handles )

//:Page 70 of VKTUT_2018_PDF
//:(Just page 70, last page of chapter)
//:(Page 74 hints I should do this for:
//:( graphics, present, and compute )

////////////////////////////////////////////////////////////////

void* /** VK_DEFINE_HANDLE(VkQueue) **/
F66_graphics_queue = NULL;

void* /** VK_DEFINE_HANDLE(VkQueue) **/
 F66_compute_queue = NULL;

void* /** VK_DEFINE_HANDLE(VkQueue) **/
 F66_present_queue = NULL;

////////////////////////////////////////////////////////////////

//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
/** ---- **/                                        /** ---- **/
/** ---- **/    //:First function always "Halt":    /** ---- **/
/** ---- **/    static void                         /** ---- **/
/** ---- **/    f66_Halt( const char* msg ){        /** ---- **/
/** ---- **/        printf(                         /** ---- **/
/** ---- **/            "[f66_Halt]:%s\n", msg      /** ---- **/
/** ---- **/        );;                             /** ---- **/
/** ---- **/        fflush(stdout); exit(666);      /** ---- **/
/** ---- **/    }//[;]//                            /** ---- **/
/** ---- **/                                        /** ---- **/
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

void* /** GQ:GetQueue **/
f66_GQ( 
    unsigned int        qfi /** queue_family_index **/
,   const char*  debug_code /** What queue are you getting? **/
){

    void*
    vulkan_queue_object = NULL;

    //+----------------------------------------------+//
    //| queueIndex must be less than the number of   |//
    //| queues created for the specified queue       |//
    //| family index when device was created,via the |//
    //| queueCount member of the                     |//
    //| VkDeviceQueueCreateInfo structure            |//
    //+----------------------------------------------+//
    ((F03_04)F02_vkGetDeviceQueue)(
    /**/          F64_logical_device

    /**/   ,        (void*)(unsigned long long)
                    qfi //:queueFamilyIndex

    /**/   ,      0 //:queueIndex
    /**/   ,   &( vulkan_queue_object )
    );;

    //:Pass or Fail?
    if(NULL==vulkan_queue_object){
        printf("[FAIL:vulkan_queue_object]:%s\n", debug_code);
        f66_Halt("[GET_QUEUE_FAIL:SEE_ABOVE_THIS_MESSAGE]");
    }else{
      // printf("[Got!:vulkan_queue_object]:%s\n", debug_code);
      // fflush(stdout);
    };;

    return( vulkan_queue_object );

}//[;]//


void f66_PrivateInitPage_70( void ){

    F66_graphics_queue =( f66_GQ( F62_qfi_graphics, "[G]"));
     F66_compute_queue =( f66_GQ( F62_qfi_compute , "[C]"));
     F66_present_queue =( f66_GQ( F63_qfi_present , "[P]"));

    printf("[GOT_QUEUES(GRAPHICS,COMPUTE,PRESENT)]\n");
    fflush(stdout);

}//[;]//


//:IM:Init_And_Main:
//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//
    int F66_Init(){
        printf("[BEG:F66:Init]\n");

            ////////////////////////////////////////////////////

            //: ".SUPER_CHAIN()"
            int ret = F64_Init(); 

            //: LAST_ITEM_IN_CODE_CHAIN:
            f66_PrivateInitPage_70();

            ////////////////////////////////////////////////////

        printf("[END:F66:Init]\n");
        return( ret );
    }//[;]//
    int F66_Main(){

        printf("[F66_Main:Before:F66_Init()]\n");
        ////////////////////////////////////////////////////////

        F66_Init();

        ////////////////////////////////////////////////////////
        printf("[F66_Main:Afterr:F66_Init()]\n");


        
        //:RLSI:RENDER_LOOP_STAND_IN
        ////////////////////////////////////////////////////////

        printf("[F66:TO_EXIT:CTRL+C]\n");
        fflush(stdout );
        while( 1 ){ }; //:LOOP_FOREVER

        ////////////////////////////////////////////////////////

        return( 0 );
    }//[;]//

//[IMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIMIM]//


//#FILE_REGION[ F.66 ]END#####################################//

    //:F70: Chapter 10. Swap Chain. BookPage[ 76 ]

   // **F70_NOTICE_ME_SENPAI**
//#FILE_REGION[ VG03.H ]BEG###################################//
/////////////////////////////////. . . . . . 13
/////////////////////////////////............|
/////////////////////////////////123456789ABCD
//|---- F01 ------|////[ DOTADIW:DLL_FUNC_LIST ]//
//|---- F02 ------|////[ DOTADIW:DLL_FUNC_LOAD ]//
//|-----F03 ------|////[ DOTADIW:DLL_CALL_CAST ]//

//|-----F04 ------|////[ DOTADIW:DLL_STRUCTS   ]//
//|-----F05 ------|////[ DOTADIW:DLL_TYPEDEFS  ]//

//|-----F06 ------|////[ DOTADIW:DLL_PARG_LIST ]//
//|-----F07 ------|////[ DOTADIW:DLL_WRAP_BOIL ]//
//|-----F08 ------|////[ DOTADIW:DLL_WRAP_MAKE ]//

//|-----F09 ------|////[ DOTADIW:MAKE_A_WINDOW ]//
//|-----F10 ------|////[ DOTADIW:WIN_IN_THREAD ]//

//|-----F20 ------|////[ DOTADIW:VULKAN_STRUCT ]//
//|-----F30 ------|////[ DOTADIW:VULKAN_PFN_TD ]//
//|-----F35 ------|////[ DOTADIW:STRUCTS_W_PFN ]//

//|-----F40 ------|////[ DOTADIW:VK_INIT_PART1 ]//
//|-----F50 ------|////[ DOTADIW:VK_INST_FUNCS ]//
//|-----F60 ------|////[ DOTADIW:VK_INIT_PART2 ]//

//|-----F61 ------|////[ DOTADIW:WIN32_SURFACE ]//
//|-----F62 ------|////[ DOTADIW:PHYDEV_SELECT ]//
//|-----F64 ------|////[ DOTADIW:MAK_LOGIC_DEV ]//
//|-----F66 ------|////[ DOTADIW:RET_QUEUE_HAN ]//
    

int
VG03_Demo( void ){
    printf("[BEG:VG03_DEMO]\n");


    //:F10_Main();
    //:F35_Main();
    //:F40_Main();
    //:F50_Main();
    //:F60_Main();
   //F61_Main();
    //:F62_Main();
    //:F64_Main();
    F66_Main();


    printf("[END:VG03_DEMO]\n");
    return( 0 );
}//[;]//

//:WHAT IS WHERE?
//[ F66_graphics_queue ]//

//[ F64_logical_device                  ]//
//[ F64_enabled_logical_device_features ]//

//[ F62_physical_device;                                     ]//
//[ F62_physical_device_features;                            ]//
//[ F62_physical_device_properties;                          ]//
//[                                                          ]//
//[ F62_qfp_graphics  ; //:qfp:queue_family_properties       ]//
//[ F62_qfp_compute   ;                                      ]//
//[ F62_qfp_graphics_and_compute_are_same_object;            ]//
//[                                                          ]//
//[ F62_qfi_graphics  ; //:qfi:queue_family_index            ]//
//[ F62_qfi_compute   ;                                      ]//

//[ F61_vulkan_surface                                       ]//

//[ f60_debug_utils_messenger                                ]//

//[ ... ]//

//#FILE_REGION[ VG03.H ]END###################################//