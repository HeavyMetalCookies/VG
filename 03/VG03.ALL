//| Only choose one to set to 1 |//
#define COMPILE_FOR_windows_10_64bit 1
#if( COMPILE_FOR_windows_10_64bit >= 1 ) //:VGAURD
//////////////////////////////////////////////////

//:PS2_3: Pebwalk_Substitution
//: "_3": More Widdling Away.
//:       Moved from _2 to _3 in order to remove
//:       large chunks of code that are never
//:       executed. (And thus I cannot test the)
//:       (validity of.)


//| 0x00: IMAGE_DATA_DIRECTORY    . VirtualAddress        |//
//| 0x70: IMAGE_OPTIONAL_HEADER   . DataDirectory         |//
//| 0x1C: IMAGE_EXPORT_DIRECTORY  . AddressOfFunctions    |//
//| 0x20: IMAGE_EXPORT_DIRECTORY  . AddressOfNames        |//
//| 0x24: IMAGE_EXPORT_DIRECTORY  . AddressOfNameOrdinals |//
//| 0x18: IMAGE_EXPORT_DIRECTORY  . NumberOfNames         |//
//| 0x18: IMAGE_NT_HEADERS        . OptionalHeader        |//
//| 0x3C: IMAGE_DOS_HEADER        . e_lfanew              |//
//| 0x00: LIST_ENTRY              . Flink                 |//
//| 0x20: LDR_DATA_TABLE_ENTRY    .Reserved2[0]           |//
//|                                                       |//
//| 0x48: LDR_DATA_TABLE_ENTRY    .FullDllName            |//
//| 0x08:                          FullDllName.Buffer     |//
//|                                                       |//
//| 0x18: PEB.Ldr                                         |//
//| 0x20:     Ldr.InMemoryOrderModuleList                 |//
//| 0x00:         InMemoryOrderModuleList.Flink           |//

// #define WIN32_LEAN_AND_MEAN
// #include <Windows.h>
// #include <winternl.h>
// #include <malloc.h>
// 
// #ifdef _M_AMD64
// #include <intrin.h>
// #elif defined(_M_ARM)
// #include <armintr.h>
// #endif



#include <string.h> //: strcmp


//|M:Macros: (Non-Local Macros)________________|//
//|MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM|//
//:See MSDN documentation on:
//:"ImageDirectoryEntryToDataEx"
#define MACRO_x_IMAGE_DIRECTORY_ENTRY_EXPORT 0

//:IMAGE_DATA_DIRECTORY struct is 128 bytes.
//:When doing address indexing math, multiply
//:by this value.
#define MACRO_sizeof_IMAGE_DATA_DIRECTORY 128

#define MACRO_WINAPI __stdcall
#define MACRO_WINDOWS_xxx_MB_OK 0x00000000L
//|MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM|//



typedef
    const char* //:<--ImmutableStringPointer
    TYPEDEF_LPCSTR;

typedef
    unsigned long //:32 bits, unsigned
    TYPEDEF_ULONG;

typedef
    unsigned long long //:64 bits, unsigned.
    TYPEDEF_DWORD_PTR;

typedef 
    const unsigned short *  TYPEDEF_LPCWSTR;

//:Though "HMODULE" is a void*, you cannot mix
//:"void*" with window's HMODULE because HMODULE
//:is declared using DECLARE_HANDLE hack. Which
//:creates a pointer to a dummy struct.
typedef 
    void* TYPEDEF_HMODULE;


//|FT:Function_Typedefs________________________|//
//|FTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFT|//

typedef 
    TYPEDEF_HMODULE                  //:RETURNS
    (MACRO_WINAPI *LoadLibraryAF)  //:CC+NAME
    (TYPEDEF_LPCSTR lpFileName    ); //:PARAM_L

typedef
    unsigned long long               //:RETURNS
    ( __stdcall  *TYPEDEF_FARPROC )  //:NAME
    ( /**NOT_SPECIFIED != void**/ ); //:PARAMS

typedef 
    TYPEDEF_FARPROC
    (MACRO_WINAPI *GetProcAddressF)
    (
        TYPEDEF_HMODULE hModule
    ,   TYPEDEF_LPCSTR lpProcName
    );

//|FTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFT|//

//////////////////////////////////////////////////

LoadLibraryAF
dll_LoadLibraryA   =NULL;

GetProcAddressF
dll_GetProcAddress =NULL;
//////////////////////////////////////////////////



#include <stdlib.h> //: exit()
#include <stdio.h> //:printf(...)

//:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX://  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    //:PERMA:SHORTCUT[ PASTE_COM_WID_STR_INS ]      //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//:CWSI: Compare_Wide_Strings_Insensitive           //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
#include <stdio.h> //:for: printf(...)              //[CWSI:2019_11_28]//
#include <assert.h>                                 //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
int                                                 //[CWSI:2019_11_28]//
JMIM_lstrcmpiW( //[lstrcmpiW]//                     //[CWSI:2019_11_28]//
    const unsigned short* str_1                     //[CWSI:2019_11_28]//
,   const unsigned short* str_2                     //[CWSI:2019_11_28]//
){                                                  //[CWSI:2019_11_28]//
    void JMIM_lstrcmpiW_LAZYTEST();                 //[CWSI:2019_11_28]//
         JMIM_lstrcmpiW_LAZYTEST();                 //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    #define U unsigned short /////////////////////  //[CWSI:2019_11_28]//
    #define S   signed short /////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    int dex =(0-1);                                 //[CWSI:2019_11_28]//
    U r_e_s_u_l_t ;                                 //[CWSI:2019_11_28]//
    U chr_1       ;                                 //[CWSI:2019_11_28]//
    U chr_2       ;            //: 97 - 65          //[CWSI:2019_11_28]//
    U       sub_to_get_uppercase = 'a'-'A';         //[CWSI:2019_11_28]//
    assert( sub_to_get_uppercase > 0 );             //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    #undef  U ////////////////////////////////////  //[CWSI:2019_11_28]//
    #undef  S ////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    while( 1 ){                                     //[CWSI:2019_11_28]//
        dex++;                                      //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        chr_1=str_1[ dex ];                         //[CWSI:2019_11_28]//
        chr_2=str_2[ dex ];                         //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        //:Convert both characters to uppercase:    //[CWSI:2019_11_28]//
        //////////////////////////////////////////  //[CWSI:2019_11_28]//
        if( chr_1 >= 'a' && chr_1 <= 'z' ){         //[CWSI:2019_11_28]//
            chr_1 = chr_1 - sub_to_get_uppercase;   //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
        if( chr_2 >= 'a' && chr_2 <= 'z' ){         //[CWSI:2019_11_28]//
            chr_2 = chr_2 - sub_to_get_uppercase;   //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
        //////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
                 r_e_s_u_l_t = (chr_1 - chr_2);     //[CWSI:2019_11_28]//
        if( 0 != r_e_s_u_l_t ){ break; };           //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
        //:Null terminator found. Exit.             //[CWSI:2019_11_28]//
        if(0==chr_1 || 0==chr_2){                   //[CWSI:2019_11_28]//
            break;                                  //[CWSI:2019_11_28]//
        };;                                         //[CWSI:2019_11_28]//
    };;                                             //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    return( (int)r_e_s_u_l_t );                     //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//////////////////////////////////////////////////  //[CWSI:2019_11_28]//
static char JMIM_lstrcmpiW_TESTED = 0;              //[CWSI:2019_11_28]//
static char JMIM_lstrcmpiW_TESTIN = 0;              //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
void                                                //[CWSI:2019_11_28]//
JMIM_lstrcmpiW_TESTIT(){                            //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTED=0;                        //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTIN=1;                        //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    int res;                                        //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    const unsigned short* A1=L"WIDE";               //[CWSI:2019_11_28]//
    const unsigned short* B1=L"wide";               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    res = JMIM_lstrcmpiW(A1,B1);                    //[CWSI:2019_11_28]//
    assert( 0==res );                               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    // ---------------------------------------- //  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    const unsigned short* A2=L"JEFF";               //[CWSI:2019_11_28]//
    const unsigned short* B2=L"PAUL";               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    res = JMIM_lstrcmpiW(A2,B2);                    //[CWSI:2019_11_28]//
    assert( 0!=res );                               //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTIN=0;                        //[CWSI:2019_11_28]//
    JMIM_lstrcmpiW_TESTED=1;                        //[CWSI:2019_11_28]//
    //////////////////////////////////////////////  //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
void                                                //[CWSI:2019_11_28]//
JMIM_lstrcmpiW_LAZYTEST(){                          //[CWSI:2019_11_28]//
    if( 0 == 0                                      //[CWSI:2019_11_28]//
    &&  0 >= JMIM_lstrcmpiW_TESTED //:NOT_TESTED    //[CWSI:2019_11_28]//
    &&  0 >= JMIM_lstrcmpiW_TESTIN //:NOT_TESTING   //[CWSI:2019_11_28]//
    ){       JMIM_lstrcmpiW_TESTIT(); };            //[CWSI:2019_11_28]//
}//[;]//                                            //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//////////////////////////////////////////////////  //[CWSI:2019_11_28]//
                                                    //[CWSI:2019_11_28]//
//:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX://  //[CWSI:2019_11_28]//





void*
VOID_T16B( //:TruncatePointerTo16Bits (2bytes)

    void* addr

){

    #define U unsigned long long /////////////////

    /////////0xR_G_B_AA==4bytes,  32bits
    U mask = 0x0000FFFF ;     //: 16bits
    U addr_u = (U)addr;       //: Unsigned Long
    U addr_t = addr_u & mask; //: Truncated
    
    return( (void*)addr_t );

    #undef  U ////////////////////////////////////

}//[;]//

void*
VOID_T32B( //:TruncatePointerTo32Bits (4bytes)
    void* addr
){
    #define U unsigned long long /////////////////

    /////////0xR_G_B_AA==4bytes,32bits
    U mask = 0xFFFFFFFF ;
    U addr_u = (U)addr;       //:Unsigned Long
    U addr_t = addr_u & mask; //:Truncated
    
    return( (void*)addr_t );

    #undef  U ////////////////////////////////////
}//[;]//

//:Add two addresses together.
void*
VOID_Plus(
/**/    void* addr_01
,       void* addr_02
){

    #define U unsigned char //////////////////////
    #define L unsigned long long /////////////////

        //:addr_01 is casted to a byte pointer
        //:so that offsets from adding addr_02
        //:will be multiplied by 1 (sizeof byte)
        //:rather than 4 or 8.

        U* A_1=(U*)addr_01;
        L  A_2=(L )addr_02;
        U* A_3=( A_1 + A_2 );
        return( (void*)A_3 );

    #undef  U ////////////////////////////////////
    #undef  L ////////////////////////////////////

}//[;]//

//:Perform: (addr_01 - addr_02 )
void*
VOID_Minu(
/**/    void* addr_01
,       void* addr_02
){

    #define U unsigned char //////////////////////
    #define L unsigned long long /////////////////

    U* A_1=(U*)addr_01;
    L  A_2=(L )addr_02;
    U* A_3=( A_1 - A_2 );
    return( (void*)A_3 );

    #undef  U ////////////////////////////////////
    #undef  L ////////////////////////////////////

}//[;]//


//|Example Usage:                              |//
//|Find the relative offset in bytes from      |//
//|the base address "pOptionalHeader"          |//
//|to the member "DataDirectory"               |//
//|ANSWER: (0x70)                              |//
//|--------------------------------------------|//
//|  VOID_PROS(                                |//
//|      pOptionalHeader                       |//
//|  , &(pOptionalHeader->DataDirectory)       |//
//|  ,  "pOptionalHeader .DataDirectory"       |//
//|  );;                                       |//
void
VOID_PROS( //:PROS:Print_Relative_OffSet
/**/    void* base_address
,       void* seek_address
,       const char*    msg
){
    if( base_address > seek_address ){
        printf("[Bad_Ordering]\n");
        fflush(stdout);
        exit(666);
    };;

    //:   os:offset/delta:
    void* os = VOID_Minu(
        seek_address //:<----LARGER_VALUE
    ,   //  -     //
        base_address //:<----SMALLER_VALUE
    );;

    printf(
        "[PROS:msg]:%s\n[PROS:os]:%p\n"
    ,    msg,os
    );;

}//[;]//

void* 
VOID_Seek( 

/**/    void* data
,       int byte_offset 

){

    //:In order to have the correct byte offset
    //:applied to the pointers, you have to make
    //:sure they are casted to byte pointers
    //:first. Casting to void* seems to work
    //:as well. But I wouldn't trust that. Since
    //:the size of a pointer is either 4 or
    //:8 bytes, so offsets being multiplied by
    //:4 or 8 with void* would not suprise me
    //:depending on the C compiler.

    #define U unsigned char //////////////////////

        //:A_0: Start_Address
        //:A_1: End___Address

        U* A_0=(U*)data;  
        U* A_1=( A_0 + byte_offset );

        return( (void*)A_1 );

    #undef  U ////////////////////////////////////

}//[;]//

void* 
VOID_Load( 

/**/    void* data 

){

    //:Assumming the data is a pointer,
    //:it holds the address to some object
    //:somewhere else. We want to load that
    //:address.

    void** ptr = (void**)data; //:POINTER
    void*  aod = *(ptr);       //:ADDRESS_OR_DATA

    return( aod );
}//[;]//


//:Perform a series of memory offsets on an
//:address until you get to whatever destination
//:you are looking for.
//:
//:NOTE: Add 'A' and Seek 'S' instructions
//:      have the same result. But Add('A') was
//:      originally written for adding an address
//:      and Seek('S') was originally for a
//:      hexadecimal relative offset from the
//:      base address of a struct.
void*
VOID_Inst(
/**/    void*          initial_address  
,       unsigned long long* instruction_arr
){
    //:Instructions come in pairs:
    //:1: Instruction Type (Op-code)
    //:2: Instruction Data

    //: 0x00:     :  Terminate_Instruction_Stream
    //: 0x53: 'S' :  SEEK (takes an offset)
    //: 0x4C: 'L' :  LOAD
    //:              DATA==0: Load Full Address
    //:              DATA==4: Truncate to 4 bytes.
    //: 0x41: 'A' :  ADD  (Add addresses  )
    //: 0x54: 'T' :  Truncate to n bytes.(data==n)


    int code_index = (0-1);
    int data_index = (0-1);
    int pair_index = (0-1);

    unsigned long long  code;
    unsigned long long  data;

    void*  p = initial_address;
    void** pp= NULL;

    while(1){
        pair_index++;

        code_index = pair_index*2;
        data_index = code_index+1;
        
        code = instruction_arr[ code_index ];
        data = instruction_arr[ data_index ];

        if( 'S' == code ){ //:SEEK

            #define U unsigned long long /////////
            void* base_address = p;
            U     byte_offset  =(U)data;
            #undef  U ////////////////////////////

            #define U unsigned char //////////////

                //:A_0: Start_Address
                //:A_1: End___Address

                U* A_0=(U*)    base_address ;  
                U* A_1=( A_0 + byte_offset );

                p=(void*)A_1;

            #undef  U ////////////////////////////
            

        }else
        if( 'L' == code ){ //:LOAD
            if(data==0x00){
                //:LEA(Load Affective Address)
                //:by de-referencing the pointer.
                pp=(void**)p;
                p=(*pp);
            }else{

                //:LEA(Load Affective Address)
                //:by de-referencing the pointer.
                pp=(void**)p;
                p=(*pp);


                //:TRUNCATE address AFTER loading:


                #define U unsigned long long ///////////|------------|//
                                                      //| 2019_11_28 |//
                void* addr = p;                       //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                //:addr_f: Address_Full               //| 2019_11_28 |//
                //:addr_t: Address_Truncated          //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                ///////////0x1234567812345678         //| 2019_11_28 |//
                U mask_8 = 0xFFFFFFFFFFFFFFFF;//64bits//| 2019_11_28 |//
                ///////////0xR_G_B_AA == 4bytes,32bits//| 2019_11_28 |//
                U mask_4 = 0xFFFFFFFF;//:4bytes,32bits//| 2019_11_28 |//
                U mask_2 = 0xFFFF    ;//:2bytes,16bits//| 2019_11_28 |//
                U mask   = 0;                         //| 2019_11_28 |//
                if( 2 == data ){ mask = mask_2; };    //| 2019_11_28 |//
                if( 4 == data ){ mask = mask_4; };    //| 2019_11_28 |//
                if( 8 == data ){ mask = mask_8; };    //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                U addr_f = (U)addr;       //:All_Bits //| 2019_11_28 |//
                U addr_t = addr_f & mask; //:32__Bits //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                p=( (void*)addr_t );                  //| 2019_11_28 |//
                                                      //| 2019_11_28 |//
                #undef  U //////////////////////////////|____________|//

            };;

        }else
        if( 'T'  == code ){ //:TRUNCATE_4:
        //:Truncate address to first T bytes,
        //:The rest will be zeros.

            #define U unsigned long long ///////////|------------|//
                                                  //| 2019_11_28 |//
            void* addr = p;                       //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            //:addr_f: Address_Full               //| 2019_11_28 |//
            //:addr_t: Address_Truncated          //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            ///////////0x1234567812345678         //| 2019_11_28 |//
            U mask_8 = 0xFFFFFFFFFFFFFFFF;//64bits//| 2019_11_28 |//
            ///////////0xR_G_B_AA == 4bytes,32bits//| 2019_11_28 |//
            U mask_4 = 0xFFFFFFFF;//:4bytes,32bits//| 2019_11_28 |//
            U mask_2 = 0xFFFF    ;//:2bytes,16bits//| 2019_11_28 |//
            U mask   = 0;                         //| 2019_11_28 |//
            if( 2 == data ){ mask = mask_2; };    //| 2019_11_28 |//
            if( 4 == data ){ mask = mask_4; };    //| 2019_11_28 |//
            if( 8 == data ){ mask = mask_8; };    //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            U addr_f = (U)addr;       //:All_Bits //| 2019_11_28 |//
            U addr_t = addr_f & mask; //:32__Bits //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            p=( (void*)addr_t );                  //| 2019_11_28 |//
                                                  //| 2019_11_28 |//
            #undef  U //////////////////////////////|____________|//

        }else
        if( 'A' == code ){  //:ADD address

            #define U unsigned char ////////////// 
            #define L unsigned long long ///////// 
            
                //|addr_01 is casted to a byte |//
                //|pointer so that offsets from|//
                //|adding addr_02 will be      |//
                //|multiplied by 1 (sizeof     |//
                //|byte) rather than 4 or 8.   |//
            
                void* addr_01 = p;
                void* addr_02 = (void*)data;
            
                U* A_1=(U*)addr_01;
                L  A_2=(L )addr_02;
                U* A_3=( A_1 + A_2 );
            
                p = ( (void*)A_3 );
            
            #undef  U //////////////////////////// 
            #undef  L //////////////////////////// 

        }else
        if( 0x00 == code ){ //:END_OF_STREAM

            break;
        
        }else{
            printf("[INVALID_OP_CODE]\n");
            fflush(stdout);
            exit(666);
        };;

    };;
    
    //:Return the resulting address from all
    //:of the operations:
    return( p );

}//[;]//


//:Like VOID_Inst, but the instruction stream
//:first instruction is always an intitial('I')
//:start address to load. Thus only one argument
//:is needed instead of two.
void*
VOID_Oper(
    unsigned long long* instruction_arr
){
    if( 'I' != instruction_arr[0] ){
        printf("[I:ShouldBeFirstInstruction]\n");
        fflush(stdout);
        exit(666);
    };;

    //:Change first instruction to "add"
    instruction_arr[0]='A';
   
    //:Starting at address 0 essentially
    //:will load initial start address.
    void* p = VOID_Inst( 0x00, instruction_arr );

    //:Change the first instruction back to
    //:'I' so calling code is unaware of our
    //:hacky ways.
    instruction_arr[0]='I';

    return( p );

}//[;]//


//|_M_IX86 Defined as the integer literal value|//
//|600 for compilations that target x86        |//
//|processors. This macro isn't defined for x64|//
//|or ARM compilation targets.                 |//
//|SOURCE[ M_IX86-url ]                        |//
#ifdef _M_IX86 ///////////////////////////////////

    #error NOT_SUPPORTING_X86

#endif ///////////////////////////////////////////


static void* 
JMIM_ASM_GetBaseAddr_PEB_x64()
{
    void* base_address = 0;
    unsigned long long var_out = 0;

    __asm__(
        " movq %%gs:0x60, %[sym_out]  ; \n\t"
        :[sym_out] "=r"  (var_out) //:OUTPUTS
    );

    //: printf("[var_out]:%d\n", (int)var_out);

    base_address=(void*)var_out;
    return( base_address );
}

TYPEDEF_HMODULE MACRO_WINAPI 
JMIM_GetModuleBaseAddress(
    TYPEDEF_LPCWSTR moduleName
){

    //:Void pointers:
    //:void* p;
    void* p1;
    void* p2;
    //:void* p3; 

    //:Using void* instead of the actual types,
    //:so that we don't need to include the
    //:headers for these window's structs.
    //:SOURCES:
    //: https://www.codemachine.com/downloads/win80/winnt.h
    //: https://msdn.microsoft.com/en-us/windows/desktop/aa813706
    //: https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data
    //////////////////////////////////////////////
	void* //:PEB*        
    pPeb = NULL;

	void* //:LIST_ENTRY* 
    pListEntry = NULL;

	void* //:LDR_DATA_TABLE_ENTRY* 
    pLdrDataTableEntry = NULL;
    //////////////////////////////////////////////

    //:pPeb = (PPEB)JMIM_ASM_GetBaseAddr_PEB_x64();
    pPeb = JMIM_ASM_GetBaseAddr_PEB_x64();

	if (pPeb == NULL){
		return NULL;
    };;


    //:pPeb->Ldr->InMemoryOrderModuleList.Flink
    //////////////////////////////////////////////
    unsigned long long 
    instructions_to_Flink[] ={ 

        //:____________ Ldr ___________________://
        'S' , 0x18  //: PTR
    ,   'L' ,  0    //: OBJ

        //:____________ InMemoryOrderModuleList://
    ,   'S' , 0x20  //: PTR
    ,   'L' ,  0    //: OBJ

        //:____________ Flink
    ,   'S' , 0x00  //: PTR
    ,   0x00, 0x00  

    };;
    void* 
    first_link_in_list=(
        VOID_Inst( pPeb, instructions_to_Flink )
    );;
    //////////////////////////////////////////////
        


    
    
    pLdrDataTableEntry=( first_link_in_list );
    pListEntry        =( first_link_in_list );

    int we_wrapped_around_stop_looping = 0;
    
	do
	{

        //:pLdrDataTableEntry->FullDllName.Buffer
        //////////////////////////////////////////
        unsigned long long 
        instructions_to_Buffer[]={
            'S', 0x48  //:FullDllName:PTR
        ,   'S', 0x08  //:Buffer     :PTR
        ,   'L',  0    //:Buffer     :OBJ
        ,   0x00,0x00
        };;
        unsigned short* 
        full_dll_name_buffer=VOID_Inst( 
            pLdrDataTableEntry
            ,
            instructions_to_Buffer
        );;
        //////////////////////////////////////////
        
         
		if(0 ==
            JMIM_lstrcmpiW(

                //:"unsigned short"=="wide char"
                full_dll_name_buffer
            , 
                moduleName
            )
        ){
    
            //:No clue why, but the base address
            //:of the DLL seems to be at:
            //:"pLdrDataTableEntry->Reserved2[0]"
            //:which is the member right before
            //:"pLdrDataTableEntry->DllBase"

            //: pLdrDataTableEntry -> Reserved2[0]
            //////////////////////////////////////

            unsigned long long
            instructions_to_dll_module[]={
                'S', 0x20 //:Reserved2[0]:PTR
            ,   'L',  0   //:Reserved2[0]:OBJ
            ,   0x00,0x00
            };;

            void* 
            dll_module=VOID_Inst(
                pLdrDataTableEntry
            ,   instructions_to_dll_module
            );;

            return( dll_module );

            //////////////////////////////////////
        };;



        //: pListEntry = pListEntry -> Flink
        p1 = (void*)pListEntry;
        p1 = VOID_Seek( p1, 0x00 ); //:Flink:PTR
        p1 = VOID_Load( p1       ); //:Flink:OBJ
        pListEntry =    p1;



        //:pLdrDataTableEntry=pListEntry->Flink
        p2 = p1;
        p2 = VOID_Seek( p2, 0x00 ); //:Flink:PTR
        p2 = VOID_Load( p2       ); //:Flink:OBJ
        pLdrDataTableEntry = p2;



        if( pListEntry == first_link_in_list ){
            we_wrapped_around_stop_looping = 1;
        }else{
            we_wrapped_around_stop_looping = 0;
        };;



	}while( 0 == we_wrapped_around_stop_looping );

	return NULL;
}

TYPEDEF_FARPROC __stdcall 
JMIM_GetExportAddress(
    TYPEDEF_HMODULE hMod
,   const char *lpProcName
){

    void* p;

    //: printf("[helllooooo]");

	char *pBaseAddress = (char *)hMod;

    //|  Can be found in winnt.h header file.  |//
    //|----------------------------------------|//



    //////////////////////////////////////////////
	//| IMAGE_DOS_HEADER                       |//
    //| *pDosHeader =(                         |//
    //|         (IMAGE_DOS_HEADER *)           |//
    //|          pBaseAddress                  |//
    //| );;                                    |//
                                            //||//
    void*                                   //||//
    pDosHeader = pBaseAddress;              //||//
                                            //||//
    //////////////////////////////////////////////


    #define U unsigned long long /////////////////

    //| IMAGE_NT_HEADERS                       |//
    //| *pNtHeaders == pBaseAddress            |//
    //|                +                       |//
    //|                pDosHeader -> e_lfanew  |//

    unsigned long long oper_pNtHeaders[]={
        'I' , (U)pDosHeader   //:Initial_Address
    ,   'S' , 0x3C            //:e_lfanew:PTR
    ,   'L' ,  4              //:e_lfanew:OBJ
    ,   'A' , (U)pBaseAddress //:IMAGE_NT_HEADERS
    ,   0x00,0x00
    };;
    void* pNtHeaders=VOID_Oper(
        oper_pNtHeaders
    );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////
    
    U oper_OptionalHeader[]={
        'I' , (U)pNtHeaders
    ,   'S' , 0x18 //:OptionalHeader:PTR
    ,   0x00, 0x00
    };;
    void* //:IMAGE_OPTIONAL_HEADER
    pOptionalHeader =VOID_Oper( 
        oper_OptionalHeader
    );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////

    //| IMAGE_DATA_DIRECTORY                   |//
    //|*pDataDirectory=(                       |//
    //|    &(pOptionalHeader -> DataDirectory[ |//
    //|         IMAGE_DIRECTORY_ENTRY_EXPORT   |//
    //|     ])                                 |//
    //| );;                                    |//

    U oper_pDataDirectory[]={
        'I', (U)pOptionalHeader
    ,   'S', 0x70 //:DataDirectory[ 0 ]

        //: I_D_E_E:IMAGE_DIRECTORY_ENTRY_EXPORT
        //: DataDirectory[ I_D_E_E ]
    ,   'S', MACRO_x_IMAGE_DIRECTORY_ENTRY_EXPORT
             *
             MACRO_sizeof_IMAGE_DATA_DIRECTORY

        //:Dont load address. Keep as pointer.
       
    ,   0x00,0x00
    };;
    void*
    pDataDirectory=VOID_Oper( 
        oper_pDataDirectory 
    );;

    #undef  U ////////////////////////////////////
    

    //:pDataDirectory -> VirtualAddress
    p = pDataDirectory;
    p = VOID_Seek( p, 0x00 );//:VirtualAddress:PTR
    p = VOID_Load( p       );//:VirtualAddress:OBJ
    void* virtual_address = p;



        #define U unsigned long long /////////////
        
        U base = (U)pBaseAddress;
        
        U inst_to_image_export_directory[]={
            'T',  4   //:truncate to 4 bytes
        ,   'A', base //:Add base addr
        ,  0x00, 0x00 //:END
        };;
        void* 
        added_addresses=VOID_Inst(
            virtual_address
        ,   inst_to_image_export_directory
        );;
        
        #undef  U ////////////////////////////////

        void* //:IMAGE_EXPORT_DIRECTORY*
        pExportDirectory = added_addresses;


      // VOID_PROS(
      //     pExportDirectory
      // , &(pExportDirectory->NumberOfFunctions)
      // ,  "pExportDirectory .NumberOfFunctions"
      // );;

    //: data_directory_size==
    //: pDataDirectory -> Size
    p = pDataDirectory;
    p = VOID_Seek( p, 0x04 ); //:Size:PTR
    p = VOID_Load( p       ); //:Size:OBJ
    size_t data_directory_size=(size_t)( p );
    


    //|----------------------------------------|//



    #define U unsigned long long /////////////////

    //| ppFunctions=(                          |//
    //|    pBaseAddress                        |//
    //|    +                                   |//
    //|    pExportDirectory->AddressOfFunctions|//
    //| );;                                    |//
    
//x   U inst_to_ppFunctions[]={
//x       'S' , 0x1C      //:AddressOfFunctions:PTR
//x   ,   'L' ,  0        //:AddressOfFunctions:OBJ
//x   ,   'T' ,  4        //:Truncate to 4 bytes
//x   ,   'A' ,  (U)pBaseAddress //:Add base address
//x   ,   0x00,0x00
//x   };;
//x   void**
//x   ppFunctions=VOID_Inst(
//x       pExportDirectory
//x   ,   inst_to_ppFunctions
//x   );;

    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////
    
    //|                                        |//
    //|         pOrdinals                      |//
    //|         ===                            |//
    //|         pBaseAddress                   |//
    //|         +                              |//
    //|         pExportDirectory               |//
    //|         ->AddressOfNameOrdinals        |//
    
    unsigned long long oper_pOrdinals[]={
    /**/'I' , (U)pExportDirectory
    ,   'S' , 0x24 //:AddressOfNameOrdinals:PTR
    ,   'L' ,  4   //:AddressOfNameOrdinals:OBJ  
    ,   'A' , (U)pBaseAddress //:pOrdinals
    ,   0x00,0x00  //:END_OF_INSTRUCTIONS
    };;
    unsigned short //:WORD* 
    *pOrdinals=VOID_Oper( oper_pOrdinals );
    
    #undef  U ////////////////////////////////////
    #define U unsigned long long /////////////////

    U oper_pNames[]={
    /**/'I' , (U)pExportDirectory
    ,   'S' , 0x20 //:AddressOfNames:PTR
    ,   'L' ,  4   //:AddressOfNames:OBJ  
    ,   'A' , (U)pBaseAddress //:pNames
    ,   0x00,0x00  //:END_OF_INSTRUCTIONS
    };;
    TYPEDEF_ULONG*
    pNames=VOID_Oper( oper_pNames );


    #undef  U ////////////////////////////////////


	void *pAddress = NULL;



	unsigned long i; //:DWORD

	if (((TYPEDEF_DWORD_PTR)lpProcName >> 16) == 0)
	{
        //:The pointer only contains 16 bits.
        //:Why does this require different code?
        //:Don't know. SEE: PS2_2.C11 for
        //:reference.
        
        printf("[ERROR:2019_11_28:09_32AM]\n");
        fflush(stdout); 
        exit(666);
	}
	else
	{
        //: printf("[BOT:SELECTED]");

        #define U unsigned long long /////////////

        //| pExportDirectory -> NumberOfNames  |//

        U oper_NumberOfNames[]={
            'I' , (U)pExportDirectory
        ,   'S' , 0x18 //:NumberOfNames:PTR
        ,   'L' ,  4   //:NumberOfNames:OBJ
        ,   0x00,0x00
        };; 
        unsigned long
        number_of_names=(
            (unsigned long)
            (unsigned long long)
            VOID_Oper( oper_NumberOfNames )
        );;

        // ------------------------------------ //

        //| pExportDirectory                   |//
        //| -> AddressOfFunctions              |//

        U oper_AddressOfFunctions[]={
            'I' , (U)pExportDirectory
        ,   'S' , 0x1C //:AddressOfFunctions:PTR
        ,   'L' ,  4   //:AddressOfFunctions:OBJ
        ,   0x00,0x00 
        };; 
        unsigned long
        address_of_functions=(
            (unsigned long)
            (unsigned long long)
            VOID_Oper( oper_AddressOfFunctions )
        );;

        #undef  U ////////////////////////////////


        unsigned long
        *absolute_address_of_functions=(
            (unsigned long *)
            (
                pBaseAddress
                +
                address_of_functions
            )
        );;

		for(
            i = 0
            ; 
            i < number_of_names
            ; 
            i++
        ){
			char *szName =(
                (  char*  )pBaseAddress 
              + (TYPEDEF_DWORD_PTR)pNames[i]
            );;

			if (strcmp(lpProcName, szName) == 0)
			{
				pAddress =(
                    (void*)( //:(TYPEDEF_FARPROC)
                        pBaseAddress
                        +
                        absolute_address_of_functions
                        [pOrdinals[i]]
                    )
                );;

				break;
			};;
		}
	}

	if(
        (char *)pAddress
        >= 
        (char *)pExportDirectory 

        && 

        (char *)pAddress 
        < 
        (char *)pExportDirectory 
              + data_directory_size
    ){
        //:Not going to re-write dead
        //:code path until error is hit.
       
        printf("[ERROR:2019_11_28:09_37AM]\n");
        fflush(stdout); 
        exit(666);

	}

    //:https://stackoverflow.com/questions/14134245/
    //:iso-c-void-and-function-pointers
	//:return pAddress;
    TYPEDEF_FARPROC ret;
    *(void **)(&ret) = pAddress;
    return( ret );
}




//|////////////////////////////////////////////|//
//|     -///-                        -///-     |//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __  __  __  __      __  _|//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |//
//|      \  /                        \  /      |//
//|       \/                          \/       |//
//+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +//
//|           /\                  /\           |//
//|          /  \                /  \          |//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|//
//|                                            |//
//|       ______________________________       |//
//|______/                              \______|//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) /////////////
/** ****************************************** |||
                                                   
    typedef struct _UNICODE_STRING {
      USHORT Length;
      USHORT MaximumLength;
      PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;



    typedef struct _LIST_ENTRY {
       struct _LIST_ENTRY *Flink;
       struct _LIST_ENTRY *Blink;
    } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;



    typedef struct _LDR_DATA_TABLE_ENTRY {
        PVOID Reserved1[2];
        LIST_ENTRY InMemoryOrderLinks;
        PVOID Reserved2[2];
        PVOID DllBase;
        PVOID EntryPoint;
        PVOID Reserved3;
        UNICODE_STRING FullDllName;
        BYTE Reserved4[8];
        PVOID Reserved5[3];
        union {
            ULONG CheckSum;
            PVOID Reserved6;
        };
        ULONG TimeDateStamp;
    } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;



    typedef struct _PEB {
        BYTE                          Reserved1[2];
        BYTE                          BeingDebugged;
        BYTE                          Reserved2[1];
        PVOID                         Reserved3[2];
        PPEB_LDR_DATA                 Ldr;
        PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
        BYTE                          Reserved4[104];
        PVOID                         Reserved5[52];
        PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
        BYTE                          Reserved6[128];
        PVOID                         Reserved7[1];
        ULONG                         SessionId;
    } PEB, *PPEB;


IMAGE_DATA_DIRECTORY

    typedef struct _IMAGE_DATA_DIRECTORY {
      DWORD VirtualAddress;
      DWORD Size;
    } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
                                                
||| ****************************************** **/ 
#endif ///////////////////////////////////////////
//|______                                ______|//
//|||||||\______________________________/|||||||//
//|                                            |//
//|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|//
//|_  __      __  __  __  __  __  __      __  _|//
//| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |//
//|      \  /                        \  /      |//
//|       \/                          \/       |//
//+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +//
//|           /\                  /\           |//
//|          /  \                /  \          |//
//|_--__--__/    \__/\__/\__/\__/    \__--__--_|//
//|                                            |//
//|____________________________________________|//


//////////////////////////////////////////////////
#endif  //:VGAURD
//[ DLLL: DLLL_Loader                          ]//
//+--------------------------------------------+//
//| PUBLIC:                                    |//
//| DLLL_FUNC                                  |//
//| DLLL_DLIB                                  |//
//| DLLL_WRAP_LoadLibraryA                     |//
//| DLLL_WRAP_GetProcAddress                   |//
//+--------------------------------------------+//





//: typedef 
//:     void (*DLLL_GENERIC_FUNCTION_POINTER)
//:     ( void ); //:<<"void" may need to be omitted.




#if( COMPILE_FOR_windows_10_64bit >= 1 )

    //: #include "./TARG/WIN10_x64._"

    //: #include "V:/VG/03/W32/DLLL/TARG/W10.X64"

    typedef
        TYPEDEF_HMODULE
        DLLL_DLIB;

    typedef 
        TYPEDEF_FARPROC 
        DLLL_FUNC;

#endif


static unsigned char
dll_init_already_called =((( 0 )));
void
DLLL_Init(){

    if( dll_init_already_called>0){ return; };

    TYPEDEF_HMODULE 
    hKernel32 =(
    /**/    JMIM_GetModuleBaseAddress(
    /**/        L"KERNEL32.DLL"
    /**/    )
    );;

    LoadLibraryAF 
    pLoadLibraryA =(
    /**/    (LoadLibraryAF)
    /**/    JMIM_GetExportAddress(
    /**/        hKernel32
    /**/    ,  "LoadLibraryA"
    /**/    )
    );;

    GetProcAddressF 
    pGetProcAddress =(
    /**/    (GetProcAddressF)
    /**/    JMIM_GetExportAddress(
    /**/        hKernel32
    /**/    ,   "GetProcAddress"
    /**/    )
    );;

    //:Assign the private function pointers
    //:defined in the specific operating system
    //:implementation files:
    dll_LoadLibraryA   =pLoadLibraryA  ;
    dll_GetProcAddress =pGetProcAddress;

    dll_init_already_called=( 1 );
    
}//[;]//

DLLL_DLIB
DLLL_WRAP_LoadLibraryA(
    const char* name
){
    if(NULL==dll_LoadLibraryA){
        printf("[FORGOT:DLLL_Init()?](LLA)\n");
        assert(NULL!=dll_LoadLibraryA);
    };;

    //:Implementation_Specific:
    return( dll_LoadLibraryA( name ) );
}//[;]//

DLLL_FUNC
DLLL_WRAP_GetProcAddress(
    DLLL_DLIB   dlib
,   const char* name
){
    if(NULL==dll_GetProcAddress){
        printf("[FORGOT:DLLL_Init()?](GPA)\n");
        assert(NULL!=dll_GetProcAddress);
    };;

    //:Implementation_Specific:
    DLLL_FUNC ret;
    ret = (DLLL_FUNC)
           dll_GetProcAddress(dlib, name);
    return(  ret  );
}//[;]//

//////////////////////////////////////////////////
//|  Let's be real... You are not going to     |//
//|  remember "DLLL_WRAP_*" Better just stick  |//
//|  with habits that are less complex.        |//
//+--------------------------------------------+//               
//|  Also,prioritize ease of use! Not speed    |//
//|  here.                                     |//
//////////////////////////////////////////////////

DLLL_DLIB
DLLL_LoadLibraryA(
    const char* name
){
    DLLL_Init(); //:LazyInit

    DLLL_DLIB ret=(
    /**/    DLLL_WRAP_LoadLibraryA(
    /**/        name
    /**/    )
    );;

    if(NULL==ret){
        printf(
            "[DLLL_LoadLibraryA:FAIL]:%s\n"
        ,   name
        );;
    };;

    return( ret );

}//[;]//

DLLL_FUNC
DLLL_GetProcAddress(
    DLLL_DLIB   dlib
,   const char* name
){
    DLLL_Init(); //:LazyInit

    DLLL_FUNC ret=(
    /**/    DLLL_WRAP_GetProcAddress(
    /**/        dlib
    /**/    ,   name
    /**/    )
    );;

    if(NULL==ret){
        printf(
            "[DLLL_GetProcAddress:FAIL]:%s\n"
        ,   name
        );;
    };;


    return( ret );

}//[;]//


//////////////////////////////////////////////////

//[ DOTADIW: Gather_Function_Pointers_From_DLL_Files --------]//
//[         (DLL files or linux equivalent)                  ]//
//[                                                          ]//
//[ Example Function Pointer Created By This File:           ]//
//[                                                          ]//
//[         F02_VOF F02_DestroyWindow =<SomeDLLAddress>      ]//

#include <string.h> //: strcmp

//:Generic_Function_Pointer
typedef void (*F02_VOF)(void);


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

void F01_Halt( const char* msg ){ 
    printf( "[F01_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//

int F01_Same( const char* str_01, const char* str_02 ){
    return( 0 == strcmp( str_01, str_02 ) );
}//[;]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

    

    //[ Declare void pointers for every single DLL function  ]//
    //[ you want to call. They will be wrapped by functions  ]//
    //[ in a later file. Or called by casting to correct     ]//
    //[ signature on the fly.                                ]//
    #define F02_F01_MACRO(f,d) F02_VOF  F02_  ##  f ;
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    //:Create dummy F01_ functions to let you know
    //:you are wrong and should be calling F02_ functions.
    #define F02_F01_MACRO(f,d) F02_VOF  F01_  ##  f ;
        #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

////////////////////////////////////////////////////////////////
//:Positive: The index of the loaded dll address in array.
//:Negative: The index to insert/cache next dll.
//:DO NOT USE TO PEEK! When returning negative, expects you
//:to add to the cache array.
#define MACRO_STR const char * /////////////////////////////////
static DLLL_DLIB F01_Cache_ADDR[1+10]={0}; //:DLL_CACHE.address
static MACRO_STR F01_Cache_NAME[1+10]={0}; //:DLL_CACHE.name
int F01_GetCacheIndex( const char* dlib_name ){

    int i = 0;while(1){ i++;
        
        assert( 0 != i ); //:Invalid_Cache_Index
        assert( i <= 10); //:Out_Of_Pre_Allocated_Slots

        if( NULL ==    F01_Cache_ADDR[i]){ return(  0-i  ); }
        if( F01_Same(  F01_Cache_NAME[i], dlib_name  )   ){
            return( i );
        };;

    };;

    assert( 0 ); //:CRASH! Should have returned already!
    return( 0 ); //:Return invalid index.

}//[;]//
#undef MACRO_STR ///////////////////////////////////////////////

int F01_GF_total_number_of_functions_fetched=0;
static F02_VOF F02_GF( //:GF:Get_Function(Pointer)
/**/    const char* func_name //:EX:"ShowWindow"
/**/,   const char* dlib_name //:EX:"user32.dll" | "user32"
){
    DLLL_DLIB  dlib_addr; //:DLL Module   Address
    DLLL_FUNC  func_addr; //:DLL Function Address
    ////////////////////////////////////////////////////////////
    //:GET DLL Module:
    ////////////////////////////////////////////////////////////
    int cac_dex = F01_GetCacheIndex( dlib_name );
    if( cac_dex > 0 ){

        dlib_addr = F01_Cache_ADDR[ cac_dex ];

    }else
    if( cac_dex < 0 ){

        dlib_addr = DLLL_LoadLibraryA(
        dlib_name );;

        F01_Cache_ADDR[ 0-cac_dex ] = dlib_addr;
        F01_Cache_NAME[ 0-cac_dex ] = dlib_name;

    }else{
        F01_Halt( "[EUBOC:ZERO_IS_INVALID_CACHE_INDEX]" );
    };;
    ////////////////////////////////////////////////////////////
    //:PULL Function From DLL:
    ////////////////////////////////////////////////////////////

        func_addr = DLLL_GetProcAddress( dlib_addr, func_name );

    ////////////////////////////////////////////////////////////

    F01_GF_total_number_of_functions_fetched++;
    return( (F02_VOF)func_addr );

}//[;]//

void F02_WRONGNAME(void){

    printf("[Raw_Function_Pointers_Are_Named]\n");
    printf("[After_The_File_They_Are_Created]\n");
    printf("[in.(F.02)not_the_file_the_func_]\n");
    printf("[name_list_lives_in(F.01).------]\n");
    printf("[TL;DR::::::::::::::::::::::::::]\n");
    printf("[   YES: F02_SomeRawDLLFunction ]\n");
    printf("[    NO: F01_SomeRawDLLFunction ]\n");

    fflush(stdout);
    exit(666);

}//[;]//

//:Load Function Pointers: EX: F02_ShowWindow
void F01_Init(){
    #define F02_F01_MACRO(f,d) F02_ ## f = F02_GF(#f,#d);
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    //:In case you think the functions start with "F01_"
    #define F02_F01_MACRO(f,d) F01_ ## f = &(F02_WRONGNAME);
            #include "./F.01" //:<--[[[DOTADIW:DLL_FUNC_LIST]]]
    #undef  F02_F01_MACRO

    if( F01_GF_total_number_of_functions_fetched != 19 ){
        F01_Halt("[Expected_This_Many_Fetched_Funcs]");
    };;

}//[;]//



//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[F02: DOTADIW: Quick_Hack_For_Calling_DLL_Func_Pointers. --]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[ Making typedefs and wrappers for function signatures can ]//
//[ get a bit verbose and annoying. When you feel like       ]//
//[ skipping that effort, you can use these hacks depending  ]//
//[ on the number of parameters the function has.            ]//
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

#define  V void* ///////////////////////////////////////////////
#define  a void* ///////////////////////////////////////////////
#define  b void* ///////////////////////////////////////////////
#define  c void* ///////////////////////////////////////////////
#define  d void* ///////////////////////////////////////////////
#define  e void* ///////////////////////////////////////////////

typedef  V (* F03_00)( void );
typedef  V (* F03_01)( a                                      );
typedef  V (* F03_02)( a,a                                    );
typedef  V (* F03_03)( a,a,a                                  );
typedef  V (* F03_04)( a,a,a,a                                );
typedef  V (* F03_05)( a,a,a,a,b                              );
typedef  V (* F03_06)( a,a,a,a,b,b                            );
typedef  V (* F03_07)( a,a,a,a,b,b,b                          );
typedef  V (* F03_08)( a,a,a,a,b,b,b,b                        );
typedef  V (* F03_09)( a,a,a,a,b,b,b,b,c                      );
typedef  V (* F03_10)( a,a,a,a,b,b,b,b,c,c                    );
typedef  V (* F03_11)( a,a,a,a,b,b,b,b,c,c,c                  );
typedef  V (* F03_12)( a,a,a,a,b,b,b,b,c,c,c,c                );
typedef  V (* F03_13)( a,a,a,a,b,b,b,b,c,c,c,c,d              );
typedef  V (* F03_14)( a,a,a,a,b,b,b,b,c,c,c,c,d,d            );
typedef  V (* F03_15)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d          );
typedef  V (* F03_16)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d        );
typedef  V (* F03_17)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e      );
typedef  V (* F03_18)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e    );
typedef  V (* F03_19)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e  );
typedef  V (* F03_20)( a,a,a,a,b,b,b,b,c,c,c,c,d,d,d,d,e,e,e,e);

#undef   V /////////////////////////////////////////////////////
#undef   a /////////////////////////////////////////////////////
#undef   b /////////////////////////////////////////////////////
#undef   c /////////////////////////////////////////////////////
#undef   d /////////////////////////////////////////////////////
#undef   e /////////////////////////////////////////////////////

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//
//[ DOTADIW: Make wrapper functions for DLL func pointers.   ]//

//:We could abstract this further, by creating a list
//:of function names that have had typedefs created for them.

#define F06_F05_MACRO_RETURNTYPE void*  ////////////////////////
#define F06_F04_MACRO_CreateWindowExW 1  ///////////////////////

    #define F06_F05_MACRO_wrapper   F06_CreateWindowExW
    #define F06_F05_MACRO_wrapped   F02_CreateWindowExW

        #include "./F.05" //:<<--#DOTADIW:WRAPPER_FUNC_TEMPLATE#
    
    #undef  F06_F05_MACRO_wrapper
    #undef  F06_F05_MACRO_wrapped

#undef  F06_F05_MACRO_RETURNTYPE  //////////////////////////////
#undef  F06_F04_MACRO_CreateWindowExW ////////////////////////// 
//#DOTADIW: Create_A_Window                                  #//

//[V:Variables. #VARS_TOP_OF_FILE_BIG_PICTURE#               ]//
//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//:Initial_Window_Size_And_Position:
////////////////////////////////////////////
int f07_X    = 22  ; /**  GLEB_SWIN.X    **/
int f07_Y    = 22  ; /**  GLEB_SWIN.Y    **/
int f07_WID  = 1024; /**  GLEB_SWIN.WID  **/
int f07_HIG  = 512 ; /**  GLEB_SWIN.HIG  **/
////////////////////////////////////////////

    signed char f07_window_created     = 0;
    signed char f07_window_just_closed = 0;
      
    void* f07_handle_to_window      = NULL; //:HWND
    void* f07_window_device_context = NULL; //:HDC
    
    //:Forward declare so we can keep variables
    //:at top of file.
    struct F07_STRUCT_PIXELFORMATDESCRIPTOR;
    struct F07_STRUCT_PIXELFORMATDESCRIPTOR
                f07_pixel_format_descriptor;
    signed char f07_InitPixelFormatDescriptor_DONE=0;

//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//[H:Halt Always first function in file._____________________]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
void F07_Halt( const char*     msg ){ 
    printf( "[F07_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

//[SI:Structs_And_Initializers (Initializers For The Structs)]//
//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//

typedef void (*F07_GENERIC_FUNC)(void);


typedef 
    __int64
    (__stdcall *F07_WNDPROC)(
        void*             //: HWND
    ,   unsigned   int    //: UINT
    ,   unsigned __int64  //: WPARAM
    ,            __int64  //: LPARAM
    );

// ---------------------------------------------------------- //

struct F07_STRUCT_WNDCLASSEXW {
                unsigned int   cbSize       ;
                unsigned int   style        ;
                 F07_WNDPROC   lpfnWndProc  ;
                         int   cbClsExtra   ;
                         int   cbWndExtra   ;
                        void*  hInstance    ;
                        void*  hIcon        ;
                        void*  hCursor      ;
                        void*  hbrBackground;
        const unsigned short*  lpszMenuName ;
        const unsigned short*  lpszClassName;
                        void*  hIconSm      ;
};

// ---------------------------------------------------------- //

struct F07_STRUCT_POINT{

    long x;
    long y;

};//[struct]//

//:winuser.h
struct F07_STRUCT_MSG {

    void*                    hwnd    ;  //: HWND    ://
    unsigned   int           message ;  //: UINT    ://
    unsigned __int64         wParam  ;  //: WPARAM  ://

             __int64         lParam  ;  //: LPARAM  ://
    unsigned    long         time    ;  //: DWORD   ://

    struct F07_STRUCT_POINT  pt      ;  //: POINT   ://
    unsigned    long         lPrivate;  //: DWORD   ://

};//[struct]//



//[  docs.microsoft.com/en-us/windows/win32/api/wingdi       ]//
//[  /ns-wingdi-pixelformatdescriptor                        ]//
#define W unsigned short /** WORD **/  /////////////////////////
#define D unsigned long  /**DWORD **/  /////////////////////////
#define B unsigned char  /** BYTE **/  /////////////////////////
struct F07_STRUCT_PIXELFORMATDESCRIPTOR {
    W  nSize;   
    W  nVersion;

    D dwFlags;

    B  iPixelType;
    B  cColorBits;
    B  cRedBits;
    B  cRedShift;
    B  cGreenBits;
    B  cGreenShift;
    B  cBlueBits;
    B  cBlueShift;
    B  cAlphaBits;
    B  cAlphaShift;
    B  cAccumBits;
    B  cAccumRedBits;
    B  cAccumGreenBits;
    B  cAccumBlueBits;
    B  cAccumAlphaBits;
    B  cDepthBits;
    B  cStencilBits;
    B  cAuxBuffers;
    B  iLayerType;
    B  bReserved;

    D dwLayerMask;
    D dwVisibleMask;
    D dwDamageMask;

};//[struct]//
#undef  W ////////////// /** WORD **/  /////////////////////////
#undef  D ////////////// /**DWORD **/  /////////////////////////
#undef  B ////////////// /** BYTE **/  /////////////////////////
void                                       
f07_InitPixelFormatDescriptor(       
    void                                   
){          
    if( f07_InitPixelFormatDescriptor_DONE != 0 ){
        F07_Halt("[AlreadyInited:PFD]");
    };;
                                                                           
    struct F07_STRUCT_PIXELFORMATDESCRIPTOR                  
    p ={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct F07_STRUCT_PIXELFORMATDESCRIPTOR ), //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;     

    //:Quick smoke test in case I missed a param
    //:and my data is mis-aligned.
    if( 32 != p.cColorBits   ){
        F07_Halt( "[32!=p.cColorBits]" );
    };;
    if( 24 != p.cDepthBits  ){
        printf("[p.cDepthBits]:%d\n" , p.cDepthBits );
        F07_Halt( "[24!=p.cDepthBits]");
    };;
    if(  8 != p.cStencilBits ){
       F07_Halt( "[08!=p.cStencilBits]");
    };;
                                           
    //[ Copy Over To Global Variable ]// 
    f07_pixel_format_descriptor =( p );
    f07_InitPixelFormatDescriptor_DONE = 1;
                                           
} //[InitPixelFormatDescriptor]//          

//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//


// ---------------------------------------------------------- //

////////////////////////////////////////////////////////////////             

typedef const unsigned short *  TYPEDEF_LPCWSTR;


char*
F07_MakeIntResourceA( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
}//[;]//

////////////////////////////////////////////////////////////////

//:WinMsgHanWndPoc:WINDOW_MESSAGE_HANDLER_WNDPROC
__stdcall
__int64 //:LRESULT
F07_WinMsgHanWndPoc(
/**/           void*    Hw     //:HWND
,   unsigned   int      Msg    //:...?...
,   unsigned __int64    wParam //:WPARAM
,            __int64    lParam //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[GLEB_SWIN:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 ((F03_01)(F02_DestroyWindow))(Hw);

            if(0==ok){F07_Halt("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            ((F03_01)(F02_DestroyWindow))(Hw);

        if(0==ok){F07_Halt("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((F03_01)F02_PostQuitMessage)(0);

    case 0x000F /**wm_paint**/:
        //:[TODO]:Something to pace the updating
        //:of graphics.


        //+ DELETE THIS BLOCK +//
        //- //:I dont think this is needed:         -//
        //- //: You may use the same HDC in both    -//
        //- //: threads, but not at the same time.  -//
        //- //: SEE[ gl-hdc-thread-quote ]          -//
        //- if(GLEB_SWIN.render_tick_function_has){ -//
        //-    GLEB_SWIN.render_tick_function();    -//
        //- };;                                     -//

        //: This might be better done setting a flag
        //: than using a callback. In order to prevent
        //: drawing code from being invoked on the
        //: wrong thread.

        //: With that said, setting a flag:
        //- ENGETHER.THREADING.InterlockedIncrement64( -//
        //-     &( GLEB_SWIN.THREAD_SAFE_FLAGS.        -//
        //-        redraw_message_count )              -//
        //- );;                                        -//

        
        //+ This call needs to be made from    +//
        //+ the same thread as your OpenGL     +//
        //+ calls.                             +//
        //# DONT_HERE:GLEB_SWIN_SwapBuffers(); #//





    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            ((F03_04)(F02_DefWindowProcW))(
            /**/(void*)                     Hw  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //[F07_WinMsgHanWndPoc]//

////////////////////////////////////////////////////////////////


int //:BOOL
F07_RegisterWindow(
/**/                    void*  hInstance                
/**/,   const unsigned short*  unique_window_name    
){

    //|Smoke_Test:-----------------------|//
    size_t struct_size =(
        sizeof( struct F07_STRUCT_WNDCLASSEXW )
    );;
    if( struct_size != 80 ){
        F07_Halt("[BadStructSize]");
    };;//|-------------------------------|//
    
    //: WNDCLASSEXW W;
    struct F07_STRUCT_WNDCLASSEXW 
    W = {0};

    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////

    W.cbSize=sizeof( struct F07_STRUCT_WNDCLASSEXW );
    W.style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                     //| ...ClassWin32         |//
    0);;
    W.lpfnWndProc=F07_WinMsgHanWndPoc;
    W.cbClsExtra=0;
    W.cbWndExtra=0;
    W.hInstance=hInstance;

    char* idi_application = F07_MakeIntResourceA( 32512 );
    char* idc_arrow       = F07_MakeIntResourceA( 32512 );

    W.hIcon  =((F03_02)F02_LoadIconA)(  
        NULL
    ,   idi_application
    );;
    W.hCursor=((F03_02)F02_LoadCursorA)(  
        NULL
    ,   idc_arrow
    );;

    //| Looking at:                            |//
    //| https://github.com/glfw/glfw/blob/     |//
    //| master/src/win32_window.c              |//
    //| does not look like background          |//
    //| brush color eneds to be set.           |//
    //|                                        |//
    //| Code here specifically says:           |//
    //| "No Background Required For GL"        |//
    //| http://nehe.gamedev.net/tutorial       |//
    //| /creating_an_opengl_window_(win32)     |//
    //| /13001/                                |//
    //- W.hbrBackground=(                      -//
    //-     /**/(HBRUSH)                       -// 
    //-     /**/ FP->GDI32.GetStockObject(     -// 
    //-     /**/     FP->GDI32.DATA.BRUSH.BLACK-// 
    //-     /**/)                              -// 
    //- );;                                    -//
    W.hbrBackground=NULL;

    W.lpszMenuName=NULL;
    W.lpszClassName=unique_window_name;
    W.hIconSm=(
        ((F03_02)F02_LoadIconA)(
            NULL
        ,   idi_application
        )
    );;

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //! If you forget to register your         !//
    //! window class, the observable effect    !//
    //! is the window never opening, and the   !//
    //! wait loop exiting immediately.         !//
    //|________________________________________|//
    return(
        (int)(unsigned long long)
        ((F03_01)F02_RegisterClassExW)(
            &( W )
        )
    );;
} //[Register]//


void //:gleb_swin_MakeWindowCompatibleWith_GL
f07_MakeWindowCompatibleWith_GL(
    void*  Hw /**HWND**/
){
    
    f07_InitPixelFormatDescriptor();

    void* /** HDC **/ 
    window_device_context =(
        ((F03_01)F02_GetWindowDC)( Hw ) /**user32**/
    );;
    int
    pixel_format_number=(
        (int)(unsigned long long)
        ((F03_02)F02_ChoosePixelFormat)( /**gdi32**/
            window_device_context
        , &( f07_pixel_format_descriptor )
        )
    );;
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((F03_03)F02_SetPixelFormat)(
        /**/
        /**/        window_device_context
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        pixel_format_number
        /**/    ,
        /**/        &( f07_pixel_format_descriptor )
        )
    );;
    if( setting_pixel_format_worked ){
        //: printf("[SPF:OK]\n");
    }else{
        F07_Halt("[SPF:FAIL]\n");
    };;

    f07_window_device_context=(
        window_device_context
    );;

} //[MakeWindowCompatibleWith_GL]//


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

int //:BOOL
f07_TakeOrLookMessage( 
/**/
    struct F07_STRUCT_MSG*
    dont_prefix_message_with_and_symbol /**LPMSG**/
    ,
    int    
    take_the_message
){

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        F07_Halt("[Exp:Pos|Or|Zero]");
    };;

    int ret =(
    (int)(unsigned long long)
    ((F03_05)F02_PeekMessageW)(
        (void*)
        dont_prefix_message_with_and_symbol
        ,
        NULL
        ,
        0
        ,
        0
        ,
        (void*)(unsigned long long)
        look_or_take

    ));;

    return( ret );

} //[TakeOrLookMessage]//



int //:BOOL
f07_LookMessage(
    struct F07_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=f07_TakeOrLookMessage(msg,look);
    return( ret );
} //[LookMessage]//



int //:BOOL
f07_TakeMessage(
    struct F07_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=f07_TakeOrLookMessage(msg,take);
    return( ret );
} //[TakeMessage]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


struct F07_STRUCT_MSG //:MSG struct
f07_WindowLoop(
    void*  Hw //:HWND
){

    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;
    ((F03_02)F02_ShowWindow  )(  Hw, show  ); 
    ((F03_01)F02_UpdateWindow)(  Hw        ); 
    ((F03_01)F02_SetFocus    )(  Hw        );

    unsigned int  wm_quit =  0x12;          

    struct F07_STRUCT_MSG  
    M; //:MSG struct

    f07_LookMessage( &M );
    while(
        M.message
        !=
        wm_quit
    ){
        if( f07_TakeMessage(    &M )){

            ((F03_01)F02_TranslateMessage)( &M );

            ((F03_01)F02_DispatchMessageW)( &M );

        };;

    };;

    f07_window_just_closed = ('t'|'r'|'u'|'e');

   //: //# [HACK]:Sleep a bit so other threads    #//
   //: //#        see "window_just_closed" update.#//
   //: //# You really should use a proper mutex.  #//
    ((F03_01)F02_Sleep)( (void*)64 );

    return( M );

} //[WindowLoop]//


//: Call this function on a separate thread!
//: Refactor_Of:gleb_swin_OPEN_WINDOW_LOOP_FOREVER
unsigned __int64 //:WPARAM
F07_OpenWindowAndLoopForever(
    //:UNICODE_STRING
    const unsigned short *  //:LPCWSTR
    unique_window_name
){

     
    void* /**HMODULE**/ hin=(
        ((F03_01)F02_GetModuleHandleW)(
            NULL
        )
    );;//[a]//

    if(NULL==hin){
        F07_Halt(
            "[FailedToGetModuleHandle]"
        );;
    };;//[b]//

    /////////////////////////////////////
    void*                              //
    Hw = NULL;  //:HWND                //
                                       //
    struct F07_STRUCT_MSG              //
    Msg       ;   //:tagMSG (Struct)   //
    /////////////////////////////////////

    if(0 >=
        F07_RegisterWindow(
            hin
        ,   unique_window_name
        )
    ){ 

        F07_Halt( /** Originally: gleb_swin_Alert **/
            "[FailedToRegisterWindow]"
        );;
        return 0; 

    };;//[c]//

    int X   = f07_X   ; //:Initial_X_Position
    int Y   = f07_Y   ; //:Initial_Y_Position
    int WID = f07_WID ; //:Initial_WIDTH
    int HIG = f07_HIG ; //:Initial_HEIGHT

    unsigned long ws_overlappedwindow=( 0
    |   0x00000000L  /** WS_OVERLAPPED  **/
    |   0x00C00000L  /** WS_CAPTION     **/
    |   0x00080000L  /** WS_SYSMENU     **/
    |   0x00040000L  /** WS_THICKFRAME  **/
    |   0x00020000L  /** WS_MINIMIZEBOX **/
    |   0x00010000L  /** WS_MAXIMIZEBOX **/
    );;//[d]//

    unsigned long cs_owndc = 0x0020;

    //:NOOP's so I can comment out call to CreateWindowExW:
    if( cs_owndc            ){ /** NOOP **/ };
    if( ws_overlappedwindow ){ /** NOOP **/ };
    if( X|Y|WID|HIG         ){ /** NOOP **/ };
    if( hin                 ){ /** NOOP **/ };

    void*
    the_desktop_window=((F03_00)F02_GetDesktopWindow)();

    Hw=F06_CreateWindowExW
    (

    /**/0x00000008L /** ws_ex_topmost **/
    ,   unique_window_name     
    ,   L"[GLEB_TITLE_BAR](題圌)"       
  
    , 
        (0
        |  ws_overlappedwindow /** STYLE **/   
        |  cs_owndc            /** STYLE **/
        |
        0)

    ,   X,Y,WID,HIG

    ,   the_desktop_window //:-- hWndParent ---://
    ,   NULL   //:-------------- hMenu      ---://
    ,   hin    //:-------------- hInstance  ---://        
    ,   NULL   //:-------------- lpParam    ---://  
    );//[e]//

    if(Hw==NULL){
        F07_Halt("[F07:WindowCreateFail]");
        return 0;
    };;//[f]//

    //:Store the handle to window in global state:
    f07_handle_to_window=Hw;

    //:Modifications to make window opengl
    //:compatible:
    //////////////////////////////////////////////
    f07_MakeWindowCompatibleWith_GL(
        Hw
    );;//[g]//

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯MC|//
    //!PUT AFTER device context has been     MC!//
    //!set, or your device context fetching  MC!//
    //!function waiting on this flag to be   MC!//
    //!set in this thread will end up        MC!//
    //!with a NULL device context.           MC!//
    //!Speaking Of:                          MC!//
    //!GLEB_SWIN_GetWindowDeviceContext();   MC!//
    f07_window_created=1;                 //|MC|//
    //|______________________________________MC|//

    //////////////////////////////////////////////

    Msg = f07_WindowLoop( Hw );

    return Msg.wParam;
} //[OPEN_WINDOW_LOOP_FOREVER]//


int F07_Demo_SingleThreaded(){
    F07_OpenWindowAndLoopForever(L"[CAJUN_SPICE]");
    return( 0 );
}//[;]//


//[ ]////|////////////////////////////////////////////|////[ ]//
//[ ]////|     -///-                        -///-     |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|       ______________________________       |////[ ]//
//[ ]////|______/                              \______|////[ ]//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) ///////////////////////////
/** ******************************************************** |||
                                                   
#VARS_TOP_OF_FILE_BIG_PICTURE#
    Variables are at the top of the file because they are
    what is most likely to be re-looked at when looking
    over the code months later.
                                                 
  
||| ******************************************************** **/ 
#endif /////////////////////////////////////////////////////////
//[ ]////|______                                ______|////[ ]//
//[ ]////|||||||\______________________________/|||||||////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|____________________________________________|////[ ]//


#include<stdlib.h> //:for: malloc(...)
#include<stdlib.h> //:for:   free(...)
#include <stdio.h> //:for: printf(...)

//:WC:Window Creation:
//:WCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWC://



//:WCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWCWC://

void VG03_Init(){
    F01_Init();


    
}//[;]//

int
VG03_Demo( void ){

    printf("[BEG:VG03_DEMO]\n");

    VG03_Init();

    F07_Demo_SingleThreaded();

    printf("[END:VG03_DEMO]\n");

    return( 0 );
}//[;]//

struct VG03_BLUEPRINT{

    int( *Demo )( void );

}VG03={

    .Demo = &( VG03_Demo )

};//[struct]//



