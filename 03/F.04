

//[V:Variables. #VARS_TOP_OF_FILE_BIG_PICTURE#               ]//
//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//:Initial_Window_Size_And_Position:
////////////////////////////////////////////
int f04_X    = 22  ; /**  GLEB_SWIN.X    **/
int f04_Y    = 22  ; /**  GLEB_SWIN.Y    **/
int f04_WID  = 1024; /**  GLEB_SWIN.WID  **/
int f04_HIG  = 512 ; /**  GLEB_SWIN.HIG  **/
////////////////////////////////////////////

    signed char f04_window_created     = 0;
    signed char f04_window_just_closed = 0;
      
    void* f04_handle_to_window      = NULL; //:HWND
    void* f04_window_device_context = NULL; //:HDC
    
    //:Forward declare so we can keep variables
    //:at top of file.
    struct F04_STRUCT_PIXELFORMATDESCRIPTOR;
    struct F04_STRUCT_PIXELFORMATDESCRIPTOR
                f04_pixel_format_descriptor;
    signed char f04_InitPixelFormatDescriptor_DONE=0;

//[VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV]//

//[H:Halt Always first function in file._____________________]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//
void F04_Halt( const char*     msg ){ 
    printf( "[F04_Halt]:%s\n", msg ); 
    fflush(stdout); exit(666);
}//[;]//
//[HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH]//

//[SI:Structs_And_Initializers (Initializers For The Structs)]//
//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//

typedef void (*F04_GENERIC_FUNC)(void);


typedef 
    __int64
    (__stdcall *F04_WNDPROC)(
        void*             //: HWND
    ,   unsigned   int    //: UINT
    ,   unsigned __int64  //: WPARAM
    ,            __int64  //: LPARAM
    );

// ---------------------------------------------------------- //

struct F04_STRUCT_WNDCLASSEXW {
                unsigned int   cbSize       ;
                unsigned int   style        ;
                 F04_WNDPROC   lpfnWndProc  ;
                         int   cbClsExtra   ;
                         int   cbWndExtra   ;
                        void*  hInstance    ;
                        void*  hIcon        ;
                        void*  hCursor      ;
                        void*  hbrBackground;
        const unsigned short*  lpszMenuName ;
        const unsigned short*  lpszClassName;
                        void*  hIconSm      ;
};

// ---------------------------------------------------------- //

struct F04_STRUCT_POINT{

    long x;
    long y;

};//[struct]//

//:winuser.h
struct F04_STRUCT_MSG {

    void*                    hwnd    ;  //: HWND    ://
    unsigned   int           message ;  //: UINT    ://
    unsigned __int64         wParam  ;  //: WPARAM  ://

             __int64         lParam  ;  //: LPARAM  ://
    unsigned    long         time    ;  //: DWORD   ://

    struct F04_STRUCT_POINT  pt      ;  //: POINT   ://
    unsigned    long         lPrivate;  //: DWORD   ://

};//[struct]//



//[  docs.microsoft.com/en-us/windows/win32/api/wingdi       ]//
//[  /ns-wingdi-pixelformatdescriptor                        ]//
#define W unsigned short /** WORD **/  /////////////////////////
#define D unsigned long  /**DWORD **/  /////////////////////////
#define B unsigned char  /** BYTE **/  /////////////////////////
struct F04_STRUCT_PIXELFORMATDESCRIPTOR {
    W  nSize;   
    W  nVersion;

    D dwFlags;

    B  iPixelType;
    B  cColorBits;
    B  cRedBits;
    B  cRedShift;
    B  cGreenBits;
    B  cGreenShift;
    B  cBlueBits;
    B  cBlueShift;
    B  cAlphaBits;
    B  cAlphaShift;
    B  cAccumBits;
    B  cAccumRedBits;
    B  cAccumGreenBits;
    B  cAccumBlueBits;
    B  cAccumAlphaBits;
    B  cDepthBits;
    B  cStencilBits;
    B  cAuxBuffers;
    B  iLayerType;
    B  bReserved;

    D dwLayerMask;
    D dwVisibleMask;
    D dwDamageMask;

};//[struct]//
#undef  W ////////////// /** WORD **/  /////////////////////////
#undef  D ////////////// /**DWORD **/  /////////////////////////
#undef  B ////////////// /** BYTE **/  /////////////////////////
void                                       
f04_InitPixelFormatDescriptor(       
    void                                   
){          
    if( f04_InitPixelFormatDescriptor_DONE != 0 ){
        F04_Halt("[AlreadyInited:PFD]");
    };;
                                                                           
    struct F04_STRUCT_PIXELFORMATDESCRIPTOR                  
    p ={  
        
        //[ nSize    ----------------------------------]////[]//
        sizeof(struct F04_STRUCT_PIXELFORMATDESCRIPTOR ), //[]//
                                                          //[]//
        1,                             //[ nVersion ---]////[]//                  
                                                          //[]//
            //[ dwFlags: %GCC%/[...]/wingdi.h ---------]////[]//
            //[ What do you want to support?  ---------]////[]//
       (0   //[-------------------------------]//         //[]//
        |   0x00000004 /** PFD_DRAW_TO_WINDOW **/         //[]//
        |   0x00000020 /** PFD_SUPPORT_OPENGL **/         //[]//
        |   0x00000001 /** PFD_DOUBLEBUFFER   **/         //[]//
        |   //[-------------------------------]//         //[]//
        0)                                                //[]//
                                                          //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ iPixelType: The kind of framebuffer. ------]////[]//
        //[ RGBA or palette.                     ------]////[]//
        //[ Request RGBA format (PFD_TYPE_RGBA)  ------]////[]//
        0x0 /** PFD_TYPE_RGBA **/                         //[]//
        ,                                                 //[]//
                                                          //[]//
        //[ cColorBits: Colordepth of the framebuffer. ]////[]//
        //[ cColorBits=="count of color bits" I think. ]////[]//
        32,                                               //[]//
                                                          //[]//
        0, 0, //[ cRedBits  , cRedShift  : IGNORED ----]////[]//
        0, 0, //[ cGreenBits, cGreenShift: IGNORED ----]////[]//
        0, 0, //[ cBlueBits , cBlueShift : IGNORED ----]////[]//
                                                          //[]//
        0,    //[ cAlphaBits : >= 0    ----------------]////[]//                        
        0,    //[ cAlphaShift: IGNORED ----------------]////[]//
                                                          //[]//
        0,    //[ cAccumBits : >= 0    ----------------]////[]//
                                                          //[]//
                                                          //[]//
        0,    //[ cAccumRedBits  : IGNORED ------------]////[]//
        0,    //[ cAccumGreenBits: IGNORED ------------]////[]//
        0,    //[ cAccumBlueBits : IGNORED ------------]////[]//
        0,    //[ cAccumAlphaBits: IGNORED ------------]////[]//
                                                          //[]//
        //[ cDepthBits  : Number_Of_Bits: depthbuffer  ]////[]//
        24,                                               //[]//
                                                          //[]//
        //[ cStencilBits: Number_Of_Bits: stencilbuffer]////[]//
        8,                                                //[]//
                                                          //[]//
        //[ cAuxBuffers : >=0                          ]////[]//
        //[ Number of Aux buffers in framebuffer.      ]////[]//
        0,                                                //[]//
                                                          //[]//
        //[ iLayerType: ------------------------------ ]////[]//
        0x0 /**PFD_MAIN_PLANE : Main Drawing Layer **/,   //[]//
                                                          //[]//
        //[ "byte reserved?" ---------]////[ --------- ]////[]//
        0, //[ bReserved    : IGNORED.]////[ --------- ]////[]//
                                         //[ --------- ]////[]//
                                         //[ --------- ]////[]//
        //[ MASKS: IGNORED ---------- ]////[ --------- ]////[]//
        0, //[ dwLayerMask  : IGNORED ]////[ --------- ]////[]//
        0, //[ dwVisibleMask: IGNORED ]////[ --------- ]////[]//
        0  //[ dwDamageMask : IGNORED ]////[ --------- ]////[]//                            
    };;     

    //:Quick smoke test in case I missed a param
    //:and my data is mis-aligned.
    if( 32 != p.cColorBits   ){
        F04_Halt( "[32!=p.cColorBits]" );
    };;
    if( 24 != p.cDepthBits  ){
        printf("[p.cDepthBits]:%d\n" , p.cDepthBits );
        F04_Halt( "[24!=p.cDepthBits]");
    };;
    if(  8 != p.cStencilBits ){
       F04_Halt( "[08!=p.cStencilBits]");
    };;
                                           
    //[ Copy Over To Global Variable ]// 
    f04_pixel_format_descriptor =( p );
    f04_InitPixelFormatDescriptor_DONE = 1;
                                           
} //[InitPixelFormatDescriptor]//          

//[SISISISISISISISISISISISISISISISISISISISISISISISISISISISISI]//


// ---------------------------------------------------------- //


////////////////////////////////////////////////////////////////

#define     MACRO_RETURNTYPE void*  ////////////////////////////
#define F03_MACRO_CreateWindowExW 1  ////////////////////////////


        #define MACRO_L       unsigned long
        #define MACRO_S_PTR   const unsigned short *
        #define MACRO_I       int
        #define MACRO_V_PTR   void *

    typedef  
        void* 
        (*F03_CreateWindowExW_TYPEDEF)(            
                
        MACRO_L      dwExStyle    /**DWORD     01 **/
    ,   MACRO_S_PTR  lpClassName  /**LPCWSTR   02 **/
    ,   MACRO_S_PTR  pWindowName  /**LPCWSTR   03 **/
    ,   MACRO_L      dwStyle      /**DWORD     04 **/
    ,   MACRO_I      X            /**          05 **/
    ,   MACRO_I      Y            /**          06 **/
    ,   MACRO_I      nWidth       /**          07 **/
    ,   MACRO_I      nHeight      /**          08 **/
    ,   MACRO_V_PTR  hWndParent   /**HWND      09 **/
    ,   MACRO_V_PTR  hMenu        /**HMENU     10 **/
    ,   MACRO_V_PTR  hInstance    /**HINSTANCE 11 **/
    ,   MACRO_V_PTR  lpParam      /**HINSTANCE 12 **/ 
 
        );

        #undef MACRO_L        
        #undef MACRO_S_PTR    
        #undef MACRO_I        
        #undef MACRO_V_PTR   

        #define MACRO_L       unsigned long
        #define MACRO_S_PTR   const unsigned short *
        #define MACRO_I       int
        #define MACRO_V_PTR   void *

    //:Can we abstract this further?
    void*
    F04_CreateWindowExW(


        MACRO_L      dwExStyle    /**DWORD     01 **/
    ,   MACRO_S_PTR  lpClassName  /**LPCWSTR   02 **/
    ,   MACRO_S_PTR  pWindowName  /**LPCWSTR   03 **/
    ,   MACRO_L      dwStyle      /**DWORD     04 **/
    ,   MACRO_I      X            /**          05 **/
    ,   MACRO_I      Y            /**          06 **/
    ,   MACRO_I      nWidth       /**          07 **/
    ,   MACRO_I      nHeight      /**          08 **/
    ,   MACRO_V_PTR  hWndParent   /**HWND      09 **/
    ,   MACRO_V_PTR  hMenu        /**HMENU     10 **/
    ,   MACRO_V_PTR  hInstance    /**HINSTANCE 11 **/
    ,   MACRO_V_PTR  lpParam      /**HINSTANCE 12 **/ 

    ){


              F03_CreateWindowExW_TYPEDEF
        fun =(F03_CreateWindowExW_TYPEDEF)
              F01_CreateWindowExW;

        void* ret=( fun(
            #define F03_MACRO_ARGS_CreateWindowEx 1

            dwExStyle    /**DWORD     01 **/
        ,   lpClassName  /**LPCWSTR   02 **/
        ,   pWindowName  /**LPCWSTR   03 **/
        ,   dwStyle      /**DWORD     04 **/
        ,   X            /**          05 **/
        ,   Y            /**          06 **/
        ,   nWidth       /**          07 **/
        ,   nHeight      /**          08 **/
        ,   hWndParent   /**HWND      09 **/
        ,   hMenu        /**HMENU     10 **/
        ,   hInstance    /**HINSTANCE 11 **/
        ,   lpParam      /**HINSTANCE 12 **/ 


            #undef  F03_MACRO_ARGS_CreateWindowEx
        ));

        return(  ret  );

    }//[CreateWindowExW]//

        #undef MACRO_L        
        #undef MACRO_S_PTR    
        #undef MACRO_I        
        #undef MACRO_V_PTR 

#undef      MACRO_RETURNTYPE     ///////////////////////////////
#undef  F03_MACRO_CreateWindowEx /////////////////////////////// 


    int
    F04_CreateWindowExW_TRY02(
   //     void*  dwExStyle    /**DWORD     01 **/
   // ,   void*  lpClassName  /**LPCWSTR   02 **/
   // ,   void*  pWindowName  /**LPCWSTR   03 **/
   // ,   void*  dwStyle      /**DWORD     04 **/
   // ,   void*  X            /**          05 **/
   // ,   void*  Y            /**          06 **/
   // ,   void*  nWidth       /**          07 **/
   // ,   void*  nHeight      /**          08 **/
   // ,   void*  hWndParent   /**HWND      09 **/
   // ,   void*  hMenu        /**HMENU     10 **/
   // ,   void*  hInstance    /**HINSTANCE 11 **/
   // ,   void*  lpParam      /**HINSTANCE 12 **/ 
   // 
    ){
      //  if(dwExStyle||lpClassName||pWindowName||dwStyle
      //  ||X||Y||nWidth||nHeight||hWndParent||hMenu||hInstance
      //  ||lpParam
      //  ){ /**NOOP**/ };
    
        return( 0 );
    }//[;]//

////////////////////////////////////////////////////////////////             

typedef const unsigned short *  TYPEDEF_LPCWSTR;


char*
F04_MakeIntResourceA( int i ){

    #define MACRO_16BITS unsigned short
    #define MACRO_64BITS unsigned long long
   
    MACRO_16BITS  wword = (MACRO_16BITS)i    ; //:TRUNCATE
    MACRO_64BITS  qword = (MACRO_64BITS)wword; //:ZERO_EXTEND
    char* ret_out=(char*)qword; //://////////////:CAST

    #define T unsigned short     //:TRUNCATE
    #define E unsigned __int64   //:ZERO_EXTEND
    #define C char*              //:CAST

    //: stackoverflow.com/questions/3610565
    char* ret_chk=((C)((E)((T)(i))));

    assert( ret_chk == ret_out );

    return( ret_out );

    #undef  MACRO_16BITS  //////////////////////////////////////
    #undef  MACRO_32BITS  //////////////////////////////////////
                          //////////////////////////////////////
    #undef  C  /////////////////////////////////////////////////
    #undef  E  /////////////////////////////////////////////////
    #undef  T  /////////////////////////////////////////////////
}//[;]//

////////////////////////////////////////////////////////////////

//:WinMsgHanWndPoc:WINDOW_MESSAGE_HANDLER_WNDPROC
__stdcall
__int64 //:LRESULT
F04_WinMsgHanWndPoc(
/**/           void*    Hw     //:HWND
,   unsigned   int      Msg    //:...?...
,   unsigned __int64    wParam //:WPARAM
,            __int64    lParam //:LPARAM
){
    //:An LRESULT tells us what we did
    //:with the message. If handled it
    //:should return zero.
    __int64 return_this_result = 0; //:LRESULT
    int ok = 0; //:BOOL

    //|SOURCE:winuser.h |___________|//
    //| wm_size    = 0x0005 ;       |//
    //| wm_keydown = 0x0100 ;       |//
    //| wm_keyup   = 0x0101 ;       |//
    //| wm_close   = 0x0010 ;       |//
    //| wm_destroy = 0x0002 ;       |//
    //| wm_paint   = 0x000F ;       |//
    //| vk_escape  = 0x001B ;       |//
    //|_____________________________|//

    switch(Msg){ //:- - - - - - - - - - - - - -://
    case 0x0005/**wm_size**/:{

        printf("[GLEB_SWIN:WM_SIZE]\n");
        fflush(stdout);

    }break;
    case 0x0100 /**wm_keydown**/:{
        if(wParam==0x001B /**vk_escape**/ ){

            ok = (int)(unsigned long long)
                 ((F02_01)(F01_DestroyWindow))(Hw);

            if(0==ok){F04_Halt("[0OK_1]");}

        }else{
            //:KEBO_DOWN_HandleVirtualKey( wParam );
        };;

    }break;

    case 0x0101 /**wm_keyup**/:{
        
            //:KEBO_UPPP_HandleVirtualKey( wParam );

    }break;

    //:WM_CLOSE: The "[X]" button was clicked.
    case 0x0010 /**wm_close**/:

        ok = (int)(unsigned long long)
            ((F02_01)(F01_DestroyWindow))(Hw);

        if(0==ok){F04_Halt("[0OK_2]");}

    //:WM_DESTROY: ( DESTROYED|DESTROYING )
    case 0x0002 /**wm_destroy**/:  
        //: Send "WM_QUIT" to exit msg loop.
        ((F02_01)F01_PostQuitMessage)(0);

    case 0x000F /**wm_paint**/:
        //:[TODO]:Something to pace the updating
        //:of graphics.


        //+ DELETE THIS BLOCK +//
        //- //:I dont think this is needed:         -//
        //- //: You may use the same HDC in both    -//
        //- //: threads, but not at the same time.  -//
        //- //: SEE[ gl-hdc-thread-quote ]          -//
        //- if(GLEB_SWIN.render_tick_function_has){ -//
        //-    GLEB_SWIN.render_tick_function();    -//
        //- };;                                     -//

        //: This might be better done setting a flag
        //: than using a callback. In order to prevent
        //: drawing code from being invoked on the
        //: wrong thread.

        //: With that said, setting a flag:
        //- ENGETHER.THREADING.InterlockedIncrement64( -//
        //-     &( GLEB_SWIN.THREAD_SAFE_FLAGS.        -//
        //-        redraw_message_count )              -//
        //- );;                                        -//

        
        //+ This call needs to be made from    +//
        //+ the same thread as your OpenGL     +//
        //+ calls.                             +//
        //# DONT_HERE:GLEB_SWIN_SwapBuffers(); #//





    //:Keep window responsive:
    default: 
        return_this_result=(
            (__int64)
            ((F02_04)(F01_DefWindowProcW))(
            /**/(void*)                     Hw  
            ,   (void*)(unsigned long long)Msg
            ,   (void*)                 wParam
            ,   (void*)                 lParam
            )
        );;
    };;//:- - - - - - - - - - - - - - - - - - -://

    return( return_this_result );
} //[F04_WinMsgHanWndPoc]//

////////////////////////////////////////////////////////////////


int //:BOOL
F04_RegisterWindow(
/**/                    void*  hInstance                
/**/,   const unsigned short*  unique_window_name    
){

    //|Smoke_Test:-----------------------|//
    size_t struct_size =(
        sizeof( struct F04_STRUCT_WNDCLASSEXW )
    );;
    if( struct_size != 80 ){
        F04_Halt("[BadStructSize]");
    };;//|-------------------------------|//
    
    //: WNDCLASSEXW W;
    struct F04_STRUCT_WNDCLASSEXW 
    W = {0};

    //| Winuser.h ClassStyles(CS_) |//
    #define T unsigned int  //////////
            T  cs_hredraw = 0x0002 ;//
            T  cs_vredraw = 0x0001 ;//
            T  cs_owndc   = 0x0020 ;//
    #undef  T ////////////////////////

    W.cbSize=sizeof( struct F04_STRUCT_WNDCLASSEXW );
    W.style=(
        cs_hredraw | //| Copied from glfw's:   |//
        cs_vredraw | //| win32_window.c        |//
        cs_owndc   | //| _gflwRegisterWindow   |//
                     //| ...ClassWin32         |//
    0);;
    W.lpfnWndProc=F04_WinMsgHanWndPoc;
    W.cbClsExtra=0;
    W.cbWndExtra=0;
    W.hInstance=hInstance;

    char* idi_application = F04_MakeIntResourceA( 32512 );
    char* idc_arrow       = F04_MakeIntResourceA( 32512 );

    W.hIcon  =((F02_02)F01_LoadIconA)(  
        NULL
    ,   idi_application
    );;
    W.hCursor=((F02_02)F01_LoadCursorA)(  
        NULL
    ,   idc_arrow
    );;

    //| Looking at:                            |//
    //| https://github.com/glfw/glfw/blob/     |//
    //| master/src/win32_window.c              |//
    //| does not look like background          |//
    //| brush color eneds to be set.           |//
    //|                                        |//
    //| Code here specifically says:           |//
    //| "No Background Required For GL"        |//
    //| http://nehe.gamedev.net/tutorial       |//
    //| /creating_an_opengl_window_(win32)     |//
    //| /13001/                                |//
    //- W.hbrBackground=(                      -//
    //-     /**/(HBRUSH)                       -// 
    //-     /**/ FP->GDI32.GetStockObject(     -// 
    //-     /**/     FP->GDI32.DATA.BRUSH.BLACK-// 
    //-     /**/)                              -// 
    //- );;                                    -//
    W.hbrBackground=NULL;

    W.lpszMenuName=NULL;
    W.lpszClassName=unique_window_name;
    W.hIconSm=(
        ((F02_02)F01_LoadIconA)(
            NULL
        ,   idi_application
        )
    );;

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|//
    //! If you forget to register your         !//
    //! window class, the observable effect    !//
    //! is the window never opening, and the   !//
    //! wait loop exiting immediately.         !//
    //|________________________________________|//
    return(
        (int)(unsigned long long)
        ((F02_01)F01_RegisterClassExW)(
            &( W )
        )
    );;
} //[Register]//


void //:gleb_swin_MakeWindowCompatibleWith_GL
f04_MakeWindowCompatibleWith_GL(
    void*  Hw /**HWND**/
){
    
    f04_InitPixelFormatDescriptor();

    void* /** HDC **/ 
    window_device_context =(
        ((F02_01)F01_GetWindowDC)( Hw ) /**user32**/
    );;
    int
    pixel_format_number=(
        (int)(unsigned long long)
        ((F02_02)F01_ChoosePixelFormat)( /**gdi32**/
            window_device_context
        , &( f04_pixel_format_descriptor )
        )
    );;
    int /** BOOL **/ 
    setting_pixel_format_worked=(
        (int)(unsigned long long)
        ((F02_03)F01_SetPixelFormat)(
        /**/
        /**/        window_device_context
        /**/    ,
        /**/        (void*)(unsigned long long)
        /**/        pixel_format_number
        /**/    ,
        /**/        &( f04_pixel_format_descriptor )
        )
    );;
    if( setting_pixel_format_worked ){
        //: printf("[SPF:OK]\n");
    }else{
        F04_Halt("[SPF:FAIL]\n");
    };;

    f04_window_device_context=(
        window_device_context
    );;

} //[MakeWindowCompatibleWith_GL]//


//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

int //:BOOL
f04_TakeOrLookMessage( 
/**/
    struct F04_STRUCT_MSG*
    dont_prefix_message_with_and_symbol /**LPMSG**/
    ,
    int    
    take_the_message
){

    unsigned int   look;
    unsigned int   take;
    unsigned int   look_or_take;

    look = 0x0000 /** pm_noremove **/ ;
    take = 0x0001 /** pm_remove   **/ ;
    look_or_take =(777);

    if( take_the_message > 0 ){
        look_or_take = take;
    }else
    if( 0 == take_the_message ){
        look_or_take = look;
    }else{
        F04_Halt("[Exp:Pos|Or|Zero]");
    };;

    int ret =(
    (int)(unsigned long long)
    ((F02_05)F01_PeekMessageW)(
        (void*)
        dont_prefix_message_with_and_symbol
        ,
        NULL
        ,
        0
        ,
        0
        ,
        (void*)(unsigned long long)
        look_or_take

    ));;

    return( ret );

} //[TakeOrLookMessage]//



int //:BOOL
f04_LookMessage(
    struct F04_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int look = 0;
    ret=f04_TakeOrLookMessage(msg,look);
    return( ret );
} //[LookMessage]//



int //:BOOL
f04_TakeMessage(
    struct F04_STRUCT_MSG* msg //:LPMSG
){
    int ret;
    const int take = 1;
    ret=f04_TakeOrLookMessage(msg,take);
    return( ret );
} //[TakeMessage]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//


struct F04_STRUCT_MSG //:MSG struct
f04_WindowLoop(
    void*  Hw //:HWND
){

    int sw_show = 5; //:Active window..
    void* show = (void*)(unsigned long long)sw_show;
    ((F02_02)F01_ShowWindow  )(  Hw, show  ); 
    ((F02_01)F01_UpdateWindow)(  Hw        ); 
    ((F02_01)F01_SetFocus    )(  Hw        );

    unsigned int  wm_quit =  0x12;          

    struct F04_STRUCT_MSG  
    M; //:MSG struct

    f04_LookMessage( &M );
    while(
        M.message
        !=
        wm_quit
    ){
        if( f04_TakeMessage(    &M )){

            ((F02_01)F01_TranslateMessage)( &M );

            ((F02_01)F01_DispatchMessageW)( &M );

        };;

    };;

    f04_window_just_closed = ('t'|'r'|'u'|'e');

   //: //# [HACK]:Sleep a bit so other threads    #//
   //: //#        see "window_just_closed" update.#//
   //: //# You really should use a proper mutex.  #//
    ((F02_01)F01_Sleep)( (void*)64 );

    return( M );

} //[WindowLoop]//


//: Call this function on a separate thread!
//: Refactor_Of:gleb_swin_OPEN_WINDOW_LOOP_FOREVER
unsigned __int64 //:WPARAM
F04_OpenWindowAndLoopForever(
    //:UNICODE_STRING
    const unsigned short *  //:LPCWSTR
    unique_window_name
){

     
    void* /**HMODULE**/ hin=(
        ((F02_01)F01_GetModuleHandleW)(
            NULL
        )
    );;//[a]//

    if(NULL==hin){
        F04_Halt(
            "[FailedToGetModuleHandle]"
        );;
    };;//[b]//

    /////////////////////////////////////
    void*                              //
    Hw = NULL;  //:HWND                //
                                       //
    struct F04_STRUCT_MSG              //
    Msg       ;   //:tagMSG (Struct)   //
    /////////////////////////////////////

    if(0 >=
        F04_RegisterWindow(
            hin
        ,   unique_window_name
        )
    ){ 

        F04_Halt( /** Originally: gleb_swin_Alert **/
            "[FailedToRegisterWindow]"
        );;
        return 0; 

    };;//[c]//

    int X   = f04_X   ; //:Initial_X_Position
    int Y   = f04_Y   ; //:Initial_Y_Position
    int WID = f04_WID ; //:Initial_WIDTH
    int HIG = f04_HIG ; //:Initial_HEIGHT

    unsigned long ws_overlappedwindow=( 0
    |   0x00000000L  /** WS_OVERLAPPED  **/
    |   0x00C00000L  /** WS_CAPTION     **/
    |   0x00080000L  /** WS_SYSMENU     **/
    |   0x00040000L  /** WS_THICKFRAME  **/
    |   0x00020000L  /** WS_MINIMIZEBOX **/
    |   0x00010000L  /** WS_MAXIMIZEBOX **/
    );;//[d]//

    unsigned long cs_owndc = 0x0020;

    //:NOOP's so I can comment out call to CreateWindowExW:
    if( cs_owndc            ){ /** NOOP **/ };
    if( ws_overlappedwindow ){ /** NOOP **/ };
    if( X|Y|WID|HIG         ){ /** NOOP **/ };
    if( hin                 ){ /** NOOP **/ };

    void*
    the_desktop_window=((F02_00)F01_GetDesktopWindow)();

    Hw=
        F04_CreateWindowExW
        //F04_CreateWindowExW_TRY02
    (

    /**/0x00000008L /** ws_ex_topmost **/
    ,   unique_window_name     
    ,   L"[GLEB_TITLE_BAR](題圌)"       
  
    , 
        (0
        |  ws_overlappedwindow /** STYLE **/   
        |  cs_owndc            /** STYLE **/
        |
        0)

    ,   X,Y,WID,HIG

    ,   the_desktop_window //:-- hWndParent ---://
    ,   NULL   //:-------------- hMenu      ---://
    ,   hin    //:-------------- hInstance  ---://        
    ,   NULL   //:-------------- lpParam    ---://  
    );//[e]//

    if(Hw==NULL){
        F04_Halt("[F04:WindowCreateFail]");
        return 0;
    };;//[f]//

    //:Store the handle to window in global state:
    f04_handle_to_window=Hw;

    //:Modifications to make window opengl
    //:compatible:
    //////////////////////////////////////////////
    f04_MakeWindowCompatibleWith_GL(
        Hw
    );;//[g]//

    //|¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯MC|//
    //!PUT AFTER device context has been     MC!//
    //!set, or your device context fetching  MC!//
    //!function waiting on this flag to be   MC!//
    //!set in this thread will end up        MC!//
    //!with a NULL device context.           MC!//
    //!Speaking Of:                          MC!//
    //!GLEB_SWIN_GetWindowDeviceContext();   MC!//
    f04_window_created=1;                 //|MC|//
    //|______________________________________MC|//

    //////////////////////////////////////////////

    Msg = f04_WindowLoop( Hw );

    return Msg.wParam;
} //[OPEN_WINDOW_LOOP_FOREVER]//


int F04_Demo_SingleThreaded(){
    F04_OpenWindowAndLoopForever(L"[CAJUN_SPICE]");
    return( 0 );
}//[;]//


//[ ]////|////////////////////////////////////////////|////[ ]//
//[ ]////|     -///-                        -///-     |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ BEG: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|       ______________________________       |////[ ]//
//[ ]////|______/                              \______|////[ ]//
#if(BOTTOM_OF_FILE_COMMENTS_SECTION) ///////////////////////////
/** ******************************************************** |||
                                                   
#VARS_TOP_OF_FILE_BIG_PICTURE#
    Variables are at the top of the file because they are
    what is most likely to be re-looked at when looking
    over the code months later.
                                                 
  
||| ******************************************************** **/ 
#endif /////////////////////////////////////////////////////////
//[ ]////|______                                ______|////[ ]//
//[ ]////|||||||\______________________________/|||||||////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|....(( 0 ))|| ||_ _--  --_ _|| ||(( 0 ))....|////[ ]//
//[ ]////|_  __      __  __  __  __  __  __      __  _|////[ ]//
//[ ]////| \/  \    /  \/  \/  \/  \/  \/  \    /  \/ |////[ ]//
//[ ]////|      \  /                        \  /      |////[ ]//
//[ ]////|       \/                          \/       |////[ ]//
//[ ]////+ END: #BOTTOM_OF_FILE_COMMENTS_SECTION#     +////[ ]//
//[ ]////|           /\                  /\           |////[ ]//
//[ ]////|          /  \                /  \          |////[ ]//
//[ ]////|_--__--__/    \__/\__/\__/\__/    \__--__--_|////[ ]//
//[ ]////|                                            |////[ ]//
//[ ]////|____________________________________________|////[ ]//
