//[ 01: Gather_Function_Pointers ]////|________|//

#include <string.h> //: strcmp

//:Fuck detailed function signatures.
//:Just use void function pointers for everything.
//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

//:Generic_Function_Pointer
typedef void (*VOF)(void);

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

void F01_Halt( const char* msg ){ 
    printf( msg ); fflush(stdout); exit(666);
}//[;]//

int F01_Same( const char* str_01, const char* str_02 ){
    return( 0 == strcmp( str_01, str_02 ) );
}//[;]//

//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//

    //:Declare Function Pointers: EX: VOF_ShowWIndow
    #define MAC(f,d) VOF  F01_  ##  f ;
            #include "01/F01.FUNCTION_LIST._"
    #undef  MAC


////////////////////////////////////////////////////////////////
//:Positive: The index of the loaded dll address in array.
//:Negative: The index to insert/cache next dll.
//:DO NOT USE TO PEEK! When returning negative, expects you
//:to add to the cache array.
#define MACRO_STR const char * /////////////////////////////////
static DLLL_DLIB F01_Cache_ADDR[1+10]={0}; //:DLL_CACHE.address
static MACRO_STR F01_Cache_NAME[1+10]={0}; //:DLL_CACHE.name
int F01_GetCacheIndex( const char* dlib_name ){

    int i = 0;while(1){ i++;
        
        assert( 0 != i ); //:Invalid_Cache_Index
        assert( i <= 10); //:Out_Of_Pre_Allocated_Slots

        if( NULL ==    F01_Cache_ADDR[i]){ return(  0-i  ); }
        if( F01_Same(  F01_Cache_NAME[i], dlib_name  )   ){
            return( i );
        };;

    };;

    assert( 0 ); //:CRASH! Should have returned already!
    return( 0 ); //:Return invalid index.

}//[;]//
#undef MACRO_STR ///////////////////////////////////////////////

int F01_GF_total_number_of_functions_fetched=0;
static VOF F01_GF( //:GF:Get_Function(Pointer)
/**/    const char* func_name //:EX:"ShowWindow"
/**/,   const char* dlib_name //:EX:"user32.dll"
){
    DLLL_DLIB  dlib_addr; //:DLL Module   Address
    DLLL_FUNC  func_addr; //:DLL Function Address
    ////////////////////////////////////////////////////////////
    //:GET DLL Module:
    ////////////////////////////////////////////////////////////
    int cac_dex = F01_GetCacheIndex( dlib_name );
    if( cac_dex > 0 ){

        dlib_addr = F01_Cache_ADDR[ cac_dex ];

    }else
    if( cac_dex < 0 ){

        dlib_addr = DLLL_LoadLibraryA(
        dlib_name );;

        F01_Cache_ADDR[ 0-cac_dex ] = dlib_addr;
        F01_Cache_NAME[ 0-cac_dex ] = dlib_name;

    }else{
        F01_Halt( "[EUBOC:ZERO_IS_INVALID_CACHE_INDEX]" );
    };;
    ////////////////////////////////////////////////////////////
    //:PULL Function From DLL:
    ////////////////////////////////////////////////////////////

        func_addr = DLLL_GetProcAddress( dlib_addr, func_name );

    ////////////////////////////////////////////////////////////

    F01_GF_total_number_of_functions_fetched++;
    return( (VOF)func_addr );

}//[;]//

//:Load Function Pointers: EX: VOF_ShowWindow
void F01_Init(){
    #define MAC(f,d) F01_ ## f = F01_GF(#f,#d);
            #include "01/F01.FUNCTION_LIST._"
    #undef  MAC

    if( F01_GF_total_number_of_functions_fetched != 2 ){
        F01_Halt("[Expected_This_Many_Fetched_Funcs]");
    };;

}//[;]//



//[XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]//