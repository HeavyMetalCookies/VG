//#FILE_REGION[ CP._ (CONSTPOOL) ]BEG#########################//


//|   Usage:                                        |//
//|                                                 |//
//|   CONSTPOOL_Init(); //:Before First Use         |//
//|                                                 |//
//|   const char**                                  |//
//|   arr = CONSTPOOL_Beg( sizeof(char*) );         |//
//|                                                 |//
//|         CONSTPOOL_Add( "ELEMENT_01" );          |//
//|         CONSTPOOL_Add( "ELEMENT_02" );          |//
//|         CONSTPOOL_Add( "ELEMENT_03" );          |//
//|   int                                           |//
//|   len = CONSTPOOL_End();                        |//
//|                                                 |//
//|   When done with all allocations and ready      |//
//|   to remove them all:                           |//
//|                                                 |//
//|   CONSTPOOL_Kill();                             |//
//|                                                 |//
//|   There is no "EMPTY()" method.                 |//
//|   This pool is for allocations that are not to  |//
//|   be touched until the program terminates.      |//

#include<stdlib.h> //: <-- for malloc(...)
#include <stdio.h> //:printf(...)

//:Dont bog down console with status messages:
//:Really you only want to see this when running this
//:code file in isolation as a demonstration.
int CONSTPOOL_tell_me_about_everything = 0;

//:Small enough to fit within a 32bit void*
struct constpool_SmallStruct{

    unsigned char A; //: 1 ://
    unsigned char B; //: 2 ://

};//[struct]//
struct constpool_TestStruct{

    //:This struct needs to be larger than the processor
    //:word size. So for x64, struct needs to be larger
    //:than 8bytes / 64bits

    //: 8bytes:
    unsigned char a; //: 1 ://
    unsigned char b; //: 2 ://
    unsigned char c; //: 3 ://
    unsigned char d; //: 4 ://
    unsigned char e; //: 5 ://
    unsigned char f; //: 6 ://
    unsigned char g; //: 7 ://
    unsigned char h; //: 8 ://

    //: Another 8 bytes:
    unsigned char A; //: 1 ://
    unsigned char B; //: 2 ://
    unsigned char C; //: 3 ://
    unsigned char D; //: 4 ://
    unsigned char E; //: 5 ://
    unsigned char F; //: 6 ://
    unsigned char G; //: 7 ://
    unsigned char H; //: 8 ://

    

};//[struct]//


char* constpool_testdata_ELEMENT_01 = "ELM_01";
char* constpool_testdata_ELEMENT_02 = "ELM_02";
char* constpool_testdata_ELEMENT_03 = "ELM_03";

//:Can never allocate more than this.
    const int /**PRIVATE**/
    constpool_size_in_bytes= 1024; 
//  constpool_size_in_bytes= 8; //:For observing of of memory
                                //:error.


unsigned char*  /**PRIVATE**/
constpool_pool=NULL;

////////////////////////////////////////////////////////////////
//nex      nex         nex      nex                           //
// |        |           |        |                            //
//[0][1][2][3][4][5][6][7][8][9][A]//                         //
// |     |  |        |  |     |                               //
//beg---end |        | beg---end                              //
//         beg------end                                       //
#define UI64 long long int /////////////////////////////////////
UI64 constpool_addr_nex   =0; //| The next "beg" value.      |//
UI64 constpool_addr_beg_T0=0; //| FIRST ADDRESS              |//
UI64 constpool_addr_end_T1=0; //| LAST  ADDRESS              |//
UI64 constpool_current_allocation_size_double_check=0;      
#undef  UI64 ///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

int constpool_entry_size=0;



/** AKA: constpool_curalloc_in_elements **/
int constpool_num_entries_made=0;



int constpool_has_been_unit_tested = 0;
int constpool_unit_test_is_running = 0;

extern void CONSTPOOL_UnitTest( void ); //:FORWARD_DECLARATION

int constpool_initialized = 0;

////////////////////////////////////////////////////////////////

void
constpool_Halt( const char* msg ){

    printf("[constpool_Halt]:[msg]:%s\n", msg );
    fflush(stdout);
    exit(666);

}//[;]//
void
constpool_Tell( const char* msg ){

    if( CONSTPOOL_tell_me_about_everything > 0 ){

        printf("[constpool_Tell]:[msg]:%s\n", msg );
        fflush(stdout);

    };;

}//[;]//////////////////////////////////////////////////////////
void
constpool_Print_01( const char* fmt, void* data ){

    if( CONSTPOOL_tell_me_about_everything > 0 ){
    printf( fmt, data );
    };;

}//[;]//////////////////////////////////////////////////////////
void
constpool_Print_00( const char* fmt ){
    
    if( CONSTPOOL_tell_me_about_everything > 0){
    printf( fmt ); //:FormatStringNoArguments
    };;

}//[;]//////////////////////////////////////////////////////////
void //:UC: Unsigned Char
constpool_Print_UC( const char* fmt, unsigned char data ){

    if( CONSTPOOL_tell_me_about_everything > 0 ){
    printf( fmt, data );
    };;

}//[;]//////////////////////////////////////////////////////////
void //:SI: Signed Integer
constpool_Print_SI( const char* fmt, signed int data ){

    if( CONSTPOOL_tell_me_about_everything > 0 ){
    printf( fmt, data );
    };;

}//[;]//////////////////////////////////////////////////////////
void //:SI: Signed Integer
constpool_Print_STR( const char* fmt, const char* data ){

    if( CONSTPOOL_tell_me_about_everything > 0 ){
    printf( fmt, data );
    };;

}//[;]//////////////////////////////////////////////////////////
void*                   //| 1.Begings allocating             |//
CONSTPOOL_Beg(          //| 2.Returns begin memory address   |//
    int   entry_size    /** << size of one added element     **/
){ 

    constpool_num_entries_made                    = 0;
    constpool_current_allocation_size_double_check= 0;

    constpool_entry_size =(
              entry_size   );;

    constpool_addr_beg_T0=(
        constpool_addr_nex
    );;

    //:Invalid trap value for end value: #T1_TRAP#
    constpool_addr_end_T1=(
    constpool_addr_beg_T0-1 );;//:MUST_BE_NEGATIVE_ONE

    return( 
        &( constpool_pool[ constpool_addr_beg_T0 ] )
    );;

}//[;]//////////////////////////////////////////////////////////


const void*             //| 1.Add new element to allocation  |//
constpool_private_Add(  //| 2.Return address of allocation   |//
    void* entry_data    /** << data of one added element     **/
   ,int passed_by_value
 ){ 

    //| The number of entries made in the current_scope.     |//
    //| constpool_beg                                        |//
    //|                                                      |//
    //|  //:current_scope:THIS_SCOPE_HERE                    |//
    //|                                                      |//
    //| constpool_end                                        |//
    constpool_num_entries_made++;

    int element_offset =(constpool_num_entries_made-1);
    int byte_offset=( element_offset * constpool_entry_size );

    //:Are we out of space?
    ////////////////////////////////////////////////////////////
    //[ Inclusive range of allocated memory]//
    //|  |---A---||---B---||---C---|       |//
    //|  [0][1][2][3][4][5][6][7][8][9][A] |//
    //|   |                       |        |//
    //| constpool_addr_beg_T0     |        |//
    //|           constpool_addr_end_T1    |//
    constpool_addr_end_T1=(
        //:We are not starting at zero!
        constpool_addr_beg_T0
        +
        byte_offset
        +
       (constpool_entry_size-1)
    );;

    int last_memory_index = (constpool_size_in_bytes-1);
    if( constpool_addr_end_T1 > last_memory_index ){
        constpool_Halt("[OUT_OF_MEMORY:Increase_Limits!]");
    };;

    ////////////////////////////////////////////////////////////

    if( passed_by_value > 0 ){
        //[ #BF01_COMMENT_TAG# ///////////////////////////// ]//
        //:FIX: T0 was previously set to "byte_offset"
        //:     which meant all memory kept getting written
        //:     to the beginning of the allocation!
        #define T0 (constpool_addr_beg_T0 + byte_offset)
        #define CP char* ///////////////////////////////////////
        //:Memcpy:
        //:Use (&entry_data) not (entry_data) because we want
        //:to copy the actual bytes of data inside the void*.
        //:The void* type is "generic data" not a 
        //:"pointer to whatever". (In this current context)
        ////////////////////////////////////////////////////////
        char* mem_src = (char*) (&entry_data) ;
        char* mem_dst = (char*)&( constpool_pool[ T0 ] );
        for( int i = 0; i < constpool_entry_size; i++ ){
                mem_dst[ i ] = mem_src[ i ];
        };;
        ////////////////////////////////////////////////////////
    }else{

        //:Passed By Reference:
        ////////////////////////////////////////////////////////
        char* mem_src = (char*) (entry_data) ;
        char* mem_dst = (char*)&( constpool_pool[ T0 ] );
        for( int i = 0; i < constpool_entry_size; i++ ){
                mem_dst[ i ] = mem_src[ i ];
        };;
        ////////////////////////////////////////////////////////

        #undef  CP /////////////////////////////////////////////
        #undef  T0 /////////////////////////////////////////////
    };;
    




    constpool_current_allocation_size_double_check+=(
        constpool_entry_size
    );;

    if( 
        (constpool_addr_end_T1 - constpool_addr_beg_T0 + 1)
        !=
        constpool_current_allocation_size_double_check
    ){
        constpool_Halt(
            "[CONSTPOOL(CP.C11):AllocationSizeCheckFail]\n"
        );;
     
    };;
        
    return( &( constpool_pool[ byte_offset ] ) );

}//[;]//////////////////////////////////////////////////////////
const void*
CONSTPOOL_Add_ByVal(
    void* entry_data 
){
    const void* ret = NULL;
    
    ret = constpool_private_Add(
        entry_data
    ,   1 /** passed_by_value == true **/
    );;

    return( ret );

}//[;]//////////////////////////////////////////////////////////
const void*
CONSTPOOL_Add_ByRef(
    void* entry_data 
){
    const void* ret = NULL;
    
    ret = constpool_private_Add(
        entry_data
    ,   0 /** passed_by_value == true **/
    );;

    return( ret );

}//[;]//////////////////////////////////////////////////////////
int                     //| 1. Ends allocation           --- |//
CONSTPOOL_End(          //| 2. Returns allocation size   --- |//
    void*  ptr_beg      /** ptr_beg: Pointer to address      **/
){                      /** returned by CONSTPOOL_Beg        **/

    //:ptr_beg is really a void** not void*.
    //:But signature is void* for ease of parameter passing.
    void** PTR_BEG = (void**)ptr_beg;

    if(0==PTR_BEG){
        constpool_Halt("[Invalid:PTR_BEG]");
    };;
    void* beg = (*PTR_BEG);
    if( beg != &( constpool_pool[ constpool_addr_beg_T0 ] ) ){

        //:OACPMM:Opening_And_Closing_Pointers_Must_Match
        constpool_Halt("[OACPMM]");

    };;
    
    //:If no entries were made, the initial address given
    //:to the pointer was invalid. Change it back to zero/null.
    if( constpool_num_entries_made == 0 ){
        (*PTR_BEG) = NULL;
    };;

    //:Next Byte After Previous Allocation:
    //:If no allocations were made, +1 is added
    //:to the trap value, and you end up where you
    //:began. SEE[ #T1_TRAP# ]
    constpool_addr_nex=constpool_addr_end_T1+1;

    int expected_len =(
        constpool_current_allocation_size_double_check
        /
        constpool_entry_size
    );;

    if( expected_len != constpool_num_entries_made ){
        constpool_Halt("[EpectedLenFail]\n");
    };;

    return(
        constpool_num_entries_made
    );;

}//[;]//////////////////////////////////////////////////////////
void
CONSTPOOL_Init( void ){

    if( constpool_has_been_unit_tested != 1 &&
        constpool_unit_test_is_running != 1
    ){  CONSTPOOL_UnitTest(); }

    if( constpool_initialized != 0 ){
        constpool_Halt("[Already_Initialized]");
    };;

    constpool_initialized = 1 ;

    //:Allocate the pool.
    constpool_pool=calloc(
        1 //:<--1 pool. It is a singleton.
    ,   constpool_size_in_bytes
    );;

    //:After allocating, first free address is
    //:the start of the allocation:
    //:Address is relative to the pool.
    constpool_addr_nex=( 0 );; 
    constpool_addr_beg_T0=( 0   );
    constpool_addr_end_T1=( 0-1 ); //:Invalid endpoint
                                   //:must start at negative 1.
                                   //:(first invalid value)


}//[;]//////////////////////////////////////////////////////////
void
CONSTPOOL_Kill( void ){
    constpool_Tell("[BEG:Kill]");

    if( constpool_initialized != 1 ){
        constpool_Halt("[Already_Killed]");
    };;

    free( constpool_pool );
          constpool_pool=NULL;

    //:Set some of our counters to trap values:
      constpool_addr_nex     = (0-888);
      constpool_addr_beg_T0  = (0-777);
      constpool_addr_end_T1  = (0-666);

    constpool_initialized = 0;
 
    constpool_Tell("[END:Kill]");   
}//[;]//////////////////////////////////////////////////////////
void
CONSTPOOL_UnitTest( void ){
    constpool_Tell("[BEG:CONSTPOOL_UnitTest]\n");
    constpool_has_been_unit_tested = 0;
    constpool_unit_test_is_running = 1;
    CONSTPOOL_Init( );

        //:Very small allocation, so I can see 1 allocation
        //:work, then another fail because out of space.
        #define UI08 unsigned char /////////////////////////////

        UI08* a = CONSTPOOL_Beg( sizeof( UI08 ) );
        CONSTPOOL_Add_ByVal( (void*)1 );
        CONSTPOOL_Add_ByVal( (void*)2 );
        CONSTPOOL_Add_ByVal( (void*)3 );
        int l = CONSTPOOL_End( &a );

        if( l != 3 ){ constpool_Halt("[NotLen3:L]"); };
        constpool_Tell("[Small_Alloc_Worked]");

        #undef  UI08 ///////////////////////////////////////////

    CONSTPOOL_Kill( );
    CONSTPOOL_Init( );
    // ------------------------------------------------------ //

        const char**
        arr = CONSTPOOL_Beg( sizeof(char*) ); 
                      
        constpool_Tell("[Adding...]");

            #define VAL  CONSTPOOL_Add_ByVal ///////////////////

                    VAL( "ELEMENT_01" );  
                    VAL( "ELEMENT_02" );  
                    VAL( "ELEMENT_03" ); 
                    
                    VAL( constpool_testdata_ELEMENT_01 ); 
                    VAL( constpool_testdata_ELEMENT_02 ); 
                    VAL( constpool_testdata_ELEMENT_03 ); 

            #undef  VAL ////////////////////////////////////////

        constpool_Tell("[Done_Adding]");
 
        constpool_Tell("[Ending...]");
        int                                   
        len = CONSTPOOL_End( &arr );  
        constpool_Tell("[DoneEnding]");

        if( len != 6 ){
            constpool_Halt("[BadLengthInElementUnits]");
        }else{
            constpool_Tell("[GoodLen3]");
        };;

        if( arr ){ /** NOOP **/ };

        #define PS constpool_Print_STR /////////////////////////
            PS("arr[0]:%s\n" , arr[0] );
            PS("arr[1]:%s\n" , arr[1] );
            PS("arr[2]:%s\n" , arr[2] );
            PS("arr[3]:%s\n" , arr[3] );
            PS("arr[4]:%s\n" , arr[4] );
            PS("arr[5]:%s\n" , arr[5] );
        #undef  PS /////////////////////////////////////////////

    // ------------------------------------------------------ //
    CONSTPOOL_Kill( );
    CONSTPOOL_Init(  );

        //:Try to store integers.
        //:sizeof(int)
        const int*
        arr2 = CONSTPOOL_Beg( sizeof( int ) );


        #define VAL  CONSTPOOL_Add_ByVal ///////////////////////

                VAL( (void*)1       );
                VAL( (void*)200     );
                VAL( (void*)30000   );
                VAL( (void*)4000000 );

        #undef  VAL ////////////////////////////////////////////

        int
        len2 = CONSTPOOL_End( &arr2 );

        #define PI constpool_Print_SI //////////////////////////
                PI("[len2]:%d\n", len2 );
                PI("[arr2[0]]:%d\n", arr2[0]);
                PI("[arr2[1]]:%d\n", arr2[1]);
                PI("[arr2[2]]:%d\n", arr2[2]);
                PI("[arr2[3]]:%d\n", arr2[3]);
        #undef  PI /////////////////////////////////////////////

    CONSTPOOL_Kill();
    CONSTPOOL_Init( );

        //:Try to store a struct by VALUE, not reference.
        //:sizeof( struct constpool_TestStruct )

        const struct constpool_TestStruct*
        arr3 = CONSTPOOL_Beg(
            sizeof( struct constpool_TestStruct )
        );;

        struct constpool_TestStruct s1 = { 0 };
        struct constpool_TestStruct s2 = { 0 };
        struct constpool_TestStruct s3 = { 0 };

        s1.A = 'A';
        s2.h = 'h';
        s3.E = 'E';

        CONSTPOOL_Add_ByRef( (void*) &s1 );
        CONSTPOOL_Add_ByRef( (void*) &s2 );
        CONSTPOOL_Add_ByRef( (void*) &s3 );

        int
        len3 = CONSTPOOL_End( &arr3 );
        
        #define PI constpool_Print_SI //////////////////////////
        #define PC constpool_Print_UC //////////////////////////
                PI("[len3]:%d\n", len3 );
                PC("[arr3[0].A]:%c\n", arr3[0].A);
                PC("[arr3[1].h]:%c\n", arr3[1].h);
                PC("[arr3[2].E]:%c\n", arr3[2].E);
        #undef  PC /////////////////////////////////////////////
        #undef  PI /////////////////////////////////////////////
    CONSTPOOL_Kill();
    CONSTPOOL_Init();

        const struct constpool_SmallStruct*
        arr4 = CONSTPOOL_Beg(
            sizeof( struct constpool_SmallStruct )
        );;

        struct constpool_SmallStruct ss1 = { 0 };
        struct constpool_SmallStruct ss2 = { 0 };
        struct constpool_SmallStruct ss3 = { 0 };

        ss1.A = 'A';
        ss2.B = 'B';
        ss3.A = 'a';

        //:Though the small struct can fit within
        //:a pointer, I am not allowed to convert
        //:it to a pointer.
        CONSTPOOL_Add_ByRef( (void*)  &ss1 );
        CONSTPOOL_Add_ByRef( (void*)  &ss2 );
        CONSTPOOL_Add_ByRef( (void*)  &ss3 );

        CONSTPOOL_Add_ByRef( (void*)  &ss1 );
        CONSTPOOL_Add_ByRef( (void*)  &ss2 );
        CONSTPOOL_Add_ByRef( (void*)  &ss3 );

        int
        len4 = CONSTPOOL_End( &arr4 );
        #define PI constpool_Print_SI //////////////////////////
                PI("[len4]:%d\n", len4 );
        #undef  PI /////////////////////////////////////////////

        for( int i = 0; i < len4; i++ ){
            #define P0 constpool_Print_00 //////////////////////
            #define P1 constpool_Print_01 //////////////////////
            #define PC constpool_Print_UC //////////////////////

                    P0("\n");
                    PC("[arr4[i].A]:%c\n", arr4[i].A);
                    PC("[arr4[i].B]:%c\n", arr4[i].B);
                    P0("\n");

            #undef  P0 /////////////////////////////////////////
            #undef  P1 /////////////////////////////////////////
            #undef  PC /////////////////////////////////////////
        };;

    CONSTPOOL_Kill();
    CONSTPOOL_Init();

        //:What about the case of allocating NOTHING?
        const char**
        arr5 = CONSTPOOL_Beg( sizeof(char*) );

            //:Dont add anything.

        int
        len5 = CONSTPOOL_End( &arr5 );

        if( len5 != 0 ){
            constpool_Halt("[Len5_Not_Zero]");
        }else{
            constpool_Tell("[Len5_Is_Zero!]");
        };;

        if( arr5 != 0 ){
            constpool_Halt("[CONSTPOOL/CP._:NOT_ZERO]\n");
        }else{
            constpool_Tell("[arr5_was_zeroed]");
        };;

        //:Try another allocation. Make the allocation
        //:exactly 1 byte, thus the address returned should
        //:be the same address as the pool itself.
        const unsigned char*
        arr6 = CONSTPOOL_Beg( sizeof( unsigned char ) );

            CONSTPOOL_Add_ByVal( (void*)'A' );

        int
        len6 = CONSTPOOL_End( &arr6 );

        if( len6 != 1 ){
            constpool_Halt("[ExpectedLen==1]");
        };;
        if( arr6[0] != 'A' ){ 
            constpool_Halt("[Not_A]");
        };;

        if( arr6 != constpool_pool ){
            constpool_Halt("[Expected_At_Base]");
        }else{
            constpool_Tell("[AtBaseAsExpected]");
        };;


    CONSTPOOL_Kill();
    CONSTPOOL_Init();
    //[#BF01_COMMENT_TAG# ////////////////////////////////// ]//
    //[ BF01:Bug_Fix_01. This found allocation bug. ---------]//
    //[                  On DATE[2019_01_01] ----------------]//
    //[ BF01||BF01||BF01||BF01||||||||BF01||BF01||BF01||BF01 ]//
        #define BEG CONSTPOOL_Beg       ////////////////////////
        #define END CONSTPOOL_End       ////////////////////////
        #define VAL CONSTPOOL_Add_ByVal ////////////////////////

        if( sizeof(int) == sizeof(unsigned char) ){

            constpool_Halt("[TestExpectsTypesOfDifferentSize]");
    
        };;

        int   len7 = 0;
        void* arr7 = NULL;

        //:I think the memory will get TRAMPLED.
        //:Test that hypothesis.
        int* int_arr_01 = NULL;
        int* int_arr_02 = NULL;
        int* int_arr_03 = NULL;

        //:Since iam observing trampled memory, my guess is
        //:constpool_beg_T0 and constpool_end_T1 variables
        //:are not correct. Check those.
        ////////////////////////////////////////////////////////
        int arr_01_beg = 0; //:constpool_addr_beg_T0 (INDEX)
        int arr_01_end = 0; //:constpool_addr_end_T1 (INDEX)
                         
        int arr_02_beg = 0; //:constpool_addr_beg_T0 (INDEX)
        int arr_02_end = 0; //:constpool_addr_end_T1 (INDEX)
                         
        int arr_03_beg = 0; //:constpool_addr_beg_T0 (INDEX)
        int arr_03_end = 0; //:constpool_addr_end_T1 (INDEX)
        ////////////////////////////////////////////////////////

        arr7=BEG( sizeof( int ) );

            VAL( (void*)1000 );

        len7 = END( &arr7 );
        arr_01_beg=(int)constpool_addr_beg_T0;
        arr_01_end=(int)constpool_addr_end_T1;
        if( len7 != 1 ){ constpool_Halt("[len7!=2(a)]"); };
        int_arr_01=arr7;
        arr7=BEG( sizeof( int ) );

            VAL( (void*)1111 );
            VAL( (void*)2222 );

        len7 = END( &arr7 );
        arr_02_beg=(int)constpool_addr_beg_T0;
        arr_02_end=(int)constpool_addr_end_T1;
        if( len7 != 2 ){ constpool_Halt("[len7!=2(b)]"); };
        int_arr_02=arr7;
        arr7=BEG( sizeof( int ) );

            VAL( (void*)1010 );
            VAL( (void*)2020 );
            VAL( (void*)3030 );

        len7 = END( &arr7 );
        arr_03_beg=(int)constpool_addr_beg_T0;
        arr_03_end=(int)constpool_addr_end_T1;
        if( len7 != 3 ){ constpool_Halt("[len7!=3]"); };
        int_arr_03=arr7;
        void* after_adding_integers_address=arr7;


        //:Show me what you've got:
        //:This printout looks correct!
        //:(The values describe an inclusive range of the)
        //:(allocated bytes)
        ////////////////////////////////////////////////////////

        #define P_SI constpool_Print_SI ////////////////////////
        constpool_Print_00("\n\n");
        P_SI("[arr_01_beg]:%d]\n", arr_01_beg);
        P_SI("[arr_01_end]:%d]\n", arr_01_end);

        P_SI("[arr_02_beg]:%d]\n", arr_02_beg);
        P_SI("[arr_02_end]:%d]\n", arr_02_end);

        P_SI("[arr_03_beg]:%d]\n", arr_03_beg);
        P_SI("[arr_03_end]:%d]\n", arr_03_end);
        constpool_Print_00("\n\n");
        #undef P_SI ////////////////////////////////////////////

        // |  4bytes|  |     8bytes          ||
        // |--------|  |---------------------||
        //[0][1][2][3][4][5][6][7][8][9][10][11]//

        // ||------------------12 bytes----------------||
        // ||-----------3 integers. Each 4 bytes ------||
        // ||----------||  ||----------||  ||----------||
        //[12][13][14][15][16][17][18][19][20][21][22][23]//

        ////////////////////////////////////////////////////////

        //:Setting up memory to get trampled, but printouts
        //:shoulld work here:
        ////////////////////////////////////////////////////////
        #define P_SI constpool_Print_SI ////////////////////////
        constpool_Print_00("\n\n");
        P_SI("[int_arr_01[0]]:%d\n", int_arr_01[0]);

        P_SI("[int_arr_02[0]]:%d\n", int_arr_02[0]);
        P_SI("[int_arr_02[1]]:%d\n", int_arr_02[1]);

        P_SI("[int_arr_03[0]]:%d\n", int_arr_03[0]);
        P_SI("[int_arr_03[1]]:%d\n", int_arr_03[1]);
        P_SI("[int_arr_03[2]]:%d\n", int_arr_03[2]);
        constpool_Print_00("\n\n");
        #undef P_SI ////////////////////////////////////////////

        #define H constpool_Halt ///////////////////////////////
        if( int_arr_01[0] != 1000 ){ H("[STOMP_01]");}

        if( int_arr_02[0] != 1111 ){ H("[STOMP_02]");}
        if( int_arr_02[1] != 2222 ){ H("[STOMP_03]");}

        if( int_arr_03[0] != 1010 ){ H("[STOMP_04]");}
        if( int_arr_03[1] != 2020 ){ H("[STOMP_05]");}
        if( int_arr_03[2] != 3030 ){ H("[STOMP_06]");}
        #undef  H //////////////////////////////////////////////
        ////////////////////////////////////////////////////////
        

        //:Pretty sure some faulty indexing code will cause
        //:crash if now I add something of a SMALLER SIZE
        //:than the previous integers.
        arr7=BEG( sizeof( unsigned char ) );

            VAL( (void*)'A' );
            VAL( (void*)'B' );
            VAL( (void*)'C' );

        len7 = END( &arr7 );
        if(len7!=3){ constpool_Halt("[len7!=3(b)]"); };
        
        void* after_adding_bytes_address=arr7;

        if(    after_adding_bytes_address 
            <= after_adding_integers_address 
        ){

            constpool_Halt("[Indexing_Calculations_Incorrect]");
        
        };;

        constpool_Tell("[BiggerThanSmallerTestPassed]\n");

        #undef  VAL  ///////////////////////////////////////////
        #undef  BEG  ///////////////////////////////////////////
        #undef  END  ///////////////////////////////////////////
    //[ BF01||BF01||BF01||BF01||||||||BF01||BF01||BF01||BF01 ]//
    //[ #BF01_COMMENT_TAG# ///////////////////////////////// ]//
    CONSTPOOL_Kill();
    CONSTPOOL_Init();
        #define BEG CONSTPOOL_Beg       ////////////////////////
        #define END CONSTPOOL_End       ////////////////////////
        #define VAL CONSTPOOL_Add_ByVal ////////////////////////

        int   len8 = 0;
        void* arr8 = NULL;

        ////////////////////////////////////////////////////////

        //:Add smaller sized types:
        ////////////////////////////////////////////////////////
        arr8=BEG( sizeof( unsigned char ) );

            VAL( (void*)'A' );
            VAL( (void*)'B' );
            VAL( (void*)'C' );

        len8 = END( &arr8 );
        if(len8!=3){ constpool_Halt("[len8!=3(b)]"); };
        ////////////////////////////////////////////////////////
        
        //:Now add bigger types:
        ////////////////////////////////////////////////////////

        arr8=BEG( sizeof( int ) );

            VAL( (void*)1 );

        len8 = END( &arr8 );
        if( len8 != 1 ){ constpool_Halt("[len8!=2(a)]"); };
        arr8=BEG( sizeof( int ) );

            VAL( (void*)1 );
            VAL( (void*)2 );

        len8 = END( &arr8 );
        if( len8 != 2 ){ constpool_Halt("[len8!=2(b)]"); };
        arr8=BEG( sizeof( int ) );

            VAL( (void*)1 );
            VAL( (void*)2 );
            VAL( (void*)3 );

        len8 = END( &arr8 );
        if( len8 != 3 ){ constpool_Halt("[len8!=3]"); };

        ////////////////////////////////////////////////////////

        constpool_Tell("[SmallThenBigTestPassed]\n");

        #undef  VAL  ///////////////////////////////////////////
        #undef  BEG  ///////////////////////////////////////////
        #undef  END  ///////////////////////////////////////////
    CONSTPOOL_Kill();
    CONSTPOOL_Init();
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////

        //[Recreate problem in your code with string arrays: ]//

        //| To find the problem, query what we expect to be  |//
        //| the internal state of our CONSTPOOL allocator    |//
        //| and see if anything is amiss.                    |//


        #define P_UC constpool_Print_UC
        P_UC("[nex...]:%d\n"   ,(int)constpool_addr_nex   );
        P_UC("[beg_T0]:%d\n"   ,(int)constpool_addr_beg_T0);
        P_UC("[end_T1]:%d\n"   ,(int)constpool_addr_end_T1);
        #undef P_UC

        #define H constpool_Halt ///////////////////////////////
        if( constpool_addr_nex    != 0     ){ H("CP_F36_NEX"); }
        if( constpool_addr_beg_T0 != 0     ){ H("CP_F36_BEG"); }
        if( constpool_addr_end_T1 != 0 - 1 ){ H("CP_F36_END"); }
        #undef  H //////////////////////////////////////////////

        //====================================================//

        //:constpool_F36_names:F36_wanted_validation_layers
        //:constpool_F36_count:F36_wanted_validation_layers_count
        static char** constpool_F36_names=NULL;
        int           constpool_F36_count=0;

        #define BEG CONSTPOOL_Beg       ////////////////////////
        #define END CONSTPOOL_End       ////////////////////////
        #define VAL CONSTPOOL_Add_ByVal ////////////////////////

        constpool_F36_names=( BEG( sizeof( char* ) ) );;
            
            //:Do nothing. Project was not using validation
            //:layers at time of crash.

        constpool_F36_count=(
        END(&constpool_F36_names)  );

        #undef  VAL  ///////////////////////////////////////////
        #undef  BEG  ///////////////////////////////////////////
        #undef  END  ///////////////////////////////////////////

        #define P_SI constpool_Print_SI ////////////////////////
        P_SI(
            "[constpool_F36_count]:%d\n",
              constpool_F36_count
        );;

        //:Nothing was added, so the next relative
        //:address/index should still be zero:
        if( constpool_addr_nex != 0 ){ 
            P_SI("[constpool_addr_nex]:%d\n"
               ,(int)constpool_addr_nex);
            constpool_Halt("AYEEEEE!");
        };;
        #undef P_SI ////////////////////////////////////////////

        //[PC_2019_01_01:Problem_Causer                      ]//
        //|Originally replicating segfault in my vulkan code |//
        //|removing this chunk would make segfault go away.  |//
        //|Adding it back would make segfault appear.        |//
        //====================================================//
        //====================================================//
        //====================================================// //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        char* constpool_VK_KHR_surface=(                         //[PC_2019_01_01]//
            "VK_KHR_surface"                                     //[PC_2019_01_01]//
        );;                                                      //[PC_2019_01_01]//
        char* constpool_VK_KHR_win32_surface=(                   //[PC_2019_01_01]//
            "VK_KHR_win32_surface"                               //[PC_2019_01_01]//
        );;                                                      //[PC_2019_01_01]//
        if( constpool_VK_KHR_surface       ){ /** NOOP **/ };    //[PC_2019_01_01]//
        if( constpool_VK_KHR_win32_surface ){ /** NOOP **/ };    //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        //:constpool_F37_names:                                  //[PC_2019_01_01]//
        //:         F37_wanted_instance_extensions               //[PC_2019_01_01]//
        //:constpool_F37_count:                                  //[PC_2019_01_01]//
        //:         F37_wanted_instance_extensions_count         //[PC_2019_01_01]//
        static char** constpool_F37_names = NULL;                //[PC_2019_01_01]//
        static int    constpool_F37_count = (0-1);               //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        #define BEG CONSTPOOL_Beg       //////////////////////// //[PC_2019_01_01]//
        #define END CONSTPOOL_End       //////////////////////// //[PC_2019_01_01]//
        #define VAL CONSTPOOL_Add_ByVal //////////////////////// //[PC_2019_01_01]//
        #define len constpool_F37_count //////////////////////// //[PC_2019_01_01]//
        #define arr constpool_F37_names //////////////////////// //[PC_2019_01_01]//
                arr=BEG( sizeof( char* ) );                      //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
                    VAL( &"VK_KHR_surface");                     //[PC_2019_01_01]//
                    VAL( &"VK_KHR_win32_surface");               //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
                    // VAL( constpool_VK_KHR_surface       );    //[PC_2019_01_01]//
                    // VAL( constpool_VK_KHR_win32_surface );    //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
                len=END( &arr );                                 //[PC_2019_01_01]//
        #undef  len  /////////////////////////////////////////// //[PC_2019_01_01]//
        #undef  VAL  /////////////////////////////////////////// //[PC_2019_01_01]//
        #undef  BEG  /////////////////////////////////////////// //[PC_2019_01_01]//
        #undef  END  /////////////////////////////////////////// //[PC_2019_01_01]//
        #undef  arr  /////////////////////////////////////////// //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        //:Check to make sure you can access like you think:     //[PC_2019_01_01]//
        constpool_Print_SI(                                                  //[PC_2019_01_01]//
            "[constpool_F37_count]:%d\n",                        //[PC_2019_01_01]//
              constpool_F37_count                                //[PC_2019_01_01]//
        );;                                                      //[PC_2019_01_01]//
        constpool_Print_STR(                                                  //[PC_2019_01_01]//
            "[constpool_F37_names[0]]:%s\n",                     //[PC_2019_01_01]//
              constpool_F37_names[0]                             //[PC_2019_01_01]//
        );;                                                      //[PC_2019_01_01]//
        constpool_Print_STR(                                                  //[PC_2019_01_01]//
            "[constpool_F37_names[1]]:%s\n",                     //[PC_2019_01_01]//
              constpool_F37_names[1]                             //[PC_2019_01_01]//
        );;                                                      //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        int pointer_size = sizeof( char* );                      //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        //:Two strings were added (By passing the address)       //[PC_2019_01_01]//
        //:(to the first character in them.)                     //[PC_2019_01_01]//
        //:Slots 0 and 1 thus should be used up.                 //[PC_2019_01_01]//
        //:Next available should be 2.                           //[PC_2019_01_01]//
        //:WAIT... no... It should be 2*sizeof(char*)            //[PC_2019_01_01]//
        if( constpool_addr_nex == 2 ){                           //[PC_2019_01_01]//
            //:No. The stored pointers take up more than         //[PC_2019_01_01]//
            //:1 byte each.                                      //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
            constpool_Print_SI("[constpool_addr_nex]:%d\n"                   //[PC_2019_01_01]//
               ,(int)constpool_addr_nex);                        //[PC_2019_01_01]//
            constpool_Halt("FUCK_BRO_2");                        //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        }else                                                    //[PC_2019_01_01]//
        if( constpool_addr_nex != (pointer_size*2) ){            //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
            constpool_Print_SI("[constpool_addr_nex]:%d\n"                   //[PC_2019_01_01]//
               ,(int)constpool_addr_nex);                        //[PC_2019_01_01]//
            constpool_Halt("FUCK_BRO_8");                        //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        }else{                                                   //[PC_2019_01_01]//
            constpool_Tell("[ChecksumPass]");                            //[PC_2019_01_01]//
        };;                                                      //[PC_2019_01_01]//
                                                                 //[PC_2019_01_01]//
        //====================================================// //[PC_2019_01_01]//
        //====================================================// //[PC_2019_01_01]//
        //====================================================// //[PC_2019_01_01]//
        
        ////////////////////////////////////////////////////////
        char** F61P5_names       = NULL;
        int    F61P5_count = 0   ;
    
        char* constpool_VK_KHR_swapchain=(
            "VK_KHR_swapchain"
        );;
        if( constpool_VK_KHR_swapchain ){ /** NOOP **/ };
    
        #define arr  F61P5_names ///////////////////////////////
        #define len  F61P5_count ///////////////////////////////
        #define ADD_STRING  CONSTPOOL_Add_ByVal  ///////////////
        arr=CONSTPOOL_Beg( sizeof(char*) );
    
                //:This entry, because of the F37 chunk of
                //:code, ends up being null. Error in
                //:allocator, or my conception of how this
                //:should work.
                ADD_STRING( &"VK_KHR_swapchain" );
    
        len=CONSTPOOL_End(      &arr     );
        #undef  ADD_STRING /////////////////////////////////////
        #undef  arr        /////////////////////////////////////
        #undef  len        /////////////////////////////////////
    
        // -------------------------------------------------- //
        if( constpool_addr_nex != (pointer_size*3) ){
    
            constpool_Print_SI("[constpool_addr_nex]:%d\n"
               ,(int)constpool_addr_nex);
            constpool_Halt("FUCK_BRO_24");
    
        }else{
            constpool_Tell("[ChecksumPass]\n");
        };;
        // -------------------------------------------------- //

        //:Is the previous addition still in tact?
        constpool_Print_STR(
            "[constpool_F37_names[1], AGAIN]:%s\n",
            constpool_F37_names[1]
        );;
    
    
        if(NULL==F61P5_names){
            constpool_Halt("[YourListIsNull]");
        };;
    
        //:Check to make sure you can access like you think:
        constpool_Print_SI(
            "[F61P5_count]:%d\n",
              F61P5_count
        );;
        constpool_Print_STR(
            "[F61P5_names[0]]:%s\n",
              F61P5_names[0]
        );;
        if(NULL==F61P5_names[0]){
            constpool_Halt("[WE_HAVE_PROBLEMS]\n");
        };;
        ////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    CONSTPOOL_Kill();
    constpool_has_been_unit_tested = 1;
    constpool_unit_test_is_running = 0;
    constpool_Tell("[END:CONSTPOOL_UnitTest]\n");
}//[;]//////////////////////////////////////////////////////////
int
CONSTPOOL_Main( void ){ /** AKA: CONSTPOOL_Demo() **/

    //:When compiling this file alone as a demo,
    //:use this main entry point for the file.

    printf("[BEG:CONSTPOOL_Main]\n"); fflush(stdout);

    CONSTPOOL_tell_me_about_everything = 1;
    CONSTPOOL_UnitTest();

    printf("[END:CONSTPOOL_Main]\n"); fflush(stdout);

    return( 0 );
}//[;]//////////////////////////////////////////////////////////
//#FILE_REGION[ CP._ (CONSTPOOL) ]END#########################//